var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:lru-cache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  ;(function () { // closure for web browsers
    
    if (typeof module === 'object' && module.exports) {
      module.exports = LRUCache
    } else {
      // just set the global for non-node platforms.
      this.LRUCache = LRUCache
    }
    
    function hOP (obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key)
    }
    
    function naiveLength () { return 1 }
    
    function LRUCache (options) {
      if (!(this instanceof LRUCache))
        return new LRUCache(options)
    
      if (typeof options === 'number')
        options = { max: options }
    
      if (!options)
        options = {}
    
      this._max = options.max
      // Kind of weird to have a default max of Infinity, but oh well.
      if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
        this._max = Infinity
    
      this._lengthCalculator = options.length || naiveLength
      if (typeof this._lengthCalculator !== "function")
        this._lengthCalculator = naiveLength
    
      this._allowStale = options.stale || false
      this._maxAge = options.maxAge || null
      this._dispose = options.dispose
      this.reset()
    }
    
    // resize the cache when the max changes.
    Object.defineProperty(LRUCache.prototype, "max",
      { set : function (mL) {
          if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
          this._max = mL
          if (this._length > this._max) trim(this)
        }
      , get : function () { return this._max }
      , enumerable : true
      })
    
    // resize the cache when the lengthCalculator changes.
    Object.defineProperty(LRUCache.prototype, "lengthCalculator",
      { set : function (lC) {
          if (typeof lC !== "function") {
            this._lengthCalculator = naiveLength
            this._length = this._itemCount
            for (var key in this._cache) {
              this._cache[key].length = 1
            }
          } else {
            this._lengthCalculator = lC
            this._length = 0
            for (var key in this._cache) {
              this._cache[key].length = this._lengthCalculator(this._cache[key].value)
              this._length += this._cache[key].length
            }
          }
    
          if (this._length > this._max) trim(this)
        }
      , get : function () { return this._lengthCalculator }
      , enumerable : true
      })
    
    Object.defineProperty(LRUCache.prototype, "length",
      { get : function () { return this._length }
      , enumerable : true
      })
    
    
    Object.defineProperty(LRUCache.prototype, "itemCount",
      { get : function () { return this._itemCount }
      , enumerable : true
      })
    
    LRUCache.prototype.forEach = function (fn, thisp) {
      thisp = thisp || this
      var i = 0;
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
        i++
        var hit = this._lruList[k]
        if (this._maxAge && (Date.now() - hit.now > this._maxAge)) {
          del(this, hit)
          if (!this._allowStale) hit = undefined
        }
        if (hit) {
          fn.call(thisp, hit.value, hit.key, this)
        }
      }
    }
    
    LRUCache.prototype.keys = function () {
      var keys = new Array(this._itemCount)
      var i = 0
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
        var hit = this._lruList[k]
        keys[i++] = hit.key
      }
      return keys
    }
    
    LRUCache.prototype.values = function () {
      var values = new Array(this._itemCount)
      var i = 0
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
        var hit = this._lruList[k]
        values[i++] = hit.value
      }
      return values
    }
    
    LRUCache.prototype.reset = function () {
      if (this._dispose && this._cache) {
        for (var k in this._cache) {
          this._dispose(k, this._cache[k].value)
        }
      }
    
      this._cache = Object.create(null) // hash of items by key
      this._lruList = Object.create(null) // list of items in order of use recency
      this._mru = 0 // most recently used
      this._lru = 0 // least recently used
      this._length = 0 // number of items in the list
      this._itemCount = 0
    }
    
    // Provided for debugging/dev purposes only. No promises whatsoever that
    // this API stays stable.
    LRUCache.prototype.dump = function () {
      return this._cache
    }
    
    LRUCache.prototype.dumpLru = function () {
      return this._lruList
    }
    
    LRUCache.prototype.set = function (key, value) {
      if (hOP(this._cache, key)) {
        // dispose of the old one before overwriting
        if (this._dispose) this._dispose(key, this._cache[key].value)
        if (this._maxAge) this._cache[key].now = Date.now()
        this._cache[key].value = value
        this.get(key)
        return true
      }
    
      var len = this._lengthCalculator(value)
      var age = this._maxAge ? Date.now() : 0
      var hit = new Entry(key, value, this._mru++, len, age)
    
      // oversized objects fall out of cache automatically.
      if (hit.length > this._max) {
        if (this._dispose) this._dispose(key, value)
        return false
      }
    
      this._length += hit.length
      this._lruList[hit.lu] = this._cache[key] = hit
      this._itemCount ++
    
      if (this._length > this._max) trim(this)
      return true
    }
    
    LRUCache.prototype.has = function (key) {
      if (!hOP(this._cache, key)) return false
      var hit = this._cache[key]
      if (this._maxAge && (Date.now() - hit.now > this._maxAge)) {
        return false
      }
      return true
    }
    
    LRUCache.prototype.get = function (key) {
      return get(this, key, true)
    }
    
    LRUCache.prototype.peek = function (key) {
      return get(this, key, false)
    }
    
    LRUCache.prototype.pop = function () {
      var hit = this._lruList[this._lru]
      del(this, hit)
      return hit || null
    }
    
    LRUCache.prototype.del = function (key) {
      del(this, this._cache[key])
    }
    
    function get (self, key, doUse) {
      var hit = self._cache[key]
      if (hit) {
        if (self._maxAge && (Date.now() - hit.now > self._maxAge)) {
          del(self, hit)
          if (!self._allowStale) hit = undefined
        } else {
          if (doUse) use(self, hit)
        }
        if (hit) hit = hit.value
      }
      return hit
    }
    
    function use (self, hit) {
      shiftLU(self, hit)
      hit.lu = self._mru ++
      self._lruList[hit.lu] = hit
    }
    
    function trim (self) {
      while (self._lru < self._mru && self._length > self._max)
        del(self, self._lruList[self._lru])
    }
    
    function shiftLU (self, hit) {
      delete self._lruList[ hit.lu ]
      while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
    }
    
    function del (self, hit) {
      if (hit) {
        if (self._dispose) self._dispose(hit.key, hit.value)
        self._length -= hit.length
        self._itemCount --
        delete self._cache[ hit.key ]
        shiftLU(self, hit)
      }
    }
    
    // classy, since V8 prefers predictable objects.
    function Entry (key, value, lu, length, now) {
      this.key = key
      this.value = value
      this.lu = lu
      this.length = length
      this.now = now
    }
    
    })()
    
  provide("lru-cache", module.exports);
}(global));

// pakmanager:sigmund
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = sigmund
    function sigmund (subject, maxSessions) {
        maxSessions = maxSessions || 10;
        var notes = [];
        var analysis = '';
        var RE = RegExp;
    
        function psychoAnalyze (subject, session) {
            if (session > maxSessions) return;
    
            if (typeof subject === 'function' ||
                typeof subject === 'undefined') {
                return;
            }
    
            if (typeof subject !== 'object' || !subject ||
                (subject instanceof RE)) {
                analysis += subject;
                return;
            }
    
            if (notes.indexOf(subject) !== -1 || session === maxSessions) return;
    
            notes.push(subject);
            analysis += '{';
            Object.keys(subject).forEach(function (issue, _, __) {
                // pseudo-private values.  skip those.
                if (issue.charAt(0) === '_') return;
                var to = typeof subject[issue];
                if (to === 'function' || to === 'undefined') return;
                analysis += issue;
                psychoAnalyze(subject[issue], session + 1);
            });
        }
        psychoAnalyze(subject, 0);
        return analysis;
    }
    
    // vim: set softtabstop=4 shiftwidth=4:
    
  provide("sigmund", module.exports);
}(global));

// pakmanager:core-util-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    
    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  provide("core-util-is", module.exports);
}(global));

// pakmanager:isarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
    
  provide("isarray", module.exports);
}(global));

// pakmanager:string_decoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var Buffer = require('buffer').Buffer;
    
    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         }
    
    
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    
    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
    
      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    };
    
    
    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;
    
        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
    
        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }
    
        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);
    
        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
    
        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
    
      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);
    
      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
    
      charStr += buffer.toString(this.encoding, 0, end);
    
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
    
      // or just emit the charStr
      return charStr;
    };
    
    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;
    
      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
    
        // See http://en.wikipedia.org/wiki/UTF-8#Description
    
        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
    
        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
    
        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
    
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
    
      return res;
    };
    
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
    
  provide("string_decoder", module.exports);
}(global));

// pakmanager:inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('util').inherits
    
  provide("inherits", module.exports);
}(global));

// pakmanager:amdefine
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /** vim: et:ts=4:sw=4:sts=4
     * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
     * Available via the MIT or new BSD license.
     * see: http://github.com/jrburke/amdefine for details
     */
    
    /*jslint node: true */
    /*global module, process */
    'use strict';
    
    /**
     * Creates a define for node.
     * @param {Object} module the "module" object that is defined by Node for the
     * current module.
     * @param {Function} [requireFn]. Node's require function for the current module.
     * It only needs to be passed in Node versions before 0.5, when module.require
     * did not exist.
     * @returns {Function} a define function that is usable for the current node
     * module.
     */
    function amdefine(module, requireFn) {
        'use strict';
        var defineCache = {},
            loaderCache = {},
            alreadyCalled = false,
            path = require('path'),
            makeRequire, stringRequire;
    
        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i+= 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
    
        function normalize(name, baseName) {
            var baseParts;
    
            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    baseParts = baseName.split('/');
                    baseParts = baseParts.slice(0, baseParts.length - 1);
                    baseParts = baseParts.concat(name.split('/'));
                    trimDots(baseParts);
                    name = baseParts.join('/');
                }
            }
    
            return name;
        }
    
        /**
         * Create the normalize() function passed to a loader plugin's
         * normalize method.
         */
        function makeNormalize(relName) {
            return function (name) {
                return normalize(name, relName);
            };
        }
    
        function makeLoad(id) {
            function load(value) {
                loaderCache[id] = value;
            }
    
            load.fromText = function (id, text) {
                //This one is difficult because the text can/probably uses
                //define, and any relative paths and requires should be relative
                //to that id was it would be found on disk. But this would require
                //bootstrapping a module/require fairly deeply from node core.
                //Not sure how best to go about that yet.
                throw new Error('amdefine does not implement load.fromText');
            };
    
            return load;
        }
    
        makeRequire = function (systemRequire, exports, module, relId) {
            function amdRequire(deps, callback) {
                if (typeof deps === 'string') {
                    //Synchronous, single module require('')
                    return stringRequire(systemRequire, exports, module, deps, relId);
                } else {
                    //Array of dependencies with a callback.
    
                    //Convert the dependencies to modules.
                    deps = deps.map(function (depName) {
                        return stringRequire(systemRequire, exports, module, depName, relId);
                    });
    
                    //Wait for next tick to call back the require call.
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
    
            amdRequire.toUrl = function (filePath) {
                if (filePath.indexOf('.') === 0) {
                    return normalize(filePath, path.dirname(module.filename));
                } else {
                    return filePath;
                }
            };
    
            return amdRequire;
        };
    
        //Favor explicit value, passed in if the module wants to support Node 0.4.
        requireFn = requireFn || function req() {
            return module.require.apply(module, arguments);
        };
    
        function runFactory(id, deps, factory) {
            var r, e, m, result;
    
            if (id) {
                e = loaderCache[id] = {};
                m = {
                    id: id,
                    uri: __filename,
                    exports: e
                };
                r = makeRequire(requireFn, e, m, id);
            } else {
                //Only support one define call per file
                if (alreadyCalled) {
                    throw new Error('amdefine with no module ID cannot be called more than once per file.');
                }
                alreadyCalled = true;
    
                //Use the real variables from node
                //Use module.exports for exports, since
                //the exports in here is amdefine exports.
                e = module.exports;
                m = module;
                r = makeRequire(requireFn, e, m, module.id);
            }
    
            //If there are dependencies, they are strings, so need
            //to convert them to dependency values.
            if (deps) {
                deps = deps.map(function (depName) {
                    return r(depName);
                });
            }
    
            //Call the factory with the right dependencies.
            if (typeof factory === 'function') {
                result = factory.apply(m.exports, deps);
            } else {
                result = factory;
            }
    
            if (result !== undefined) {
                m.exports = result;
                if (id) {
                    loaderCache[id] = m.exports;
                }
            }
        }
    
        stringRequire = function (systemRequire, exports, module, id, relId) {
            //Split the ID by a ! so that
            var index = id.indexOf('!'),
                originalId = id,
                prefix, plugin;
    
            if (index === -1) {
                id = normalize(id, relId);
    
                //Straight module lookup. If it is one of the special dependencies,
                //deal with it, otherwise, delegate to node.
                if (id === 'require') {
                    return makeRequire(systemRequire, exports, module, relId);
                } else if (id === 'exports') {
                    return exports;
                } else if (id === 'module') {
                    return module;
                } else if (loaderCache.hasOwnProperty(id)) {
                    return loaderCache[id];
                } else if (defineCache[id]) {
                    runFactory.apply(null, defineCache[id]);
                    return loaderCache[id];
                } else {
                    if(systemRequire) {
                        return systemRequire(originalId);
                    } else {
                        throw new Error('No module with ID: ' + id);
                    }
                }
            } else {
                //There is a plugin in play.
                prefix = id.substring(0, index);
                id = id.substring(index + 1, id.length);
    
                plugin = stringRequire(systemRequire, exports, module, prefix, relId);
    
                if (plugin.normalize) {
                    id = plugin.normalize(id, makeNormalize(relId));
                } else {
                    //Normalize the ID normally.
                    id = normalize(id, relId);
                }
    
                if (loaderCache[id]) {
                    return loaderCache[id];
                } else {
                    plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
    
                    return loaderCache[id];
                }
            }
        };
    
        //Create a define function specific to the module asking for amdefine.
        function define(id, deps, factory) {
            if (Array.isArray(id)) {
                factory = deps;
                deps = id;
                id = undefined;
            } else if (typeof id !== 'string') {
                factory = id;
                id = deps = undefined;
            }
    
            if (deps && !Array.isArray(deps)) {
                factory = deps;
                deps = undefined;
            }
    
            if (!deps) {
                deps = ['require', 'exports', 'module'];
            }
    
            //Set up properties for this module. If an ID, then use
            //internal cache. If no ID, then use the external variables
            //for this node module.
            if (id) {
                //Put the module in deep freeze until there is a
                //require call for it.
                defineCache[id] = [id, deps, factory];
            } else {
                runFactory(id, deps, factory);
            }
        }
    
        //define.require, which has access to all the values in the
        //cache. Useful for AMD modules that all have IDs in the file,
        //but need to finally export a value to node based on one of those
        //IDs.
        define.require = function (id) {
            if (loaderCache[id]) {
                return loaderCache[id];
            }
    
            if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            }
        };
    
        define.amd = {};
    
        return define;
    }
    
    module.exports = amdefine;
    
  provide("amdefine", module.exports);
}(global));

// pakmanager:source-map-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    void (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory)
      } else if (typeof exports === "object") {
        module.exports = factory()
      } else {
        root.sourceMappingURL = factory()
      }
    }(this, function() {
    
      var innerRegex = /[#@] sourceMappingURL=([^\s'"]*)/
    
      var regex = RegExp(
        "(?:" +
          "/\\*" +
          "(?:\\s*\r?\n(?://)?)?" +
          "(?:" + innerRegex.source + ")" +
          "\\s*" +
          "\\*/" +
          "|" +
          "//(?:" + innerRegex.source + ")" +
        ")" +
        "\\s*$"
      )
    
      return {
    
        regex: regex,
        _innerRegex: innerRegex,
    
        getFrom: function(code) {
          var match = code.match(regex)
          return (match ? match[1] || match[2] || "" : null)
        },
    
        existsIn: function(code) {
          return regex.test(code)
        },
    
        removeFrom: function(code) {
          return code.replace(regex, "")
        },
    
        insertBefore: function(code, string) {
          var match = code.match(regex)
          if (match) {
            return code.slice(0, match.index) + string + code.slice(match.index)
          } else {
            return code + string
          }
        }
      }
    
    }));
    
  provide("source-map-url", module.exports);
}(global));

// pakmanager:urix
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    var path = require("path")
    
    "use strict"
    
    function urix(aPath) {
      if (path.sep === "\\") {
        return aPath
          .replace(/\\/g, "/")
          .replace(/^[a-z]:\/?/i, "/")
      }
      return aPath
    }
    
    module.exports = urix
    
  provide("urix", module.exports);
}(global));

// pakmanager:resolve-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    void (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory)
      } else if (typeof exports === "object") {
        module.exports = factory()
      } else {
        root.resolveUrl = factory()
      }
    }(this, function() {
    
      function resolveUrl(/* ...urls */) {
        var numUrls = arguments.length
    
        if (numUrls === 0) {
          throw new Error("resolveUrl requires at least one argument; got none.")
        }
    
        var base = document.createElement("base")
        base.href = arguments[0]
    
        if (numUrls === 1) {
          return base.href
        }
    
        var head = document.getElementsByTagName("head")[0]
        head.insertBefore(base, head.firstChild)
    
        var a = document.createElement("a")
        var resolved
    
        for (var index = 1; index < numUrls; index++) {
          a.href = arguments[index]
          resolved = a.href
          base.href = resolved
        }
    
        head.removeChild(base)
    
        return resolved
      }
    
      return resolveUrl
    
    }));
    
  provide("resolve-url", module.exports);
}(global));

// pakmanager:wordwrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wordwrap = module.exports = function (start, stop, params) {
        if (typeof start === 'object') {
            params = start;
            start = params.start;
            stop = params.stop;
        }
        
        if (typeof stop === 'object') {
            params = stop;
            start = start || params.start;
            stop = undefined;
        }
        
        if (!stop) {
            stop = start;
            start = 0;
        }
        
        if (!params) params = {};
        var mode = params.mode || 'soft';
        var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
        
        return function (text) {
            var chunks = text.toString()
                .split(re)
                .reduce(function (acc, x) {
                    if (mode === 'hard') {
                        for (var i = 0; i < x.length; i += stop - start) {
                            acc.push(x.slice(i, i + stop - start));
                        }
                    }
                    else acc.push(x)
                    return acc;
                }, [])
            ;
            
            return chunks.reduce(function (lines, rawChunk) {
                if (rawChunk === '') return lines;
                
                var chunk = rawChunk.replace(/\t/g, '    ');
                
                var i = lines.length - 1;
                if (lines[i].length + chunk.length > stop) {
                    lines[i] = lines[i].replace(/\s+$/, '');
                    
                    chunk.split(/\n/).forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else if (chunk.match(/\n/)) {
                    var xs = chunk.split(/\n/);
                    lines[i] += xs.shift();
                    xs.forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else {
                    lines[i] += chunk;
                }
                
                return lines;
            }, [ new Array(start + 1).join(' ') ]).join('\n');
        };
    };
    
    wordwrap.soft = wordwrap;
    
    wordwrap.hard = function (start, stop) {
        return wordwrap(start, stop, { mode : 'hard' });
    };
    
  provide("wordwrap", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
        
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                setArg(m[1], m[2], arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function setKey (obj, keys, value) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            if (o[key] === undefined) o[key] = {};
            o = o[key];
        });
        
        var key = keys[keys.length - 1];
        if (o[key] === undefined || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:acorn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke and various contributors and
    // released under an MIT license. The Unicode regexps (for identifiers
    // and whitespace) were taken from [Esprima](http://esprima.org) by
    // Ariya Hidayat.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/marijnh/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/marijnh/acorn/issues
    //
    // This file defines the main parser interface. The library also comes
    // with a [error-tolerant parser][dammit] and an
    // [abstract syntax tree walker][walk], defined in other files.
    //
    // [dammit]: acorn_loose.js
    // [walk]: util/walk.js
    
    (function(root, mod) {
      if (typeof exports == "object" && typeof module == "object") return mod(exports); // CommonJS
      if (typeof define == "function" && define.amd) return define(["exports"], mod); // AMD
      mod(root.acorn || (root.acorn = {})); // Plain browser env
    })(this, function(exports) {
      "use strict";
    
      exports.version = "0.9.0";
    
      // The main exported interface (under `self.acorn` when in the
      // browser) is a `parse` function that takes a code string and
      // returns an abstract syntax tree as specified by [Mozilla parser
      // API][api], with the caveat that inline XML is not recognized.
      //
      // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
    
      var options, input, inputLen, sourceFile;
    
      exports.parse = function(inpt, opts) {
        input = String(inpt); inputLen = input.length;
        setOptions(opts);
        initTokenState();
        initParserState();
        return parseTopLevel(options.program);
      };
    
      // A second optional argument can be given to further configure
      // the parser process. These options are recognized:
    
      var defaultOptions = exports.defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must
        // be either 3, or 5, or 6. This influences support for strict
        // mode, the set of reserved words, support for getters and
        // setters and other features.
        ecmaVersion: 5,
        // Turn on `strictSemicolons` to prevent the parser from doing
        // automatic semicolon insertion.
        strictSemicolons: false,
        // When `allowTrailingCommas` is false, the parser will not allow
        // trailing commas in array and object literals.
        allowTrailingCommas: true,
        // By default, reserved words are not enforced. Enable
        // `forbidReserved` to enforce them. When this option has the
        // value "everywhere", reserved words and keywords can also not be
        // used as property names.
        forbidReserved: false,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokenize() returns. Note that you are not
        // allowed to call the parser from the callback—that will
        // corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null
      };
    
      // This function tries to parse a single expression at a given
      // offset in a string. Useful for parsing mixed-language formats
      // that embed JavaScript expressions.
    
      exports.parseExpressionAt = function(inpt, pos, opts) {
        input = String(inpt); inputLen = input.length;
        setOptions(opts);
        initTokenState(pos);
        initParserState();
        return parseExpression();
      };
    
      var isArray = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    
      function setOptions(opts) {
        options = opts || {};
        for (var opt in defaultOptions) if (!has(options, opt))
          options[opt] = defaultOptions[opt];
        sourceFile = options.sourceFile || null;
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function (token) {
            tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          var comments = options.onComment;
          options.onComment = function (block, text, start, end, startLoc, endLoc) {
            var comment = {
              type: block ? 'Block' : 'Line',
              value: text,
              start: start,
              end: end
            };
            if (options.locations) {
              comment.loc = new SourceLocation();
              comment.loc.start = startLoc;
              comment.loc.end = endLoc;
            }
            if (options.ranges)
              comment.range = [start, end];
            comments.push(comment);
          };
        }
        isKeyword = options.ecmaVersion >= 6 ? isEcma6Keyword : isEcma5AndLessKeyword;
      }
    
      // The `getLineInfo` function is mostly useful when the
      // `locations` option is off (for performance reasons) and you
      // want to find the line/column position for a given character
      // offset. `input` should be the code string that the offset refers
      // into.
    
      var getLineInfo = exports.getLineInfo = function(input, offset) {
        for (var line = 1, cur = 0;;) {
          lineBreak.lastIndex = cur;
          var match = lineBreak.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else break;
        }
        return {line: line, column: offset - cur};
      };
    
      function Token() {
        this.type = tokType;
        this.value = tokVal;
        this.start = tokStart;
        this.end = tokEnd;
        if (options.locations) {
          this.loc = new SourceLocation();
          this.loc.end = tokEndLoc;
          // TODO: remove in next major release
          this.startLoc = tokStartLoc;
          this.endLoc = tokEndLoc;
        }
        if (options.ranges)
          this.range = [tokStart, tokEnd];
      }
    
      exports.Token = Token;
    
      // Acorn is organized as a tokenizer and a recursive-descent parser.
      // The `tokenize` export provides an interface to the tokenizer.
      // Because the tokenizer is optimized for being efficiently used by
      // the Acorn parser itself, this interface is somewhat crude and not
      // very modular. Performing another parse or call to `tokenize` will
      // reset the internal state, and invalidate existing tokenizers.
    
      exports.tokenize = function(inpt, opts) {
        input = String(inpt); inputLen = input.length;
        setOptions(opts);
        initTokenState();
    
        function getToken(forceRegexp) {
          lastEnd = tokEnd;
          readToken(forceRegexp);
          return new Token();
        }
        getToken.jumpTo = function(pos, reAllowed) {
          tokPos = pos;
          if (options.locations) {
            tokCurLine = 1;
            tokLineStart = lineBreak.lastIndex = 0;
            var match;
            while ((match = lineBreak.exec(input)) && match.index < pos) {
              ++tokCurLine;
              tokLineStart = match.index + match[0].length;
            }
          }
          tokRegexpAllowed = reAllowed;
          skipSpace();
        };
        return getToken;
      };
    
      // State is kept in (closure-)global variables. We already saw the
      // `options`, `input`, and `inputLen` variables above.
    
      // The current position of the tokenizer in the input.
    
      var tokPos;
    
      // The start and end offsets of the current token.
    
      var tokStart, tokEnd;
    
      // When `options.locations` is true, these hold objects
      // containing the tokens start and end line/column pairs.
    
      var tokStartLoc, tokEndLoc;
    
      // The type and value of the current token. Token types are objects,
      // named by variables against which they can be compared, and
      // holding properties that describe them (indicating, for example,
      // the precedence of an infix operator, and the original name of a
      // keyword token). The kind of value that's held in `tokVal` depends
      // on the type of the token. For literals, it is the literal value,
      // for operators, the operator name, and so on.
    
      var tokType, tokVal;
    
      // Internal state for the tokenizer. To distinguish between division
      // operators and regular expressions, it remembers whether the last
      // token was one that is allowed to be followed by an expression.
      // (If it is, a slash is probably a regexp, if it isn't it's a
      // division operator. See the `parseStatement` function for a
      // caveat.)
    
      var tokRegexpAllowed;
    
      // When `options.locations` is true, these are used to keep
      // track of the current line, and know when a new line has been
      // entered.
    
      var tokCurLine, tokLineStart;
    
      // These store the position of the previous token, which is useful
      // when finishing a node and assigning its `end` position.
    
      var lastStart, lastEnd, lastEndLoc;
    
      // This is the parser's state. `inFunction` is used to reject
      // `return` statements outside of functions, `inGenerator` to
      // reject `yield`s outside of generators, `labels` to verify
      // that `break` and `continue` have somewhere to jump to, and
      // `strict` indicates whether strict mode is on.
    
      var inFunction, inGenerator, labels, strict;
    
      // This counter is used for checking that arrow expressions did
      // not contain nested parentheses in argument list.
    
      var metParenL;
    
      // This is used by parser for detecting if it's inside ES6
      // Template String. If it is, it should treat '$' as prefix before
      // '{expression}' and everything else as string literals.
    
      var inTemplate;
    
      function initParserState() {
        lastStart = lastEnd = tokPos;
        if (options.locations) lastEndLoc = new Position;
        inFunction = inGenerator = strict = false;
        labels = [];
        readToken();
      }
    
      // This function is used to raise exceptions on parse errors. It
      // takes an offset integer (into the current `input`) to indicate
      // the location of the error, attaches the position to the end
      // of the error message, and then raises a `SyntaxError` with that
      // message.
    
      function raise(pos, message) {
        var loc = getLineInfo(input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
        throw err;
      }
    
      // Reused empty array added for node fields that are always empty.
    
      var empty = [];
    
      // ## Token types
    
      // The assignment of fine-grained, information-carrying type objects
      // allows the tokenizer to store the information it has about a
      // token in a way that is very cheap for the parser to look up.
    
      // All token type variables start with an underscore, to make them
      // easy to recognize.
    
      // These are the general types. The `type` property is only used to
      // make them recognizeable when debugging.
    
      var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
      var _name = {type: "name"}, _eof = {type: "eof"};
    
      // Keyword tokens. The `keyword` property (also used in keyword-like
      // operators) indicates that the token originated from an
      // identifier-like word, which is used when parsing property names.
      //
      // The `beforeExpr` property is used to disambiguate between regular
      // expressions and divisions. It is set on all token types that can
      // be followed by an expression (thus, a slash after them would be a
      // regular expression).
      //
      // `isLoop` marks a keyword as starting a loop, which is important
      // to know when parsing a label, in order to allow or disallow
      // continue jumps to that label.
    
      var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
      var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
      var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
      var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
      var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
      var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
      var _let = {keyword: "let"}, _const = {keyword: "const"};
      var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
      var _this = {keyword: "this"};
      var _class = {keyword: "class"}, _extends = {keyword: "extends", beforeExpr: true};
      var _export = {keyword: "export"}, _import = {keyword: "import"};
      var _yield = {keyword: "yield", beforeExpr: true};
    
      // The keywords that denote values.
    
      var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
      var _false = {keyword: "false", atomValue: false};
    
      // Some keywords are treated as regular operators. `in` sometimes
      // (when parsing `for`) needs to be tested against specifically, so
      // we assign a variable name to it for quick comparing.
    
      var _in = {keyword: "in", binop: 7, beforeExpr: true};
    
      // Map keyword names to token types.
    
      var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
                          "continue": _continue, "debugger": _debugger, "default": _default,
                          "do": _do, "else": _else, "finally": _finally, "for": _for,
                          "function": _function, "if": _if, "return": _return, "switch": _switch,
                          "throw": _throw, "try": _try, "var": _var, "let": _let, "const": _const,
                          "while": _while, "with": _with,
                          "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
                          "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
                          "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
                          "void": {keyword: "void", prefix: true, beforeExpr: true},
                          "delete": {keyword: "delete", prefix: true, beforeExpr: true},
                          "class": _class, "extends": _extends,
                          "export": _export, "import": _import, "yield": _yield};
    
      // Punctuation token types. Again, the `type` property is purely for debugging.
    
      var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
      var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
      var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
      var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _ellipsis = {type: "..."}, _question = {type: "?", beforeExpr: true};
      var _arrow = {type: "=>", beforeExpr: true}, _bquote = {type: "`"}, _dollarBraceL = {type: "${", beforeExpr: true};
    
      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator. `isUpdate` specifies that the node produced by
      // the operator should be of type UpdateExpression rather than
      // simply UnaryExpression (`++` and `--`).
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.
    
      var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
      var _assign = {isAssign: true, beforeExpr: true};
      var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
      var _logicalOR = {binop: 1, beforeExpr: true};
      var _logicalAND = {binop: 2, beforeExpr: true};
      var _bitwiseOR = {binop: 3, beforeExpr: true};
      var _bitwiseXOR = {binop: 4, beforeExpr: true};
      var _bitwiseAND = {binop: 5, beforeExpr: true};
      var _equality = {binop: 6, beforeExpr: true};
      var _relational = {binop: 7, beforeExpr: true};
      var _bitShift = {binop: 8, beforeExpr: true};
      var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
      var _modulo = {binop: 10, beforeExpr: true};
    
      // '*' may be multiply or have special meaning in ES6
      var _star = {binop: 10, beforeExpr: true};
    
      // Provide access to the token types for external users of the
      // tokenizer.
    
      exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
                          parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
                          dot: _dot, ellipsis: _ellipsis, question: _question, slash: _slash, eq: _eq,
                          name: _name, eof: _eof, num: _num, regexp: _regexp, string: _string,
                          arrow: _arrow, bquote: _bquote, dollarBraceL: _dollarBraceL};
      for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];
    
      // This is a trick taken from Esprima. It turns out that, on
      // non-Chrome browsers, to check whether a string is in a set, a
      // predicate containing a big ugly `switch` statement is faster than
      // a regular expression, and on Chrome the two are about on par.
      // This function uses `eval` (non-lexical) to produce such a
      // predicate from a space-separated string of words.
      //
      // It starts by sorting the words by length.
    
      function makePredicate(words) {
        words = words.split(" ");
        var f = "", cats = [];
        out: for (var i = 0; i < words.length; ++i) {
          for (var j = 0; j < cats.length; ++j)
            if (cats[j][0].length == words[i].length) {
              cats[j].push(words[i]);
              continue out;
            }
          cats.push([words[i]]);
        }
        function compareTo(arr) {
          if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
          f += "switch(str){";
          for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
          f += "return true}return false;";
        }
    
        // When there are more than three length categories, an outer
        // switch first dispatches on the lengths, to save on comparisons.
    
        if (cats.length > 3) {
          cats.sort(function(a, b) {return b.length - a.length;});
          f += "switch(str.length){";
          for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
          }
          f += "}";
    
        // Otherwise, simply generate a flat `switch` statement.
    
        } else {
          compareTo(words);
        }
        return new Function("str", f);
      }
    
      // The ECMAScript 3 reserved word list.
    
      var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
    
      // ECMAScript 5 reserved words.
    
      var isReservedWord5 = makePredicate("class enum extends super const export import");
    
      // The additional reserved words in strict mode.
    
      var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
    
      // The forbidden variable names in strict mode.
    
      var isStrictBadIdWord = makePredicate("eval arguments");
    
      // And the keywords.
    
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    
      var isEcma5AndLessKeyword = makePredicate(ecma5AndLessKeywords);
    
      var isEcma6Keyword = makePredicate(ecma5AndLessKeywords + " let const class extends export import yield");
    
      var isKeyword = isEcma5AndLessKeyword;
    
      // ## Character categories
    
      // Big ugly regular expressions that match characters in the
      // whitespace, identifier, and identifier-start categories. These
      // are only applied when a character is found to actually have a
      // code point above 128.
      // Generated by `tools/generate-identifier-regex.js`.
    
      var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19B0-\u19C0\u19C8\u19C9\u19D0-\u19D9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    
      // Whether a single character denotes a newline.
    
      var newline = /[\n\r\u2028\u2029]/;
    
      // Matches a whole line break (where CRLF is considered a single
      // line break). Used to count lines.
    
      var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;
    
      // Test whether a given character code starts an identifier.
    
      var isIdentifierStart = exports.isIdentifierStart = function(code) {
        if (code < 65) return code === 36;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123)return true;
        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
      };
    
      // Test whether a given character is part of an identifier.
    
      var isIdentifierChar = exports.isIdentifierChar = function(code) {
        if (code < 48) return code === 36;
        if (code < 58) return true;
        if (code < 65) return false;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123)return true;
        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
      };
    
      // ## Tokenizer
    
      // These are used when `options.locations` is on, for the
      // `tokStartLoc` and `tokEndLoc` properties.
    
      function Position() {
        this.line = tokCurLine;
        this.column = tokPos - tokLineStart;
      }
    
      // Reset the token state. Used at the start of a parse.
    
      function initTokenState(pos) {
        if (pos) {
          tokPos = pos;
          tokLineStart = Math.max(0, input.lastIndexOf("\n", pos));
          tokCurLine = input.slice(0, tokLineStart).split(newline).length;
        } else {
          tokCurLine = 1;
          tokPos = tokLineStart = 0;
        }
        tokRegexpAllowed = true;
        metParenL = 0;
        inTemplate = false;
        skipSpace();
      }
    
      // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
      // `tokRegexpAllowed`, and skips the space after the token, so that
      // the next one's `tokStart` will point at the right position.
    
      function finishToken(type, val, shouldSkipSpace) {
        tokEnd = tokPos;
        if (options.locations) tokEndLoc = new Position;
        tokType = type;
        if (shouldSkipSpace !== false) skipSpace();
        tokVal = val;
        tokRegexpAllowed = type.beforeExpr;
        if (options.onToken) {
          options.onToken(new Token());
        }
      }
    
      function skipBlockComment() {
        var startLoc = options.onComment && options.locations && new Position;
        var start = tokPos, end = input.indexOf("*/", tokPos += 2);
        if (end === -1) raise(tokPos - 2, "Unterminated comment");
        tokPos = end + 2;
        if (options.locations) {
          lineBreak.lastIndex = start;
          var match;
          while ((match = lineBreak.exec(input)) && match.index < tokPos) {
            ++tokCurLine;
            tokLineStart = match.index + match[0].length;
          }
        }
        if (options.onComment)
          options.onComment(true, input.slice(start + 2, end), start, tokPos,
                            startLoc, options.locations && new Position);
      }
    
      function skipLineComment(startSkip) {
        var start = tokPos;
        var startLoc = options.onComment && options.locations && new Position;
        var ch = input.charCodeAt(tokPos+=startSkip);
        while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
          ++tokPos;
          ch = input.charCodeAt(tokPos);
        }
        if (options.onComment)
          options.onComment(false, input.slice(start + startSkip, tokPos), start, tokPos,
                            startLoc, options.locations && new Position);
      }
    
      // Called at the start of the parse and after every token. Skips
      // whitespace and comments, and.
    
      function skipSpace() {
        while (tokPos < inputLen) {
          var ch = input.charCodeAt(tokPos);
          if (ch === 32) { // ' '
            ++tokPos;
          } else if (ch === 13) {
            ++tokPos;
            var next = input.charCodeAt(tokPos);
            if (next === 10) {
              ++tokPos;
            }
            if (options.locations) {
              ++tokCurLine;
              tokLineStart = tokPos;
            }
          } else if (ch === 10 || ch === 8232 || ch === 8233) {
            ++tokPos;
            if (options.locations) {
              ++tokCurLine;
              tokLineStart = tokPos;
            }
          } else if (ch > 8 && ch < 14) {
            ++tokPos;
          } else if (ch === 47) { // '/'
            var next = input.charCodeAt(tokPos + 1);
            if (next === 42) { // '*'
              skipBlockComment();
            } else if (next === 47) { // '/'
              skipLineComment(2);
            } else break;
          } else if (ch === 160) { // '\xa0'
            ++tokPos;
          } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++tokPos;
          } else {
            break;
          }
        }
      }
    
      // ### Token reading
    
      // This is the function that is called to fetch the next token. It
      // is somewhat obscure, because it works in character codes rather
      // than characters, and because operator parsing has been inlined
      // into it.
      //
      // All in the name of speed.
      //
      // The `forceRegexp` parameter is used in the one case where the
      // `tokRegexpAllowed` trick does not work. See `parseStatement`.
    
      function readToken_dot() {
        var next = input.charCodeAt(tokPos + 1);
        if (next >= 48 && next <= 57) return readNumber(true);
        var next2 = input.charCodeAt(tokPos + 2);
        if (options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
          tokPos += 3;
          return finishToken(_ellipsis);
        } else {
          ++tokPos;
          return finishToken(_dot);
        }
      }
    
      function readToken_slash() { // '/'
        var next = input.charCodeAt(tokPos + 1);
        if (tokRegexpAllowed) {++tokPos; return readRegexp();}
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(_slash, 1);
      }
    
      function readToken_mult_modulo(code) { // '%*'
        var next = input.charCodeAt(tokPos + 1);
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(code === 42 ? _star : _modulo, 1);
      }
    
      function readToken_pipe_amp(code) { // '|&'
        var next = input.charCodeAt(tokPos + 1);
        if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
      }
    
      function readToken_caret() { // '^'
        var next = input.charCodeAt(tokPos + 1);
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(_bitwiseXOR, 1);
      }
    
      function readToken_plus_min(code) { // '+-'
        var next = input.charCodeAt(tokPos + 1);
        if (next === code) {
          if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
              newline.test(input.slice(lastEnd, tokPos))) {
            // A `-->` line comment
            skipLineComment(3);
            skipSpace();
            return readToken();
          }
          return finishOp(_incDec, 2);
        }
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(_plusMin, 1);
      }
    
      function readToken_lt_gt(code) { // '<>'
        var next = input.charCodeAt(tokPos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
          if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
          return finishOp(_bitShift, size);
        }
        if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
            input.charCodeAt(tokPos + 3) == 45) {
          // `<!--`, an XML-style comment that should be interpreted as a line comment
          skipLineComment(4);
          skipSpace();
          return readToken();
        }
        if (next === 61)
          size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
        return finishOp(_relational, size);
      }
    
      function readToken_eq_excl(code) { // '=!', '=>'
        var next = input.charCodeAt(tokPos + 1);
        if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
        if (code === 61 && next === 62 && options.ecmaVersion >= 6) { // '=>'
          tokPos += 2;
          return finishToken(_arrow);
        }
        return finishOp(code === 61 ? _eq : _prefix, 1);
      }
    
      // Get token inside ES6 template (special rules work there).
    
      function getTemplateToken(code) {
        // '`' and '${' have special meanings, but they should follow
        // string (can be empty)
        if (tokType === _string) {
          if (code === 96) { // '`'
            ++tokPos;
            return finishToken(_bquote);
          } else
          if (code === 36 && input.charCodeAt(tokPos + 1) === 123) { // '${'
            tokPos += 2;
            return finishToken(_dollarBraceL);
          }
        }
    
        if (code === 125) { // '}'
          ++tokPos;
          return finishToken(_braceR, undefined, false);
        }
    
        // anything else is considered string literal
        return readTmplString();
      }
    
      function getTokenFromCode(code) {
        switch (code) {
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46: // '.'
          return readToken_dot();
    
        // Punctuation tokens.
        case 40: ++tokPos; return finishToken(_parenL);
        case 41: ++tokPos; return finishToken(_parenR);
        case 59: ++tokPos; return finishToken(_semi);
        case 44: ++tokPos; return finishToken(_comma);
        case 91: ++tokPos; return finishToken(_bracketL);
        case 93: ++tokPos; return finishToken(_bracketR);
        case 123: ++tokPos; return finishToken(_braceL);
        case 125: ++tokPos; return finishToken(_braceR);
        case 58: ++tokPos; return finishToken(_colon);
        case 63: ++tokPos; return finishToken(_question);
    
        case 96: // '`'
          if (options.ecmaVersion >= 6) {
            ++tokPos;
            return finishToken(_bquote, undefined, false);
          }
    
        case 48: // '0'
          var next = input.charCodeAt(tokPos + 1);
          if (next === 120 || next === 88) return readRadixNumber(16); // '0x', '0X' - hex number
          if (options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) return readRadixNumber(8); // '0o', '0O' - octal number
            if (next === 98 || next === 66) return readRadixNumber(2); // '0b', '0B' - binary number
          }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
          return readNumber(false);
    
        // Quotes produce strings.
        case 34: case 39: // '"', "'"
          return readString(code);
    
        // Operators are parsed inline in tiny state machines. '=' (61) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
    
        case 47: // '/'
          return readToken_slash();
    
        case 37: case 42: // '%*'
          return readToken_mult_modulo(code);
    
        case 124: case 38: // '|&'
          return readToken_pipe_amp(code);
    
        case 94: // '^'
          return readToken_caret();
    
        case 43: case 45: // '+-'
          return readToken_plus_min(code);
    
        case 60: case 62: // '<>'
          return readToken_lt_gt(code);
    
        case 61: case 33: // '=!'
          return readToken_eq_excl(code);
    
        case 126: // '~'
          return finishOp(_prefix, 1);
        }
    
        return false;
      }
    
      function readToken(forceRegexp) {
        if (!forceRegexp) tokStart = tokPos;
        else tokPos = tokStart + 1;
        if (options.locations) tokStartLoc = new Position;
        if (forceRegexp) return readRegexp();
        if (tokPos >= inputLen) return finishToken(_eof);
    
        var code = input.charCodeAt(tokPos);
    
        if (inTemplate) return getTemplateToken(code);
    
        // Identifier or keyword. '\uXXXX' sequences are allowed in
        // identifiers, so '\' also dispatches to that.
        if (isIdentifierStart(code) || code === 92 /* '\' */) return readWord();
    
        var tok = getTokenFromCode(code);
    
        if (tok === false) {
          // If we are here, we either found a non-ASCII identifier
          // character, or something that's entirely disallowed.
          var ch = String.fromCharCode(code);
          if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
          raise(tokPos, "Unexpected character '" + ch + "'");
        }
        return tok;
      }
    
      function finishOp(type, size) {
        var str = input.slice(tokPos, tokPos + size);
        tokPos += size;
        finishToken(type, str);
      }
    
      // Parse a regular expression. Some context-awareness is necessary,
      // since a '/' inside a '[]' set does not end the expression.
    
      function readRegexp() {
        var content = "", escaped, inClass, start = tokPos;
        for (;;) {
          if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
          var ch = input.charAt(tokPos);
          if (newline.test(ch)) raise(start, "Unterminated regular expression");
          if (!escaped) {
            if (ch === "[") inClass = true;
            else if (ch === "]" && inClass) inClass = false;
            else if (ch === "/" && !inClass) break;
            escaped = ch === "\\";
          } else escaped = false;
          ++tokPos;
        }
        var content = input.slice(start, tokPos);
        ++tokPos;
        // Need to use `readWord1` because '\uXXXX' sequences are allowed
        // here (don't ask).
        var mods = readWord1();
        if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regular expression flag");
        try {
          var value = new RegExp(content, mods);
        } catch (e) {
          if (e instanceof SyntaxError) raise(start, "Error parsing regular expression: " + e.message);
          raise(e);
        }
        return finishToken(_regexp, value);
      }
    
      // Read an integer in the given radix. Return null if zero digits
      // were read, the integer value otherwise. When `len` is given, this
      // will return `null` unless the integer has exactly `len` digits.
    
      function readInt(radix, len) {
        var start = tokPos, total = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          var code = input.charCodeAt(tokPos), val;
          if (code >= 97) val = code - 97 + 10; // a
          else if (code >= 65) val = code - 65 + 10; // A
          else if (code >= 48 && code <= 57) val = code - 48; // 0-9
          else val = Infinity;
          if (val >= radix) break;
          ++tokPos;
          total = total * radix + val;
        }
        if (tokPos === start || len != null && tokPos - start !== len) return null;
    
        return total;
      }
    
      function readRadixNumber(radix) {
        tokPos += 2; // 0x
        var val = readInt(radix);
        if (val == null) raise(tokStart + 2, "Expected number in radix " + radix);
        if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
        return finishToken(_num, val);
      }
    
      // Read an integer, octal integer, or floating-point number.
    
      function readNumber(startsWithDot) {
        var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
        if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
        if (input.charCodeAt(tokPos) === 46) {
          ++tokPos;
          readInt(10);
          isFloat = true;
        }
        var next = input.charCodeAt(tokPos);
        if (next === 69 || next === 101) { // 'eE'
          next = input.charCodeAt(++tokPos);
          if (next === 43 || next === 45) ++tokPos; // '+-'
          if (readInt(10) === null) raise(start, "Invalid number");
          isFloat = true;
        }
        if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
    
        var str = input.slice(start, tokPos), val;
        if (isFloat) val = parseFloat(str);
        else if (!octal || str.length === 1) val = parseInt(str, 10);
        else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
        else val = parseInt(str, 8);
        return finishToken(_num, val);
      }
    
      // Read a string value, interpreting backslash-escapes.
    
      function readCodePoint() {
        var ch = input.charCodeAt(tokPos), code;
    
        if (ch === 123) {
          if (options.ecmaVersion < 6) unexpected();
          ++tokPos;
          code = readHexChar(input.indexOf('}', tokPos) - tokPos);
          ++tokPos;
          if (code > 0x10FFFF) unexpected();
        } else {
          code = readHexChar(4);
        }
    
        // UTF-16 Encoding
        if (code <= 0xFFFF) {
          return String.fromCharCode(code);
        }
        var cu1 = ((code - 0x10000) >> 10) + 0xD800;
        var cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
      }
    
      function readString(quote) {
        ++tokPos;
        var out = "";
        for (;;) {
          if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
          var ch = input.charCodeAt(tokPos);
          if (ch === quote) {
            ++tokPos;
            return finishToken(_string, out);
          }
          if (ch === 92) { // '\'
            out += readEscapedChar();
          } else {
            ++tokPos;
            if (newline.test(String.fromCharCode(ch))) {
              raise(tokStart, "Unterminated string constant");
            }
            out += String.fromCharCode(ch); // '\'
          }
        }
      }
    
      function readTmplString() {
        var out = "";
        for (;;) {
          if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
          var ch = input.charCodeAt(tokPos);
          if (ch === 96 || ch === 36 && input.charCodeAt(tokPos + 1) === 123) // '`', '${'
            return finishToken(_string, out);
          if (ch === 92) { // '\'
            out += readEscapedChar();
          } else {
            ++tokPos;
            if (newline.test(String.fromCharCode(ch))) {
              if (ch === 13 && input.charCodeAt(tokPos) === 10) {
                ++tokPos;
                ch = 10;
              }
              if (options.locations) {
                ++tokCurLine;
                tokLineStart = tokPos;
              }
            }
            out += String.fromCharCode(ch); // '\'
          }
        }
      }
    
      // Used to read escaped characters
    
      function readEscapedChar() {
        var ch = input.charCodeAt(++tokPos);
        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
        if (octal) octal = octal[0];
        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
        if (octal === "0") octal = null;
        ++tokPos;
        if (octal) {
          if (strict) raise(tokPos - 2, "Octal literal in strict mode");
          tokPos += octal.length - 1;
          return String.fromCharCode(parseInt(octal, 8));
        } else {
          switch (ch) {
            case 110: return "\n"; // 'n' -> '\n'
            case 114: return "\r"; // 'r' -> '\r'
            case 120: return String.fromCharCode(readHexChar(2)); // 'x'
            case 117: return readCodePoint(); // 'u'
            case 85: return String.fromCharCode(readHexChar(8)); // 'U'
            case 116: return "\t"; // 't' -> '\t'
            case 98: return "\b"; // 'b' -> '\b'
            case 118: return "\u000b"; // 'v' -> '\u000b'
            case 102: return "\f"; // 'f' -> '\f'
            case 48: return "\0"; // 0 -> '\0'
            case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\r\n'
            case 10: // ' \n'
              if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
              return "";
            default: return String.fromCharCode(ch);
          }
        }
      }
    
      // Used to read character escape sequences ('\x', '\u', '\U').
    
      function readHexChar(len) {
        var n = readInt(16, len);
        if (n === null) raise(tokStart, "Bad character escape sequence");
        return n;
      }
    
      // Used to signal to callers of `readWord1` whether the word
      // contained any escape sequences. This is needed because words with
      // escape sequences must not be interpreted as keywords.
    
      var containsEsc;
    
      // Read an identifier, and return it as a string. Sets `containsEsc`
      // to whether the word contained a '\u' escape.
      //
      // Only builds up the word character-by-character when it actually
      // containeds an escape, as a micro-optimization.
    
      function readWord1() {
        containsEsc = false;
        var word, first = true, start = tokPos;
        for (;;) {
          var ch = input.charCodeAt(tokPos);
          if (isIdentifierChar(ch)) {
            if (containsEsc) word += input.charAt(tokPos);
            ++tokPos;
          } else if (ch === 92) { // "\"
            if (!containsEsc) word = input.slice(start, tokPos);
            containsEsc = true;
            if (input.charCodeAt(++tokPos) != 117) // "u"
              raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
            ++tokPos;
            var esc = readHexChar(4);
            var escStr = String.fromCharCode(esc);
            if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
            if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
              raise(tokPos - 4, "Invalid Unicode escape");
            word += escStr;
          } else {
            break;
          }
          first = false;
        }
        return containsEsc ? word : input.slice(start, tokPos);
      }
    
      // Read an identifier or keyword token. Will check for reserved
      // words when necessary.
    
      function readWord() {
        var word = readWord1();
        var type = _name;
        if (!containsEsc && isKeyword(word))
          type = keywordTypes[word];
        return finishToken(type, word);
      }
    
      // ## Parser
    
      // A recursive descent parser operates by defining functions for all
      // syntactic elements, and recursively calling those, each function
      // advancing the input stream and returning an AST node. Precedence
      // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
      // instead of `(!x)[1]` is handled by the fact that the parser
      // function that parses unary prefix operators is called first, and
      // in turn calls the function that parses `[]` subscripts — that
      // way, it'll receive the node for `x[1]` already parsed, and wraps
      // *that* in the unary operator node.
      //
      // Acorn uses an [operator precedence parser][opp] to handle binary
      // operator precedence, because it is much more compact than using
      // the technique outlined above, which uses different, nesting
      // functions to specify precedence, for all of the ten binary
      // precedence levels that JavaScript defines.
      //
      // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
    
      // ### Parser utilities
    
      // Continue to the next token.
    
      function next() {
        lastStart = tokStart;
        lastEnd = tokEnd;
        lastEndLoc = tokEndLoc;
        readToken();
      }
    
      // Enter strict mode. Re-reads the next token to please pedantic
      // tests ("use strict"; 010; -- should fail).
    
      function setStrict(strct) {
        strict = strct;
        tokPos = tokStart;
        if (options.locations) {
          while (tokPos < tokLineStart) {
            tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
            --tokCurLine;
          }
        }
        skipSpace();
        readToken();
      }
    
      // Start an AST node, attaching a start offset.
    
      function Node() {
        this.type = null;
        this.start = tokStart;
        this.end = null;
      }
    
      exports.Node = Node;
    
      function SourceLocation() {
        this.start = tokStartLoc;
        this.end = null;
        if (sourceFile !== null) this.source = sourceFile;
      }
    
      function startNode() {
        var node = new Node();
        if (options.locations)
          node.loc = new SourceLocation();
        if (options.directSourceFile)
          node.sourceFile = options.directSourceFile;
        if (options.ranges)
          node.range = [tokStart, 0];
        return node;
      }
    
      // Start a node whose start offset information should be based on
      // the start of another node. For example, a binary operator node is
      // only started after its left-hand side has already been parsed.
    
      function startNodeFrom(other) {
        var node = new Node();
        node.start = other.start;
        if (options.locations) {
          node.loc = new SourceLocation();
          node.loc.start = other.loc.start;
        }
        if (options.ranges)
          node.range = [other.range[0], 0];
    
        return node;
      }
    
      // Finish an AST node, adding `type` and `end` properties.
    
      function finishNode(node, type) {
        node.type = type;
        node.end = lastEnd;
        if (options.locations)
          node.loc.end = lastEndLoc;
        if (options.ranges)
          node.range[1] = lastEnd;
        return node;
      }
    
      // Test whether a statement node is the string literal `"use strict"`.
    
      function isUseStrict(stmt) {
        return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
          stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
      }
    
      // Predicate that tests whether the next token is of the given
      // type, and if yes, consumes it as a side effect.
    
      function eat(type) {
        if (tokType === type) {
          next();
          return true;
        } else {
          return false;
        }
      }
    
      // Test whether a semicolon can be inserted at the current position.
    
      function canInsertSemicolon() {
        return !options.strictSemicolons &&
          (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
      }
    
      // Consume a semicolon, or, failing that, see if we are allowed to
      // pretend that there is a semicolon at this position.
    
      function semicolon() {
        if (!eat(_semi) && !canInsertSemicolon()) unexpected();
      }
    
      // Expect a token of a given type. If found, consume it, otherwise,
      // raise an unexpected token error.
    
      function expect(type) {
        eat(type) || unexpected();
      }
    
      // Raise an unexpected token error.
    
      function unexpected(pos) {
        raise(pos != null ? pos : tokStart, "Unexpected token");
      }
    
      // Checks if hash object has a property.
    
      function has(obj, propName) {
        return Object.prototype.hasOwnProperty.call(obj, propName);
      }
      // Convert existing expression atom to assignable pattern
      // if possible.
    
      function toAssignable(node, allowSpread, checkType) {
        if (options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
            case "MemberExpression":
              break;
    
            case "ObjectExpression":
              node.type = "ObjectPattern";
              for (var i = 0; i < node.properties.length; i++) {
                var prop = node.properties[i];
                if (prop.kind !== "init") unexpected(prop.key.start);
                toAssignable(prop.value, false, checkType);
              }
              break;
    
            case "ArrayExpression":
              node.type = "ArrayPattern";
              for (var i = 0, lastI = node.elements.length - 1; i <= lastI; i++) {
                toAssignable(node.elements[i], i === lastI, checkType);
              }
              break;
    
            case "SpreadElement":
              if (allowSpread) {
                toAssignable(node.argument, false, checkType);
                checkSpreadAssign(node.argument);
              } else {
                unexpected(node.start);
              }
              break;
    
            default:
              if (checkType) unexpected(node.start);
          }
        }
        return node;
      }
    
      // Checks if node can be assignable spread argument.
    
      function checkSpreadAssign(node) {
        if (node.type !== "Identifier" && node.type !== "ArrayPattern")
          unexpected(node.start);
      }
    
      // Verify that argument names are not repeated, and it does not
      // try to bind the words `eval` or `arguments`.
    
      function checkFunctionParam(param, nameHash) {
        switch (param.type) {
          case "Identifier":
            if (isStrictReservedWord(param.name) || isStrictBadIdWord(param.name))
              raise(param.start, "Defining '" + param.name + "' in strict mode");
            if (has(nameHash, param.name))
              raise(param.start, "Argument name clash in strict mode");
            nameHash[param.name] = true;
            break;
    
          case "ObjectPattern":
            for (var i = 0; i < param.properties.length; i++)
              checkFunctionParam(param.properties[i].value, nameHash);
            break;
    
          case "ArrayPattern":
            for (var i = 0; i < param.elements.length; i++)
              checkFunctionParam(param.elements[i], nameHash);
            break;
        }
      }
    
      // Check if property name clashes with already added.
      // Object/class getters and setters are not allowed to clash —
      // either with each other or with an init property — and in
      // strict mode, init properties are also not allowed to be repeated.
    
      function checkPropClash(prop, propHash) {
        if (prop.computed) return;
        var key = prop.key, name;
        switch (key.type) {
          case "Identifier": name = key.name; break;
          case "Literal": name = String(key.value); break;
          default: return;
        }
        var kind = prop.kind || "init", other;
        if (has(propHash, name)) {
          other = propHash[name];
          var isGetSet = kind !== "init";
          if ((strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
            raise(key.start, "Redefinition of property");
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      }
    
      // Verify that a node is an lval — something that can be assigned
      // to.
    
      function checkLVal(expr, isBinding) {
        switch (expr.type) {
          case "Identifier":
            if (strict && (isStrictBadIdWord(expr.name) || isStrictReservedWord(expr.name)))
              raise(expr.start, isBinding
                ? "Binding " + expr.name + " in strict mode"
                : "Assigning to " + expr.name + " in strict mode"
              );
            break;
    
          case "MemberExpression":
            if (!isBinding) break;
    
          case "ObjectPattern":
            for (var i = 0; i < expr.properties.length; i++)
              checkLVal(expr.properties[i].value, isBinding);
            break;
    
          case "ArrayPattern":
            for (var i = 0; i < expr.elements.length; i++) {
              var elem = expr.elements[i];
              if (elem) checkLVal(elem, isBinding);
            }
            break;
    
          case "SpreadElement":
            break;
    
          default:
            raise(expr.start, "Assigning to rvalue");
        }
      }
    
      // ### Statement parsing
    
      // Parse a program. Initializes the parser, reads any number of
      // statements, and wraps them in a Program node.  Optionally takes a
      // `program` argument.  If present, the statements will be appended
      // to its body instead of creating a new node.
    
      function parseTopLevel(program) {
        var node = program || startNode(), first = true;
        if (!program) node.body = [];
        while (tokType !== _eof) {
          var stmt = parseStatement();
          node.body.push(stmt);
          if (first && isUseStrict(stmt)) setStrict(true);
          first = false;
        }
        return finishNode(node, "Program");
      }
    
      var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};
    
      // Parse a single statement.
      //
      // If expecting a statement and finding a slash operator, parse a
      // regular expression literal. This is to handle cases like
      // `if (foo) /blah/.exec(foo);`, where looking at the previous token
      // does not help.
    
      function parseStatement() {
        if (tokType === _slash || tokType === _assign && tokVal == "/=")
          readToken(true);
    
        var starttype = tokType, node = startNode();
    
        // Most types of statements are recognized by the keyword they
        // start with. Many are trivial to parse, some require a bit of
        // complexity.
    
        switch (starttype) {
        case _break: case _continue: return parseBreakContinueStatement(node, starttype.keyword);
        case _debugger: return parseDebuggerStatement(node);
        case _do: return parseDoStatement(node);
        case _for: return parseForStatement(node);
        case _function: return parseFunctionStatement(node);
        case _class: return parseClass(node, true);
        case _if: return parseIfStatement(node);
        case _return: return parseReturnStatement(node);
        case _switch: return parseSwitchStatement(node);
        case _throw: return parseThrowStatement(node);
        case _try: return parseTryStatement(node);
        case _var: case _let: case _const: return parseVarStatement(node, starttype.keyword);
        case _while: return parseWhileStatement(node);
        case _with: return parseWithStatement(node);
        case _braceL: return parseBlock(); // no point creating a function for this
        case _semi: return parseEmptyStatement(node);
        case _export: return parseExport(node);
        case _import: return parseImport(node);
    
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
        default:
          var maybeName = tokVal, expr = parseExpression();
          if (starttype === _name && expr.type === "Identifier" && eat(_colon))
            return parseLabeledStatement(node, maybeName, expr);
          else return parseExpressionStatement(node, expr);
        }
      }
    
      function parseBreakContinueStatement(node, keyword) {
        var isBreak = keyword == "break";
        next();
        if (eat(_semi) || canInsertSemicolon()) node.label = null;
        else if (tokType !== _name) unexpected();
        else {
          node.label = parseIdent();
          semicolon();
        }
    
        // Verify that there is an actual destination to break or
        // continue to.
        for (var i = 0; i < labels.length; ++i) {
          var lab = labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
            if (node.label && isBreak) break;
          }
        }
        if (i === labels.length) raise(node.start, "Unsyntactic " + keyword);
        return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
    
      function parseDebuggerStatement(node) {
        next();
        semicolon();
        return finishNode(node, "DebuggerStatement");
      }
    
      function parseDoStatement(node) {
        next();
        labels.push(loopLabel);
        node.body = parseStatement();
        labels.pop();
        expect(_while);
        node.test = parseParenExpression();
        semicolon();
        return finishNode(node, "DoWhileStatement");
      }
    
      // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
      // loop is non-trivial. Basically, we have to parse the init `var`
      // statement or expression, disallowing the `in` operator (see
      // the second parameter to `parseExpression`), and then check
      // whether the next token is `in` or `of`. When there is no init
      // part (semicolon immediately after the opening parenthesis), it
      // is a regular `for` loop.
    
      function parseForStatement(node) {
        next();
        labels.push(loopLabel);
        expect(_parenL);
        if (tokType === _semi) return parseFor(node, null);
        if (tokType === _var || tokType === _let) {
          var init = startNode(), varKind = tokType.keyword, isLet = tokType === _let;
          next();
          parseVar(init, true, varKind);
          finishNode(init, "VariableDeclaration");
          if ((tokType === _in || (options.ecmaVersion >= 6 && tokType === _name && tokVal === "of")) && init.declarations.length === 1 &&
              !(isLet && init.declarations[0].init))
            return parseForIn(node, init);
          return parseFor(node, init);
        }
        var init = parseExpression(false, true);
        if (tokType === _in || (options.ecmaVersion >= 6 && tokType === _name && tokVal === "of")) {
          checkLVal(init);
          return parseForIn(node, init);
        }
        return parseFor(node, init);
      }
    
      function parseFunctionStatement(node) {
        next();
        return parseFunction(node, true);
      }
    
      function parseIfStatement(node) {
        next();
        node.test = parseParenExpression();
        node.consequent = parseStatement();
        node.alternate = eat(_else) ? parseStatement() : null;
        return finishNode(node, "IfStatement");
      }
    
      function parseReturnStatement(node) {
        if (!inFunction && !options.allowReturnOutsideFunction)
          raise(tokStart, "'return' outside of function");
        next();
    
        // In `return` (and `break`/`continue`), the keywords with
        // optional arguments, we eagerly look for a semicolon or the
        // possibility to insert one.
    
        if (eat(_semi) || canInsertSemicolon()) node.argument = null;
        else { node.argument = parseExpression(); semicolon(); }
        return finishNode(node, "ReturnStatement");
      }
    
      function parseSwitchStatement(node) {
        next();
        node.discriminant = parseParenExpression();
        node.cases = [];
        expect(_braceL);
        labels.push(switchLabel);
    
        // Statements under must be grouped (by label) in SwitchCase
        // nodes. `cur` is used to keep the node that we are currently
        // adding statements to.
    
        for (var cur, sawDefault; tokType != _braceR;) {
          if (tokType === _case || tokType === _default) {
            var isCase = tokType === _case;
            if (cur) finishNode(cur, "SwitchCase");
            node.cases.push(cur = startNode());
            cur.consequent = [];
            next();
            if (isCase) cur.test = parseExpression();
            else {
              if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
              cur.test = null;
            }
            expect(_colon);
          } else {
            if (!cur) unexpected();
            cur.consequent.push(parseStatement());
          }
        }
        if (cur) finishNode(cur, "SwitchCase");
        next(); // Closing brace
        labels.pop();
        return finishNode(node, "SwitchStatement");
      }
    
      function parseThrowStatement(node) {
        next();
        if (newline.test(input.slice(lastEnd, tokStart)))
          raise(lastEnd, "Illegal newline after throw");
        node.argument = parseExpression();
        semicolon();
        return finishNode(node, "ThrowStatement");
      }
    
      function parseTryStatement(node) {
        next();
        node.block = parseBlock();
        node.handler = null;
        if (tokType === _catch) {
          var clause = startNode();
          next();
          expect(_parenL);
          clause.param = parseIdent();
          if (strict && isStrictBadIdWord(clause.param.name))
            raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
          expect(_parenR);
          clause.guard = null;
          clause.body = parseBlock();
          node.handler = finishNode(clause, "CatchClause");
        }
        node.guardedHandlers = empty;
        node.finalizer = eat(_finally) ? parseBlock() : null;
        if (!node.handler && !node.finalizer)
          raise(node.start, "Missing catch or finally clause");
        return finishNode(node, "TryStatement");
      }
    
      function parseVarStatement(node, kind) {
        next();
        parseVar(node, false, kind);
        semicolon();
        return finishNode(node, "VariableDeclaration");
      }
    
      function parseWhileStatement(node) {
        next();
        node.test = parseParenExpression();
        labels.push(loopLabel);
        node.body = parseStatement();
        labels.pop();
        return finishNode(node, "WhileStatement");
      }
    
      function parseWithStatement(node) {
        if (strict) raise(tokStart, "'with' in strict mode");
        next();
        node.object = parseParenExpression();
        node.body = parseStatement();
        return finishNode(node, "WithStatement");
      }
    
      function parseEmptyStatement(node) {
        next();
        return finishNode(node, "EmptyStatement");
      }
    
      function parseLabeledStatement(node, maybeName, expr) {
        for (var i = 0; i < labels.length; ++i)
          if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
        var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
        labels.push({name: maybeName, kind: kind});
        node.body = parseStatement();
        labels.pop();
        node.label = expr;
        return finishNode(node, "LabeledStatement");
      }
    
      function parseExpressionStatement(node, expr) {
        node.expression = expr;
        semicolon();
        return finishNode(node, "ExpressionStatement");
      }
    
      // Used for constructs like `switch` and `if` that insist on
      // parentheses around their expression.
    
      function parseParenExpression() {
        expect(_parenL);
        var val = parseExpression();
        expect(_parenR);
        return val;
      }
    
      // Parse a semicolon-enclosed block of statements, handling `"use
      // strict"` declarations when `allowStrict` is true (used for
      // function bodies).
    
      function parseBlock(allowStrict) {
        var node = startNode(), first = true, oldStrict;
        node.body = [];
        expect(_braceL);
        while (!eat(_braceR)) {
          var stmt = parseStatement();
          node.body.push(stmt);
          if (first && allowStrict && isUseStrict(stmt)) {
            oldStrict = strict;
            setStrict(strict = true);
          }
          first = false;
        }
        if (oldStrict === false) setStrict(false);
        return finishNode(node, "BlockStatement");
      }
    
      // Parse a regular `for` loop. The disambiguation code in
      // `parseStatement` will already have parsed the init statement or
      // expression.
    
      function parseFor(node, init) {
        node.init = init;
        expect(_semi);
        node.test = tokType === _semi ? null : parseExpression();
        expect(_semi);
        node.update = tokType === _parenR ? null : parseExpression();
        expect(_parenR);
        node.body = parseStatement();
        labels.pop();
        return finishNode(node, "ForStatement");
      }
    
      // Parse a `for`/`in` and `for`/`of` loop, which are almost
      // same from parser's perspective.
    
      function parseForIn(node, init) {
        var type = tokType === _in ? "ForInStatement" : "ForOfStatement";
        next();
        node.left = init;
        node.right = parseExpression();
        expect(_parenR);
        node.body = parseStatement();
        labels.pop();
        return finishNode(node, type);
      }
    
      // Parse a list of variable declarations.
    
      function parseVar(node, noIn, kind) {
        node.declarations = [];
        node.kind = kind;
        for (;;) {
          var decl = startNode();
          decl.id = options.ecmaVersion >= 6 ? toAssignable(parseExprAtom()) : parseIdent();
          checkLVal(decl.id, true);
          decl.init = eat(_eq) ? parseExpression(true, noIn) : (kind === _const.keyword ? unexpected() : null);
          node.declarations.push(finishNode(decl, "VariableDeclarator"));
          if (!eat(_comma)) break;
        }
        return node;
      }
    
      // ### Expression parsing
    
      // These nest, from the most general expression type at the top to
      // 'atomic', nondivisible expression types at the bottom. Most of
      // the functions will simply let the function(s) below them parse,
      // and, *if* the syntactic construct they handle is present, wrap
      // the AST node that the inner parser gave them in another node.
    
      // Parse a full expression. The arguments are used to forbid comma
      // sequences (in argument lists, array literals, or object literals)
      // or the `in` operator (in for loops initalization expressions).
    
      function parseExpression(noComma, noIn) {
        var expr = parseMaybeAssign(noIn);
        if (!noComma && tokType === _comma) {
          var node = startNodeFrom(expr);
          node.expressions = [expr];
          while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
          return finishNode(node, "SequenceExpression");
        }
        return expr;
      }
    
      // Parse an assignment expression. This includes applications of
      // operators like `+=`.
    
      function parseMaybeAssign(noIn) {
        var left = parseMaybeConditional(noIn);
        if (tokType.isAssign) {
          var node = startNodeFrom(left);
          node.operator = tokVal;
          node.left = tokType === _eq ? toAssignable(left) : left;
          checkLVal(left);
          next();
          node.right = parseMaybeAssign(noIn);
          return finishNode(node, "AssignmentExpression");
        }
        return left;
      }
    
      // Parse a ternary conditional (`?:`) operator.
    
      function parseMaybeConditional(noIn) {
        var expr = parseExprOps(noIn);
        if (eat(_question)) {
          var node = startNodeFrom(expr);
          node.test = expr;
          node.consequent = parseExpression(true);
          expect(_colon);
          node.alternate = parseExpression(true, noIn);
          return finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
    
      // Start the precedence parser.
    
      function parseExprOps(noIn) {
        return parseExprOp(parseMaybeUnary(), -1, noIn);
      }
    
      // Parse binary operators with the operator precedence parsing
      // algorithm. `left` is the left-hand side of the operator.
      // `minPrec` provides context that allows the function to stop and
      // defer further parser to one of its callers when it encounters an
      // operator that has a lower precedence than the set it is parsing.
    
      function parseExprOp(left, minPrec, noIn) {
        var prec = tokType.binop;
        if (prec != null && (!noIn || tokType !== _in)) {
          if (prec > minPrec) {
            var node = startNodeFrom(left);
            node.left = left;
            node.operator = tokVal;
            var op = tokType;
            next();
            node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
            var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
            return parseExprOp(exprNode, minPrec, noIn);
          }
        }
        return left;
      }
    
      // Parse unary operators, both prefix and postfix.
    
      function parseMaybeUnary() {
        if (tokType.prefix) {
          var node = startNode(), update = tokType.isUpdate;
          node.operator = tokVal;
          node.prefix = true;
          tokRegexpAllowed = true;
          next();
          node.argument = parseMaybeUnary();
          if (update) checkLVal(node.argument);
          else if (strict && node.operator === "delete" &&
                   node.argument.type === "Identifier")
            raise(node.start, "Deleting local variable in strict mode");
          return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        }
        var expr = parseExprSubscripts();
        while (tokType.postfix && !canInsertSemicolon()) {
          var node = startNodeFrom(expr);
          node.operator = tokVal;
          node.prefix = false;
          node.argument = expr;
          checkLVal(expr);
          next();
          expr = finishNode(node, "UpdateExpression");
        }
        return expr;
      }
    
      // Parse call, dot, and `[]`-subscript expressions.
    
      function parseExprSubscripts() {
        return parseSubscripts(parseExprAtom());
      }
    
      function parseSubscripts(base, noCalls) {
        if (eat(_dot)) {
          var node = startNodeFrom(base);
          node.object = base;
          node.property = parseIdent(true);
          node.computed = false;
          return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
        } else if (eat(_bracketL)) {
          var node = startNodeFrom(base);
          node.object = base;
          node.property = parseExpression();
          node.computed = true;
          expect(_bracketR);
          return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
        } else if (!noCalls && eat(_parenL)) {
          var node = startNodeFrom(base);
          node.callee = base;
          node.arguments = parseExprList(_parenR, false);
          return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
        } else if (tokType === _bquote) {
          var node = startNodeFrom(base);
          node.tag = base;
          node.quasi = parseTemplate();
          return parseSubscripts(finishNode(node, "TaggedTemplateExpression"), noCalls);
        } return base;
      }
    
      // Parse an atomic expression — either a single token that is an
      // expression, an expression started by a keyword like `function` or
      // `new`, or an expression wrapped in punctuation like `()`, `[]`,
      // or `{}`.
    
      function parseExprAtom() {
        switch (tokType) {
        case _this:
          var node = startNode();
          next();
          return finishNode(node, "ThisExpression");
    
        case _yield:
          if (inGenerator) return parseYield();
    
        case _name:
          var id = parseIdent(tokType !== _name);
          if (eat(_arrow)) {
            return parseArrowExpression(startNodeFrom(id), [id]);
          }
          return id;
    
        case _num: case _string: case _regexp:
          var node = startNode();
          node.value = tokVal;
          node.raw = input.slice(tokStart, tokEnd);
          next();
          return finishNode(node, "Literal");
    
        case _null: case _true: case _false:
          var node = startNode();
          node.value = tokType.atomValue;
          node.raw = tokType.keyword;
          next();
          return finishNode(node, "Literal");
    
        case _parenL:
          var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart, val, exprList;
          next();
          // check whether this is generator comprehension or regular expression
          if (options.ecmaVersion >= 6 && tokType === _for) {
            val = parseComprehension(startNode(), true);
          } else {
            var oldParenL = ++metParenL;
            if (tokType !== _parenR) {
              val = parseExpression();
              exprList = val.type === "SequenceExpression" ? val.expressions : [val];
            } else {
              exprList = [];
            }
            expect(_parenR);
            // if '=>' follows '(...)', convert contents to arguments
            if (metParenL === oldParenL && eat(_arrow)) {
              val = parseArrowExpression(startNode(), exprList);
            } else {
              // forbid '()' before everything but '=>'
              if (!val) unexpected(lastStart);
              // forbid '...' in sequence expressions
              if (options.ecmaVersion >= 6) {
                for (var i = 0; i < exprList.length; i++) {
                  if (exprList[i].type === "SpreadElement") unexpected();
                }
              }
            }
          }
          val.start = tokStart1;
          val.end = lastEnd;
          if (options.locations) {
            val.loc.start = tokStartLoc1;
            val.loc.end = lastEndLoc;
          }
          if (options.ranges) {
            val.range = [tokStart1, lastEnd];
          }
          return val;
    
        case _bracketL:
          var node = startNode();
          next();
          // check whether this is array comprehension or regular array
          if (options.ecmaVersion >= 6 && tokType === _for) {
            return parseComprehension(node, false);
          }
          node.elements = parseExprList(_bracketR, true, true);
          return finishNode(node, "ArrayExpression");
    
        case _braceL:
          return parseObj();
    
        case _function:
          var node = startNode();
          next();
          return parseFunction(node, false);
    
        case _class:
          return parseClass(startNode(), false);
    
        case _new:
          return parseNew();
    
        case _ellipsis:
          return parseSpread();
    
        case _bquote:
          return parseTemplate();
    
        default:
          unexpected();
        }
      }
    
      // New's precedence is slightly tricky. It must allow its argument
      // to be a `[]` or dot subscript expression, but not a call — at
      // least, not without wrapping it in parentheses. Thus, it uses the
    
      function parseNew() {
        var node = startNode();
        next();
        node.callee = parseSubscripts(parseExprAtom(), true);
        if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
        else node.arguments = empty;
        return finishNode(node, "NewExpression");
      }
    
      // Parse spread element '...expr'
    
      function parseSpread() {
        var node = startNode();
        next();
        node.argument = parseExpression(true);
        return finishNode(node, "SpreadElement");
      }
    
      // Parse template expression.
    
      function parseTemplate() {
        var node = startNode();
        node.expressions = [];
        node.quasis = [];
        inTemplate = true;
        next();
        for (;;) {
          var elem = startNode();
          elem.value = {cooked: tokVal, raw: input.slice(tokStart, tokEnd)};
          elem.tail = false;
          next();
          node.quasis.push(finishNode(elem, "TemplateElement"));
          if (tokType === _bquote) { // '`', end of template
            elem.tail = true;
            break;
          }
          inTemplate = false;
          expect(_dollarBraceL);
          node.expressions.push(parseExpression());
          inTemplate = true;
          // hack to include previously skipped space
          tokPos = tokEnd;
          expect(_braceR);
        }
        inTemplate = false;
        next();
        return finishNode(node, "TemplateLiteral");
      }
    
      // Parse an object literal.
    
      function parseObj() {
        var node = startNode(), first = true, propHash = {};
        node.properties = [];
        next();
        while (!eat(_braceR)) {
          if (!first) {
            expect(_comma);
            if (options.allowTrailingCommas && eat(_braceR)) break;
          } else first = false;
    
          var prop = startNode(), isGenerator;
          if (options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            isGenerator = eat(_star);
          }
          parsePropertyName(prop);
          if (eat(_colon)) {
            prop.value = parseExpression(true);
            prop.kind = "init";
          } else if (options.ecmaVersion >= 6 && tokType === _parenL) {
            prop.kind = "init";
            prop.method = true;
            prop.value = parseMethod(isGenerator);
          } else if (options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                     (prop.key.name === "get" || prop.key.name === "set")) {
            if (isGenerator) unexpected();
            prop.kind = prop.key.name;
            parsePropertyName(prop);
            prop.value = parseMethod(false);
          } else if (options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            prop.kind = "init";
            prop.value = prop.key;
            prop.shorthand = true;
          } else unexpected();
    
          checkPropClash(prop, propHash);
          node.properties.push(finishNode(prop, "Property"));
        }
        return finishNode(node, "ObjectExpression");
      }
    
      function parsePropertyName(prop) {
        if (options.ecmaVersion >= 6) {
          if (eat(_bracketL)) {
            prop.computed = true;
            prop.key = parseExpression();
            expect(_bracketR);
            return;
          } else {
            prop.computed = false;
          }
        }
        prop.key = (tokType === _num || tokType === _string) ? parseExprAtom() : parseIdent(true);
      }
    
      // Initialize empty function node.
    
      function initFunction(node) {
        node.id = null;
        node.params = [];
        if (options.ecmaVersion >= 6) {
          node.defaults = [];
          node.rest = null;
          node.generator = false;
        }
      }
    
      // Parse a function declaration or literal (depending on the
      // `isStatement` parameter).
    
      function parseFunction(node, isStatement, allowExpressionBody) {
        initFunction(node);
        if (options.ecmaVersion >= 6) {
          node.generator = eat(_star);
        }
        if (isStatement || tokType === _name) {
          node.id = parseIdent();
        }
        parseFunctionParams(node);
        parseFunctionBody(node, allowExpressionBody);
        return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      }
    
      // Parse object or class method.
    
      function parseMethod(isGenerator) {
        var node = startNode();
        initFunction(node);
        parseFunctionParams(node);
        var allowExpressionBody;
        if (options.ecmaVersion >= 6) {
          node.generator = isGenerator;
          allowExpressionBody = true;
        } else {
          allowExpressionBody = false;
        }
        parseFunctionBody(node, allowExpressionBody);
        return finishNode(node, "FunctionExpression");
      }
    
      // Parse arrow function expression with given parameters.
    
      function parseArrowExpression(node, params) {
        initFunction(node);
    
        var defaults = node.defaults, hasDefaults = false;
    
        for (var i = 0, lastI = params.length - 1; i <= lastI; i++) {
          var param = params[i];
    
          if (param.type === "AssignmentExpression" && param.operator === "=") {
            hasDefaults = true;
            params[i] = param.left;
            defaults.push(param.right);
          } else {
            toAssignable(param, i === lastI, true);
            defaults.push(null);
            if (param.type === "SpreadElement") {
              params.length--;
              node.rest = param.argument;
              break;
            }
          }
        }
    
        node.params = params;
        if (!hasDefaults) node.defaults = [];
    
        parseFunctionBody(node, true);
        return finishNode(node, "ArrowFunctionExpression");
      }
    
      // Parse function parameters.
    
      function parseFunctionParams(node) {
        var defaults = [], hasDefaults = false;
    
        expect(_parenL);
        for (;;) {
          if (eat(_parenR)) {
            break;
          } else if (options.ecmaVersion >= 6 && eat(_ellipsis)) {
            node.rest = toAssignable(parseExprAtom(), false, true);
            checkSpreadAssign(node.rest);
            expect(_parenR);
            defaults.push(null);
            break;
          } else {
            node.params.push(options.ecmaVersion >= 6 ? toAssignable(parseExprAtom(), false, true) : parseIdent());
            if (options.ecmaVersion >= 6) {
              if (eat(_eq)) {
                hasDefaults = true;
                defaults.push(parseExpression(true));
              } else {
                defaults.push(null);
              }
            }
            if (!eat(_comma)) {
              expect(_parenR);
              break;
            }
          }
        }
    
        if (hasDefaults) node.defaults = defaults;
      }
    
      // Parse function body and check parameters.
    
      function parseFunctionBody(node, allowExpression) {
        var isExpression = allowExpression && tokType !== _braceL;
    
        if (isExpression) {
          node.body = parseExpression(true);
          node.expression = true;
        } else {
          // Start a new scope with regard to labels and the `inFunction`
          // flag (restore them to their old value afterwards).
          var oldInFunc = inFunction, oldInGen = inGenerator, oldLabels = labels;
          inFunction = true; inGenerator = node.generator; labels = [];
          node.body = parseBlock(true);
          node.expression = false;
          inFunction = oldInFunc; inGenerator = oldInGen; labels = oldLabels;
        }
    
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (strict || !isExpression && node.body.body.length && isUseStrict(node.body.body[0])) {
          var nameHash = {};
          if (node.id)
            checkFunctionParam(node.id, {});
          for (var i = 0; i < node.params.length; i++)
            checkFunctionParam(node.params[i], nameHash);
          if (node.rest)
            checkFunctionParam(node.rest, nameHash);
        }
      }
    
      // Parse a class declaration or literal (depending on the
      // `isStatement` parameter).
    
      function parseClass(node, isStatement) {
        next();
        node.id = tokType === _name ? parseIdent() : isStatement ? unexpected() : null;
        node.superClass = eat(_extends) ? parseExpression() : null;
        var classBody = startNode(), methodHash = {}, staticMethodHash = {};
        classBody.body = [];
        expect(_braceL);
        while (!eat(_braceR)) {
          var method = startNode();
          if (tokType === _name && tokVal === "static") {
            next();
            method['static'] = true;
          } else {
            method['static'] = false;
          }
          var isGenerator = eat(_star);
          parsePropertyName(method);
          if (tokType === _name && !method.computed && method.key.type === "Identifier" &&
              (method.key.name === "get" || method.key.name === "set")) {
            if (isGenerator) unexpected();
            method.kind = method.key.name;
            parsePropertyName(method);
          } else {
            method.kind = "";
          }
          method.value = parseMethod(isGenerator);
          checkPropClash(method, method['static'] ? staticMethodHash : methodHash);
          classBody.body.push(finishNode(method, "MethodDefinition"));
          eat(_semi);
        }
        node.body = finishNode(classBody, "ClassBody");
        return finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
    
      // Parses a comma-separated list of expressions, and returns them as
      // an array. `close` is the token type that ends the list, and
      // `allowEmpty` can be turned on to allow subsequent commas with
      // nothing in between them to be parsed as `null` (which is needed
      // for array literals).
    
      function parseExprList(close, allowTrailingComma, allowEmpty) {
        var elts = [], first = true;
        while (!eat(close)) {
          if (!first) {
            expect(_comma);
            if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
          } else first = false;
    
          if (allowEmpty && tokType === _comma) elts.push(null);
          else elts.push(parseExpression(true));
        }
        return elts;
      }
    
      // Parse the next token as an identifier. If `liberal` is true (used
      // when parsing properties), it will also convert keywords into
      // identifiers.
    
      function parseIdent(liberal) {
        var node = startNode();
        if (liberal && options.forbidReserved == "everywhere") liberal = false;
        if (tokType === _name) {
          if (!liberal &&
              (options.forbidReserved &&
               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
               strict && isStrictReservedWord(tokVal)) &&
              input.slice(tokStart, tokEnd).indexOf("\\") == -1)
            raise(tokStart, "The keyword '" + tokVal + "' is reserved");
          node.name = tokVal;
        } else if (liberal && tokType.keyword) {
          node.name = tokType.keyword;
        } else {
          unexpected();
        }
        tokRegexpAllowed = false;
        next();
        return finishNode(node, "Identifier");
      }
    
      // Parses module export declaration.
    
      function parseExport(node) {
        next();
        // export var|const|let|function|class ...;
        if (tokType === _var || tokType === _const || tokType === _let || tokType === _function || tokType === _class) {
          node.declaration = parseStatement();
          node['default'] = false;
          node.specifiers = null;
          node.source = null;
        } else
        // export default ...;
        if (eat(_default)) {
          node.declaration = parseExpression(true);
          node['default'] = true;
          node.specifiers = null;
          node.source = null;
          semicolon();
        } else {
          // export * from '...'
          // export { x, y as z } [from '...']
          var isBatch = tokType === _star;
          node.declaration = null;
          node['default'] = false;
          node.specifiers = parseExportSpecifiers();
          if (tokType === _name && tokVal === "from") {
            next();
            node.source = tokType === _string ? parseExprAtom() : unexpected();
          } else {
            if (isBatch) unexpected();
            node.source = null;
          }
        }
        return finishNode(node, "ExportDeclaration");
      }
    
      // Parses a comma-separated list of module exports.
    
      function parseExportSpecifiers() {
        var nodes = [], first = true;
        if (tokType === _star) {
          // export * from '...'
          var node = startNode();
          next();
          nodes.push(finishNode(node, "ExportBatchSpecifier"));
        } else {
          // export { x, y as z } [from '...']
          expect(_braceL);
          while (!eat(_braceR)) {
            if (!first) {
              expect(_comma);
              if (options.allowTrailingCommas && eat(_braceR)) break;
            } else first = false;
    
            var node = startNode();
            node.id = parseIdent();
            if (tokType === _name && tokVal === "as") {
              next();
              node.name = parseIdent(true);
            } else {
              node.name = null;
            }
            nodes.push(finishNode(node, "ExportSpecifier"));
          }
        }
        return nodes;
      }
    
      // Parses import declaration.
    
      function parseImport(node) {
        next();
        // import '...';
        if (tokType === _string) {
          node.specifiers = [];
          node.source = parseExprAtom();
          node.kind = "";
        } else {
          node.specifiers = parseImportSpecifiers();
          if (tokType !== _name || tokVal !== "from") unexpected();
          next();
          node.source = tokType === _string ? parseExprAtom() : unexpected();
          // only for backward compatibility with Esprima's AST
          // (it doesn't support mixed default + named yet)
          node.kind = node.specifiers[0]['default'] ? "default" : "named";
        }
        return finishNode(node, "ImportDeclaration");
      }
    
      // Parses a comma-separated list of module imports.
    
      function parseImportSpecifiers() {
        var nodes = [], first = true;
        if (tokType === _star) {
          var node = startNode();
          next();
          if (tokType !== _name || tokVal !== "as") unexpected();
          next();
          node.name = parseIdent();
          checkLVal(node.name, true);
          nodes.push(finishNode(node, "ImportBatchSpecifier"));
          return nodes;
        }
        if (tokType === _name) {
          // import defaultObj, { x, y as z } from '...'
          var node = startNode();
          node.id = parseIdent();
          checkLVal(node.id, true);
          node.name = null;
          node['default'] = true;
          nodes.push(finishNode(node, "ImportSpecifier"));
          if (!eat(_comma)) return nodes;
        }
        expect(_braceL);
        while (!eat(_braceR)) {
          if (!first) {
            expect(_comma);
            if (options.allowTrailingCommas && eat(_braceR)) break;
          } else first = false;
    
          var node = startNode();
          node.id = parseIdent(true);
          if (tokType === _name && tokVal === "as") {
            next();
            node.name = parseIdent();
          } else {
            node.name = null;
          }
          checkLVal(node.name || node.id, true);
          node['default'] = false;
          nodes.push(finishNode(node, "ImportSpecifier"));
        }
        return nodes;
      }
    
      // Parses yield expression inside generator.
    
      function parseYield() {
        var node = startNode();
        next();
        if (eat(_semi) || canInsertSemicolon()) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = eat(_star);
          node.argument = parseExpression(true);
        }
        return finishNode(node, "YieldExpression");
      }
    
      // Parses array and generator comprehensions.
    
      function parseComprehension(node, isGenerator) {
        node.blocks = [];
        while (tokType === _for) {
          var block = startNode();
          next();
          expect(_parenL);
          block.left = toAssignable(parseExprAtom());
          checkLVal(block.left, true);
          if (tokType !== _name || tokVal !== "of") unexpected();
          next();
          // `of` property is here for compatibility with Esprima's AST
          // which also supports deprecated [for (... in ...) expr]
          block.of = true;
          block.right = parseExpression();
          expect(_parenR);
          node.blocks.push(finishNode(block, "ComprehensionBlock"));
        }
        node.filter = eat(_if) ? parseParenExpression() : null;
        node.body = parseExpression();
        expect(isGenerator ? _parenR : _bracketR);
        node.generator = isGenerator;
        return finishNode(node, "ComprehensionExpression");
      }
    
    });
    
  provide("acorn", module.exports);
}(global));

// pakmanager:graceful-fs/fs.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // eeeeeevvvvviiiiiiillllll
    // more evil than monkey-patching the native builtin?
    // Not sure.
    
    var mod = require("module")
    var pre = '(function (exports, require, module, __filename, __dirname) { '
    var post = '});'
    var src = pre + process.binding('natives').fs + post
    var vm = require('vm')
    var fn = vm.runInThisContext(src)
    return fn(exports, require, module, __filename, __dirname)
    
  provide("graceful-fs/fs.js", module.exports);
}(global));

// pakmanager:graceful-fs/polyfills.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs =  require('graceful-fs/fs.js')
    var constants = require('constants')
    
    var origCwd = process.cwd
    var cwd = null
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process)
      return cwd
    }
    var chdir = process.chdir
    process.chdir = function(d) {
      cwd = null
      chdir.call(process, d)
    }
    
    // (re-)implement some things that are known busted or missing.
    
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') &&
        process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      fs.lchmod = function (path, mode, callback) {
        callback = callback || noop
        fs.open( path
               , constants.O_WRONLY | constants.O_SYMLINK
               , mode
               , function (err, fd) {
          if (err) {
            callback(err)
            return
          }
          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          fs.fchmod(fd, mode, function (err) {
            fs.close(fd, function(err2) {
              callback(err || err2)
            })
          })
        })
      }
    
      fs.lchmodSync = function (path, mode) {
        var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
    
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        var err, err2
        try {
          var ret = fs.fchmodSync(fd, mode)
        } catch (er) {
          err = er
        }
        try {
          fs.closeSync(fd)
        } catch (er) {
          err2 = er
        }
        if (err || err2) throw (err || err2)
        return ret
      }
    }
    
    
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs.lutimes = function (path, at, mt, cb) {
          fs.open(path, constants.O_SYMLINK, function (er, fd) {
            cb = cb || noop
            if (er) return cb(er)
            fs.futimes(fd, at, mt, function (er) {
              fs.close(fd, function (er2) {
                return cb(er || er2)
              })
            })
          })
        }
    
        fs.lutimesSync = function (path, at, mt) {
          var fd = fs.openSync(path, constants.O_SYMLINK)
            , err
            , err2
            , ret
    
          try {
            var ret = fs.futimesSync(fd, at, mt)
          } catch (er) {
            err = er
          }
          try {
            fs.closeSync(fd)
          } catch (er) {
            err2 = er
          }
          if (err || err2) throw (err || err2)
          return ret
        }
    
      } else if (fs.utimensat && constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")) {
        // maybe utimensat will be bound soonish?
        fs.lutimes = function (path, at, mt, cb) {
          fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)
        }
    
        fs.lutimesSync = function (path, at, mt) {
          return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)
        }
    
      } else {
        fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
        fs.lutimesSync = function () {}
      }
    }
    
    
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    
    fs.chown = chownFix(fs.chown)
    fs.fchown = chownFix(fs.fchown)
    fs.lchown = chownFix(fs.lchown)
    
    fs.chmod = chownFix(fs.chmod)
    fs.fchmod = chownFix(fs.fchmod)
    fs.lchmod = chownFix(fs.lchmod)
    
    fs.chownSync = chownFixSync(fs.chownSync)
    fs.fchownSync = chownFixSync(fs.fchownSync)
    fs.lchownSync = chownFixSync(fs.lchownSync)
    
    fs.chmodSync = chownFix(fs.chmodSync)
    fs.fchmodSync = chownFix(fs.fchmodSync)
    fs.lchmodSync = chownFix(fs.lchmodSync)
    
    function chownFix (orig) {
      if (!orig) return orig
      return function (target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function (er, res) {
          if (chownErOk(er)) er = null
          cb(er, res)
        })
      }
    }
    
    function chownFixSync (orig) {
      if (!orig) return orig
      return function (target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid)
        } catch (er) {
          if (!chownErOk(er)) throw er
        }
      }
    }
    
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk (er) {
      if (!er)
        return true
    
      if (er.code === "ENOSYS")
        return true
    
      var nonroot = !process.getuid || process.getuid() !== 0
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true
      }
    
      return false
    }
    
    
    // if lchmod/lchown do not exist, then make them no-ops
    if (!fs.lchmod) {
      fs.lchmod = function (path, mode, cb) {
        process.nextTick(cb)
      }
      fs.lchmodSync = function () {}
    }
    if (!fs.lchown) {
      fs.lchown = function (path, uid, gid, cb) {
        process.nextTick(cb)
      }
      fs.lchownSync = function () {}
    }
    
    
    
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 1 second.
    if (process.platform === "win32") {
      var rename_ = fs.rename
      fs.rename = function rename (from, to, cb) {
        var start = Date.now()
        rename_(from, to, function CB (er) {
          if (er
              && (er.code === "EACCES" || er.code === "EPERM")
              && Date.now() - start < 1000) {
            return rename_(from, to, CB)
          }
          cb(er)
        })
      }
    }
    
    
    // if read() returns EAGAIN, then just try it again.
    var read = fs.read
    fs.read = function (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return read.call(fs, fd, buffer, offset, length, position, callback)
    }
    
    var readSync = fs.readSync
    fs.readSync = function (fd, buffer, offset, length, position) {
      var eagCounter = 0
      while (true) {
        try {
          return readSync.call(fs, fd, buffer, offset, length, position)
        } catch (er) {
          if (er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            continue
          }
          throw er
        }
      }
    }
    
    
  provide("graceful-fs/polyfills.js", module.exports);
}(global));

// pakmanager:graceful-fs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Monkey-patching the fs module.
    // It's ugly, but there is simply no other way to do this.
    var fs = module.exports =  require('graceful-fs/fs.js')
    
    var assert = require('assert')
    
    // fix up some busted stuff, mostly on windows and old nodes
     require('graceful-fs/polyfills.js')
    
    var util = require('util')
    
    function noop () {}
    
    var debug = noop
    if (util.debuglog)
      debug = util.debuglog('gfs')
    else if (/\bgfs\b/i.test(process.env.NODE_DEBUG || ''))
      debug = function() {
        var m = util.format.apply(util, arguments)
        m = 'GFS: ' + m.split(/\n/).join('\nGFS: ')
        console.error(m)
      }
    
    if (/\bgfs\b/i.test(process.env.NODE_DEBUG || '')) {
      process.on('exit', function() {
        debug('fds', fds)
        debug(queue)
        assert.equal(queue.length, 0)
      })
    }
    
    
    var originalOpen = fs.open
    fs.open = open
    
    function open(path, flags, mode, cb) {
      if (typeof mode === "function") cb = mode, mode = null
      if (typeof cb !== "function") cb = noop
      new OpenReq(path, flags, mode, cb)
    }
    
    function OpenReq(path, flags, mode, cb) {
      this.path = path
      this.flags = flags
      this.mode = mode
      this.cb = cb
      Req.call(this)
    }
    
    util.inherits(OpenReq, Req)
    
    OpenReq.prototype.process = function() {
      originalOpen.call(fs, this.path, this.flags, this.mode, this.done)
    }
    
    var fds = {}
    OpenReq.prototype.done = function(er, fd) {
      debug('open done', er, fd)
      if (fd)
        fds['fd' + fd] = this.path
      Req.prototype.done.call(this, er, fd)
    }
    
    
    var originalReaddir = fs.readdir
    fs.readdir = readdir
    
    function readdir(path, cb) {
      if (typeof cb !== "function") cb = noop
      new ReaddirReq(path, cb)
    }
    
    function ReaddirReq(path, cb) {
      this.path = path
      this.cb = cb
      Req.call(this)
    }
    
    util.inherits(ReaddirReq, Req)
    
    ReaddirReq.prototype.process = function() {
      originalReaddir.call(fs, this.path, this.done)
    }
    
    ReaddirReq.prototype.done = function(er, files) {
      if (files && files.sort)
        files = files.sort()
      Req.prototype.done.call(this, er, files)
      onclose()
    }
    
    
    var originalClose = fs.close
    fs.close = close
    
    function close (fd, cb) {
      debug('close', fd)
      if (typeof cb !== "function") cb = noop
      delete fds['fd' + fd]
      originalClose.call(fs, fd, function(er) {
        onclose()
        cb(er)
      })
    }
    
    
    var originalCloseSync = fs.closeSync
    fs.closeSync = closeSync
    
    function closeSync (fd) {
      try {
        return originalCloseSync(fd)
      } finally {
        onclose()
      }
    }
    
    
    // Req class
    function Req () {
      // start processing
      this.done = this.done.bind(this)
      this.failures = 0
      this.process()
    }
    
    Req.prototype.done = function (er, result) {
      var tryAgain = false
      if (er) {
        var code = er.code
        var tryAgain = code === "EMFILE"
        if (process.platform === "win32")
          tryAgain = tryAgain || code === "OK"
      }
    
      if (tryAgain) {
        this.failures ++
        enqueue(this)
      } else {
        var cb = this.cb
        cb(er, result)
      }
    }
    
    var queue = []
    
    function enqueue(req) {
      queue.push(req)
      debug('enqueue %d %s', queue.length, req.constructor.name, req)
    }
    
    function onclose() {
      var req = queue.shift()
      if (req) {
        debug('process', req.constructor.name, req)
        req.process()
      }
    }
    
  provide("graceful-fs", module.exports);
}(global));

// pakmanager:minimatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  ;(function (require, exports, module, platform) {
    
    if (module) module.exports = minimatch
    else exports.minimatch = minimatch
    
    if (!require) {
      require = function (id) {
        switch (id) {
          case "sigmund": return function sigmund (obj) {
            return JSON.stringify(obj)
          }
          case "path": return { basename: function (f) {
            f = f.split(/[\/\\]/)
            var e = f.pop()
            if (!e) e = f.pop()
            return e
          }}
          case "lru-cache": return function LRUCache () {
            // not quite an LRU, but still space-limited.
            var cache = {}
            var cnt = 0
            this.set = function (k, v) {
              cnt ++
              if (cnt >= 100) cache = {}
              cache[k] = v
            }
            this.get = function (k) { return cache[k] }
          }
        }
      }
    }
    
    minimatch.Minimatch = Minimatch
    
    var LRU = require("lru-cache")
      , cache = minimatch.cache = new LRU({max: 100})
      , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
      , sigmund = require("sigmund")
    
    var path = require("path")
      // any single thing other than /
      // don't need to escape / when using new RegExp()
      , qmark = "[^/]"
    
      // * => any number of characters
      , star = qmark + "*?"
    
      // ** when dots are allowed.  Anything goes, except .. and .
      // not (^ or / followed by one or two dots followed by $ or /),
      // followed by anything, any number of times.
      , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"
    
      // not a ^ or / followed by a dot,
      // followed by anything, any number of times.
      , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"
    
      // characters that need to be escaped in RegExp.
      , reSpecials = charSet("().*{}+?[]^$\\!")
    
    // "abc" -> { a:true, b:true, c:true }
    function charSet (s) {
      return s.split("").reduce(function (set, c) {
        set[c] = true
        return set
      }, {})
    }
    
    // normalizes slashes.
    var slashSplit = /\/+/
    
    minimatch.filter = filter
    function filter (pattern, options) {
      options = options || {}
      return function (p, i, list) {
        return minimatch(p, pattern, options)
      }
    }
    
    function ext (a, b) {
      a = a || {}
      b = b || {}
      var t = {}
      Object.keys(b).forEach(function (k) {
        t[k] = b[k]
      })
      Object.keys(a).forEach(function (k) {
        t[k] = a[k]
      })
      return t
    }
    
    minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return minimatch
    
      var orig = minimatch
    
      var m = function minimatch (p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options))
      }
    
      m.Minimatch = function Minimatch (pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options))
      }
    
      return m
    }
    
    Minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return Minimatch
      return minimatch.defaults(def).Minimatch
    }
    
    
    function minimatch (p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required")
      }
    
      if (!options) options = {}
    
      // shortcut: comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false
      }
    
      // "" only matches ""
      if (pattern.trim() === "") return p === ""
    
      return new Minimatch(pattern, options).match(p)
    }
    
    function Minimatch (pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options, cache)
      }
    
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required")
      }
    
      if (!options) options = {}
      pattern = pattern.trim()
    
      // windows: need to use /, not \
      // On other platforms, \ is a valid (albeit bad) filename char.
      if (platform === "win32") {
        pattern = pattern.split("\\").join("/")
      }
    
      // lru storage.
      // these things aren't particularly big, but walking down the string
      // and turning it into a regexp can get pretty costly.
      var cacheKey = pattern + "\n" + sigmund(options)
      var cached = minimatch.cache.get(cacheKey)
      if (cached) return cached
      minimatch.cache.set(cacheKey, this)
    
      this.options = options
      this.set = []
      this.pattern = pattern
      this.regexp = null
      this.negate = false
      this.comment = false
      this.empty = false
    
      // make the set of regexps etc.
      this.make()
    }
    
    Minimatch.prototype.debug = function() {}
    
    Minimatch.prototype.make = make
    function make () {
      // don't do it more than once.
      if (this._made) return
    
      var pattern = this.pattern
      var options = this.options
    
      // empty patterns and comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true
        return
      }
      if (!pattern) {
        this.empty = true
        return
      }
    
      // step 1: figure out negation, etc.
      this.parseNegate()
    
      // step 2: expand braces
      var set = this.globSet = this.braceExpand()
    
      if (options.debug) this.debug = console.error
    
      this.debug(this.pattern, set)
    
      // step 3: now we have a set, so turn each one into a series of path-portion
      // matching patterns.
      // These will be regexps, except in the case of "**", which is
      // set to the GLOBSTAR object for globstar behavior,
      // and will not contain any / characters
      set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })
    
      this.debug(this.pattern, set)
    
      // glob --> regexps
      set = set.map(function (s, si, set) {
        return s.map(this.parse, this)
      }, this)
    
      this.debug(this.pattern, set)
    
      // filter out everything that didn't compile properly.
      set = set.filter(function (s) {
        return -1 === s.indexOf(false)
      })
    
      this.debug(this.pattern, set)
    
      this.set = set
    }
    
    Minimatch.prototype.parseNegate = parseNegate
    function parseNegate () {
      var pattern = this.pattern
        , negate = false
        , options = this.options
        , negateOffset = 0
    
      if (options.nonegate) return
    
      for ( var i = 0, l = pattern.length
          ; i < l && pattern.charAt(i) === "!"
          ; i ++) {
        negate = !negate
        negateOffset ++
      }
    
      if (negateOffset) this.pattern = pattern.substr(negateOffset)
      this.negate = negate
    }
    
    // Brace expansion:
    // a{b,c}d -> abd acd
    // a{b,}c -> abc ac
    // a{0..3}d -> a0d a1d a2d a3d
    // a{b,c{d,e}f}g -> abg acdfg acefg
    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
    //
    // Invalid sets are not expanded.
    // a{2..}b -> a{2..}b
    // a{b}c -> a{b}c
    minimatch.braceExpand = function (pattern, options) {
      return new Minimatch(pattern, options).braceExpand()
    }
    
    Minimatch.prototype.braceExpand = braceExpand
    
    function pad(n, width, z) {
      z = z || '0';
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    }
    
    function braceExpand (pattern, options) {
      options = options || this.options
      pattern = typeof pattern === "undefined"
        ? this.pattern : pattern
    
      if (typeof pattern === "undefined") {
        throw new Error("undefined pattern")
      }
    
      if (options.nobrace ||
          !pattern.match(/\{.*\}/)) {
        // shortcut. no need to expand.
        return [pattern]
      }
    
      var escaping = false
    
      // examples and comments refer to this crazy pattern:
      // a{b,c{d,e},{f,g}h}x{y,z}
      // expected:
      // abxy
      // abxz
      // acdxy
      // acdxz
      // acexy
      // acexz
      // afhxy
      // afhxz
      // aghxy
      // aghxz
    
      // everything before the first \{ is just a prefix.
      // So, we pluck that off, and work with the rest,
      // and then prepend it to everything we find.
      if (pattern.charAt(0) !== "{") {
        this.debug(pattern)
        var prefix = null
        for (var i = 0, l = pattern.length; i < l; i ++) {
          var c = pattern.charAt(i)
          this.debug(i, c)
          if (c === "\\") {
            escaping = !escaping
          } else if (c === "{" && !escaping) {
            prefix = pattern.substr(0, i)
            break
          }
        }
    
        // actually no sets, all { were escaped.
        if (prefix === null) {
          this.debug("no sets")
          return [pattern]
        }
    
       var tail = braceExpand.call(this, pattern.substr(i), options)
        return tail.map(function (t) {
          return prefix + t
        })
      }
    
      // now we have something like:
      // {b,c{d,e},{f,g}h}x{y,z}
      // walk through the set, expanding each part, until
      // the set ends.  then, we'll expand the suffix.
      // If the set only has a single member, then'll put the {} back
    
      // first, handle numeric sets, since they're easier
      var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
      if (numset) {
        this.debug("numset", numset[1], numset[2])
        var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)
          , start = +numset[1]
          , needPadding = numset[1][0] === '0'
          , startWidth = numset[1].length
          , padded
          , end = +numset[2]
          , inc = start > end ? -1 : 1
          , set = []
    
        for (var i = start; i != (end + inc); i += inc) {
          padded = needPadding ? pad(i, startWidth) : i + ''
          // append all the suffixes
          for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
            set.push(padded + suf[ii])
          }
        }
        return set
      }
    
      // ok, walk through the set
      // We hope, somewhat optimistically, that there
      // will be a } at the end.
      // If the closing brace isn't found, then the pattern is
      // interpreted as braceExpand("\\" + pattern) so that
      // the leading \{ will be interpreted literally.
      var i = 1 // skip the \{
        , depth = 1
        , set = []
        , member = ""
        , sawEnd = false
        , escaping = false
    
      function addMember () {
        set.push(member)
        member = ""
      }
    
      this.debug("Entering for")
      FOR: for (i = 1, l = pattern.length; i < l; i ++) {
        var c = pattern.charAt(i)
        this.debug("", i, c)
    
        if (escaping) {
          escaping = false
          member += "\\" + c
        } else {
          switch (c) {
            case "\\":
              escaping = true
              continue
    
            case "{":
              depth ++
              member += "{"
              continue
    
            case "}":
              depth --
              // if this closes the actual set, then we're done
              if (depth === 0) {
                addMember()
                // pluck off the close-brace
                i ++
                break FOR
              } else {
                member += c
                continue
              }
    
            case ",":
              if (depth === 1) {
                addMember()
              } else {
                member += c
              }
              continue
    
            default:
              member += c
              continue
          } // switch
        } // else
      } // for
    
      // now we've either finished the set, and the suffix is
      // pattern.substr(i), or we have *not* closed the set,
      // and need to escape the leading brace
      if (depth !== 0) {
        this.debug("didn't close", pattern)
        return braceExpand.call(this, "\\" + pattern, options)
      }
    
      // x{y,z} -> ["xy", "xz"]
      this.debug("set", set)
      this.debug("suffix", pattern.substr(i))
      var suf = braceExpand.call(this, pattern.substr(i), options)
      // ["b", "c{d,e}","{f,g}h"] ->
      //   [["b"], ["cd", "ce"], ["fh", "gh"]]
      var addBraces = set.length === 1
      this.debug("set pre-expanded", set)
      set = set.map(function (p) {
        return braceExpand.call(this, p, options)
      }, this)
      this.debug("set expanded", set)
    
    
      // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
      //   ["b", "cd", "ce", "fh", "gh"]
      set = set.reduce(function (l, r) {
        return l.concat(r)
      })
    
      if (addBraces) {
        set = set.map(function (s) {
          return "{" + s + "}"
        })
      }
    
      // now attach the suffixes.
      var ret = []
      for (var i = 0, l = set.length; i < l; i ++) {
        for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
          ret.push(set[i] + suf[ii])
        }
      }
      return ret
    }
    
    // parse a component of the expanded set.
    // At this point, no pattern may contain "/" in it
    // so we're going to return a 2d array, where each entry is the full
    // pattern, split on '/', and then turned into a regular expression.
    // A regexp is made at the end which joins each array with an
    // escaped /, and another full one which joins each regexp with |.
    //
    // Following the lead of Bash 4.1, note that "**" only has special meaning
    // when it is the *only* thing in a path portion.  Otherwise, any series
    // of * is equivalent to a single *.  Globstar behavior is enabled by
    // default, and can be disabled by setting options.noglobstar.
    Minimatch.prototype.parse = parse
    var SUBPARSE = {}
    function parse (pattern, isSub) {
      var options = this.options
    
      // shortcuts
      if (!options.noglobstar && pattern === "**") return GLOBSTAR
      if (pattern === "") return ""
    
      var re = ""
        , hasMagic = !!options.nocase
        , escaping = false
        // ? => one single character
        , patternListStack = []
        , plType
        , stateChar
        , inClass = false
        , reClassStart = -1
        , classStart = -1
        // . and .. never match anything that doesn't start with .,
        // even when options.dot is set.
        , patternStart = pattern.charAt(0) === "." ? "" // anything
          // not (start or / followed by . or .. followed by / or end)
          : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
          : "(?!\\.)"
        , self = this
    
      function clearStateChar () {
        if (stateChar) {
          // we had some state-tracking character
          // that wasn't consumed by this pass.
          switch (stateChar) {
            case "*":
              re += star
              hasMagic = true
              break
            case "?":
              re += qmark
              hasMagic = true
              break
            default:
              re += "\\"+stateChar
              break
          }
          self.debug('clearStateChar %j %j', stateChar, re)
          stateChar = false
        }
      }
    
      for ( var i = 0, len = pattern.length, c
          ; (i < len) && (c = pattern.charAt(i))
          ; i ++ ) {
    
        this.debug("%s\t%s %s %j", pattern, i, re, c)
    
        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
          re += "\\" + c
          escaping = false
          continue
        }
    
        SWITCH: switch (c) {
          case "/":
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false
    
          case "\\":
            clearStateChar()
            escaping = true
            continue
    
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c)
    
            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              this.debug('  in class')
              if (c === "!" && i === classStart + 1) c = "^"
              re += c
              continue
            }
    
            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            self.debug('call clearStateChar %j', stateChar)
            clearStateChar()
            stateChar = c
            // if extglob is disabled, then +(asdf|foo) isn't a thing.
            // just clear the statechar *now*, rather than even diving into
            // the patternList stuff.
            if (options.noext) clearStateChar()
            continue
    
          case "(":
            if (inClass) {
              re += "("
              continue
            }
    
            if (!stateChar) {
              re += "\\("
              continue
            }
    
            plType = stateChar
            patternListStack.push({ type: plType
                                  , start: i - 1
                                  , reStart: re.length })
            // negation is (?:(?!js)[^/]*)
            re += stateChar === "!" ? "(?:(?!" : "(?:"
            this.debug('plType %j %j', stateChar, re)
            stateChar = false
            continue
    
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)"
              continue
            }
    
            clearStateChar()
            hasMagic = true
            re += ")"
            plType = patternListStack.pop().type
            // negation is (?:(?!js)[^/]*)
            // The others are (?:<pattern>)<type>
            switch (plType) {
              case "!":
                re += "[^/]*?)"
                break
              case "?":
              case "+":
              case "*": re += plType
              case "@": break // the default anyway
            }
            continue
    
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|"
              escaping = false
              continue
            }
    
            clearStateChar()
            re += "|"
            continue
    
          // these are mostly the same in regexp and glob
          case "[":
            // swallow any state-tracking char before the [
            clearStateChar()
    
            if (inClass) {
              re += "\\" + c
              continue
            }
    
            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
            continue
    
          case "]":
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c
              escaping = false
              continue
            }
    
            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
            continue
    
          default:
            // swallow any state char that wasn't consumed
            clearStateChar()
    
            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
                       && !(c === "^" && inClass)) {
              re += "\\"
            }
    
            re += c
    
        } // switch
      } // for
    
    
      // handle the case where we left a class open.
      // "[abc" is valid, equivalent to "\[abc"
      if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        var cs = pattern.substr(classStart + 1)
          , sp = this.parse(cs, SUBPARSE)
        re = re.substr(0, reClassStart) + "\\[" + sp[0]
        hasMagic = hasMagic || sp[1]
      }
    
      // handle the case where we had a +( thing at the *end*
      // of the pattern.
      // each pattern list stack adds 3 chars, and we need to go through
      // and escape any | chars that were passed through as-is for the regexp.
      // Go through and escape them, taking care not to double-escape any
      // | chars that were already escaped.
      var pl
      while (pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3)
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
          if (!$2) {
            // the | isn't already escaped, so escape it.
            $2 = "\\"
          }
    
          // need to escape all those slashes *again*, without escaping the
          // one that we need for escaping the | character.  As it works out,
          // escaping an even number of slashes can be done by simply repeating
          // it exactly after itself.  That's why this trick works.
          //
          // I am sorry that you have to see this.
          return $1 + $1 + $2 + "|"
        })
    
        this.debug("tail=%j\n   %s", tail, tail)
        var t = pl.type === "*" ? star
              : pl.type === "?" ? qmark
              : "\\" + pl.type
    
        hasMagic = true
        re = re.slice(0, pl.reStart)
           + t + "\\("
           + tail
      }
    
      // handle trailing things that only matter at the very end.
      clearStateChar()
      if (escaping) {
        // trailing \\
        re += "\\\\"
      }
    
      // only need to apply the nodot start if the re starts with
      // something that could conceivably capture a dot
      var addPatternStart = false
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(": addPatternStart = true
      }
    
      // if the re is not "" at this point, then we need to make sure
      // it doesn't match against an empty path part.
      // Otherwise a/* will match a/, which it should not.
      if (re !== "" && hasMagic) re = "(?=.)" + re
    
      if (addPatternStart) re = patternStart + re
    
      // parsing just a piece of a larger pattern.
      if (isSub === SUBPARSE) {
        return [ re, hasMagic ]
      }
    
      // skip the regexp for non-magical patterns
      // unescape anything in it, though, so that it'll be
      // an exact match against a file etc.
      if (!hasMagic) {
        return globUnescape(pattern)
      }
    
      var flags = options.nocase ? "i" : ""
        , regExp = new RegExp("^" + re + "$", flags)
    
      regExp._glob = pattern
      regExp._src = re
    
      return regExp
    }
    
    minimatch.makeRe = function (pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe()
    }
    
    Minimatch.prototype.makeRe = makeRe
    function makeRe () {
      if (this.regexp || this.regexp === false) return this.regexp
    
      // at this point, this.set is a 2d array of partial
      // pattern strings, or "**".
      //
      // It's better to use .match().  This function shouldn't
      // be used, really, but it's pretty convenient sometimes,
      // when you just want to work with a regex.
      var set = this.set
    
      if (!set.length) return this.regexp = false
      var options = this.options
    
      var twoStar = options.noglobstar ? star
          : options.dot ? twoStarDot
          : twoStarNoDot
        , flags = options.nocase ? "i" : ""
    
      var re = set.map(function (pattern) {
        return pattern.map(function (p) {
          return (p === GLOBSTAR) ? twoStar
               : (typeof p === "string") ? regExpEscape(p)
               : p._src
        }).join("\\\/")
      }).join("|")
    
      // must match entire pattern
      // ending in a * or ** will make it less strict.
      re = "^(?:" + re + ")$"
    
      // can match anything, as long as it's not this.
      if (this.negate) re = "^(?!" + re + ").*$"
    
      try {
        return this.regexp = new RegExp(re, flags)
      } catch (ex) {
        return this.regexp = false
      }
    }
    
    minimatch.match = function (list, pattern, options) {
      options = options || {}
      var mm = new Minimatch(pattern, options)
      list = list.filter(function (f) {
        return mm.match(f)
      })
      if (mm.options.nonull && !list.length) {
        list.push(pattern)
      }
      return list
    }
    
    Minimatch.prototype.match = match
    function match (f, partial) {
      this.debug("match", f, this.pattern)
      // short-circuit in the case of busted things.
      // comments, etc.
      if (this.comment) return false
      if (this.empty) return f === ""
    
      if (f === "/" && partial) return true
    
      var options = this.options
    
      // windows: need to use /, not \
      // On other platforms, \ is a valid (albeit bad) filename char.
      if (platform === "win32") {
        f = f.split("\\").join("/")
      }
    
      // treat the test path as a set of pathparts.
      f = f.split(slashSplit)
      this.debug(this.pattern, "split", f)
    
      // just ONE of the pattern sets in this.set needs to match
      // in order for it to be valid.  If negating, then just one
      // match means that we have failed.
      // Either way, return on the first hit.
    
      var set = this.set
      this.debug(this.pattern, "set", set)
    
      // Find the basename of the path by looking for the last non-empty segment
      var filename;
      for (var i = f.length - 1; i >= 0; i--) {
        filename = f[i]
        if (filename) break
      }
    
      for (var i = 0, l = set.length; i < l; i ++) {
        var pattern = set[i], file = f
        if (options.matchBase && pattern.length === 1) {
          file = [filename]
        }
        var hit = this.matchOne(file, pattern, partial)
        if (hit) {
          if (options.flipNegate) return true
          return !this.negate
        }
      }
    
      // didn't get any hits.  this is success if it's a negative
      // pattern, failure otherwise.
      if (options.flipNegate) return false
      return this.negate
    }
    
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    Minimatch.prototype.matchOne = function (file, pattern, partial) {
      var options = this.options
    
      this.debug("matchOne",
                  { "this": this
                  , file: file
                  , pattern: pattern })
    
      this.debug("matchOne", file.length, pattern.length)
    
      for ( var fi = 0
              , pi = 0
              , fl = file.length
              , pl = pattern.length
          ; (fi < fl) && (pi < pl)
          ; fi ++, pi ++ ) {
    
        this.debug("matchOne loop")
        var p = pattern[pi]
          , f = file[fi]
    
        this.debug(pattern, p, f)
    
        // should be impossible.
        // some invalid regexp stuff in the set.
        if (p === false) return false
    
        if (p === GLOBSTAR) {
          this.debug('GLOBSTAR', [pattern, p, f])
    
          // "**"
          // a/**/b/**/c would match the following:
          // a/b/x/y/z/c
          // a/x/y/z/b/c
          // a/b/x/b/x/c
          // a/b/c
          // To do this, take the rest of the pattern after
          // the **, and see if it would match the file remainder.
          // If so, return success.
          // If not, the ** "swallows" a segment, and try again.
          // This is recursively awful.
          //
          // a/**/b/**/c matching a/b/x/y/z/c
          // - a matches a
          // - doublestar
          //   - matchOne(b/x/y/z/c, b/**/c)
          //     - b matches b
          //     - doublestar
          //       - matchOne(x/y/z/c, c) -> no
          //       - matchOne(y/z/c, c) -> no
          //       - matchOne(z/c, c) -> no
          //       - matchOne(c, c) yes, hit
          var fr = fi
            , pr = pi + 1
          if (pr === pl) {
            this.debug('** at the end')
            // a ** at the end will just swallow the rest.
            // We have found a match.
            // however, it will not swallow /.x, unless
            // options.dot is set.
            // . and .. are *never* matched by **, for explosively
            // exponential reasons.
            for ( ; fi < fl; fi ++) {
              if (file[fi] === "." || file[fi] === ".." ||
                  (!options.dot && file[fi].charAt(0) === ".")) return false
            }
            return true
          }
    
          // ok, let's see if we can swallow whatever we can.
          WHILE: while (fr < fl) {
            var swallowee = file[fr]
    
            this.debug('\nglobstar while',
                        file, fr, pattern, pr, swallowee)
    
            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug('globstar found match!', fr, fl, swallowee)
              // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === "." || swallowee === ".." ||
                  (!options.dot && swallowee.charAt(0) === ".")) {
                this.debug("dot detected!", file, fr, pattern, pr)
                break WHILE
              }
    
              // ** swallows a segment, and continue.
              this.debug('globstar swallow a segment, and continue')
              fr ++
            }
          }
          // no match was found.
          // However, in partial mode, we can't say this is necessarily over.
          // If there's more *pattern* left, then
          if (partial) {
            // ran out of file
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr)
            if (fr === fl) return true
          }
          return false
        }
    
        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase()
          } else {
            hit = f === p
          }
          this.debug("string match", p, f, hit)
        } else {
          hit = f.match(p)
          this.debug("pattern match", p, f, hit)
        }
    
        if (!hit) return false
      }
    
      // Note: ending in / means that we'll get a final ""
      // at the end of the pattern.  This can only match a
      // corresponding "" at the end of the file.
      // If the file ends in /, then it can only match a
      // a pattern that ends in /, unless the pattern just
      // doesn't have any more for it. But, a/b/ should *not*
      // match "a/b/*", even though "" matches against the
      // [^/]*? pattern, except in partial mode, where it might
      // simply not be reached yet.
      // However, a/b/ should still satisfy a/*
    
      // now either we fell off the end of the pattern, or we're done.
      if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true
      } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial
      } else if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")
        return emptyFileEnd
      }
    
      // should be unreachable.
      throw new Error("wtf?")
    }
    
    
    // replace stuff like \* with *
    function globUnescape (s) {
      return s.replace(/\\(.)/g, "$1")
    }
    
    
    function regExpEscape (s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
    }
    
    })( typeof require === "function" ? require : null,
        this,
        typeof module === "object" ? module : null,
        typeof process === "object" ? process.platform : "win32"
      )
    
  provide("minimatch", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    module.exports = Readable;
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    var Stream = require('stream');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      options = options || {};
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // In streams that never have any data, and do push(null) right away,
      // the consumer can miss the 'end' event if they do some I/O before
      // consuming the stream.  So, we don't emit('end') until some reading
      // happens.
      this.calledRead = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (typeof chunk === 'string' && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null || chunk === undefined) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
    
          if (state.needReadable)
            emitReadable(stream);
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        ret = null;
    
        // In cases where the decoder did not receive enough data
        // to produce a full chunk, then immediately received an
        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
        // howMuchToRead will see this and coerce the amount to
        // read to zero (because it's looking at the length of the
        // first <Buffer > in state.buffer), and we'll end up here.
        //
        // This can only happen via state.decoder -- no other venue
        // exists for pushing a zero-length chunk into state.buffer
        // and triggering this behavior. In this case, we return our
        // remaining data and end the stream, if appropriate.
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
    
        if (state.length === 0)
          endReadable(this);
    
        return ret;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length - n <= state.highWaterMark)
        doRead = true;
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading)
        doRead = false;
    
      if (doRead) {
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read called its callback synchronously, then `reading`
      // will be false, and we need to re-evaluate how much data we
      // can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we happened to read() exactly the remaining amount in the
      // buffer, and the EOF has been seen at this point, then make sure
      // that we emit 'end' on the very next tick.
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // if we've ended and we have some data left, then emit
      // 'readable' now to make sure it gets picked up.
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
    
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    
    function emitReadable_(stream) {
      stream.emit('readable');
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        if (readable !== src) return;
        cleanup();
      }
    
      function onend() {
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        // the handler that waits for readable events after all
        // the data gets sucked out in flow.
        // This would be easier to follow with a .once() handler
        // in flow(), but that is too slow.
        this.on('readable', pipeOnReadable);
    
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
    
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
    
      while (state.pipesCount && null !== (chunk = src.read())) {
    
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
    
        src.emit('data', chunk);
    
        // if anyone needs a drain, then we have to wait for that.
        if (state.awaitDrain > 0)
          return;
      }
    
      // if every destination was unpiped, either before entering this
      // function, or in the while loop, then stop flowing.
      //
      // NB: This is a pretty rare edge case.
      if (state.pipesCount === 0) {
        state.flowing = false;
    
        // if there were data event listeners added, then switch to old mode.
        if (EE.listenerCount(src, 'data') > 0)
          emitDataEvents(src);
        return;
      }
    
      // at this point, no one needed a drain, so we just ran out of data
      // on the next readable event, start it over again.
      state.ranOut = true;
    }
    
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      if (ev === 'data' && !this._readableState.flowing)
        emitDataEvents(this);
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit('resume');
    };
    
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit('pause');
    };
    
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
    
      if (state.flowing) {
        // https://github.com/isaacs/readable-stream/issues/16
        throw new Error('Cannot switch to old mode now.');
      }
    
      var paused = startPaused || false;
      var readable = false;
    
      // convert to an old-style stream.
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
    
      stream.on('readable', function() {
        readable = true;
    
        var c;
        while (!paused && (null !== (c = stream.read())))
          stream.emit('data', c);
    
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
    
      stream.pause = function() {
        paused = true;
        this.emit('pause');
      };
    
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit('readable');
          });
        else
          this.read(0);
        this.emit('resume');
      };
    
      // now make it start, just in case it hadn't already.
      stream.emit('readable');
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        //if (state.objectMode && util.isNullOrUndefined(chunk))
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (typeof stream[i] === 'function' &&
            typeof this[i] === 'undefined') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }}(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          // Check that we didn't get one last unshift.
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    module.exports = Writable;
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Stream = require('stream');
    
    util.inherits(Writable, Stream);
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    
    function WritableState(options, stream) {
      options = options || {};
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.buffer = [];
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = function() {};
    
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
    
      return ret;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
    
      return ret;
    }
    
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(stream, state);
    
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
    
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
    
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
    
        doWrite(stream, state, len, chunk, encoding, cb);
    
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          c++;
          break;
        }
      }
    
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (typeof chunk !== 'undefined' && chunk !== null)
        this.write(chunk, encoding);
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(stream, state) {
      return (state.ending &&
              state.length === 0 &&
              !state.finished &&
              !state.writing);
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit('finish');
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      process.nextTick(this.end.bind(this));
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      var ts = this._transformState = new TransformState(options, this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      this.once('finish', function() {
        if ('function' === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    module.exports = Readable;
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    var Stream = require('stream');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      options = options || {};
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // In streams that never have any data, and do push(null) right away,
      // the consumer can miss the 'end' event if they do some I/O before
      // consuming the stream.  So, we don't emit('end') until some reading
      // happens.
      this.calledRead = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (typeof chunk === 'string' && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null || chunk === undefined) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
    
          if (state.needReadable)
            emitReadable(stream);
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        ret = null;
    
        // In cases where the decoder did not receive enough data
        // to produce a full chunk, then immediately received an
        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
        // howMuchToRead will see this and coerce the amount to
        // read to zero (because it's looking at the length of the
        // first <Buffer > in state.buffer), and we'll end up here.
        //
        // This can only happen via state.decoder -- no other venue
        // exists for pushing a zero-length chunk into state.buffer
        // and triggering this behavior. In this case, we return our
        // remaining data and end the stream, if appropriate.
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
    
        if (state.length === 0)
          endReadable(this);
    
        return ret;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length - n <= state.highWaterMark)
        doRead = true;
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading)
        doRead = false;
    
      if (doRead) {
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read called its callback synchronously, then `reading`
      // will be false, and we need to re-evaluate how much data we
      // can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we happened to read() exactly the remaining amount in the
      // buffer, and the EOF has been seen at this point, then make sure
      // that we emit 'end' on the very next tick.
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // if we've ended and we have some data left, then emit
      // 'readable' now to make sure it gets picked up.
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
    
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    
    function emitReadable_(stream) {
      stream.emit('readable');
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        if (readable !== src) return;
        cleanup();
      }
    
      function onend() {
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        // the handler that waits for readable events after all
        // the data gets sucked out in flow.
        // This would be easier to follow with a .once() handler
        // in flow(), but that is too slow.
        this.on('readable', pipeOnReadable);
    
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
    
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
    
      while (state.pipesCount && null !== (chunk = src.read())) {
    
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
    
        src.emit('data', chunk);
    
        // if anyone needs a drain, then we have to wait for that.
        if (state.awaitDrain > 0)
          return;
      }
    
      // if every destination was unpiped, either before entering this
      // function, or in the while loop, then stop flowing.
      //
      // NB: This is a pretty rare edge case.
      if (state.pipesCount === 0) {
        state.flowing = false;
    
        // if there were data event listeners added, then switch to old mode.
        if (EE.listenerCount(src, 'data') > 0)
          emitDataEvents(src);
        return;
      }
    
      // at this point, no one needed a drain, so we just ran out of data
      // on the next readable event, start it over again.
      state.ranOut = true;
    }
    
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      if (ev === 'data' && !this._readableState.flowing)
        emitDataEvents(this);
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit('resume');
    };
    
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit('pause');
    };
    
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
    
      if (state.flowing) {
        // https://github.com/isaacs/readable-stream/issues/16
        throw new Error('Cannot switch to old mode now.');
      }
    
      var paused = startPaused || false;
      var readable = false;
    
      // convert to an old-style stream.
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
    
      stream.on('readable', function() {
        readable = true;
    
        var c;
        while (!paused && (null !== (c = stream.read())))
          stream.emit('data', c);
    
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
    
      stream.pause = function() {
        paused = true;
        this.emit('pause');
      };
    
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit('readable');
          });
        else
          this.read(0);
        this.emit('resume');
      };
    
      // now make it start, just in case it hadn't already.
      stream.emit('readable');
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        //if (state.objectMode && util.isNullOrUndefined(chunk))
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (typeof stream[i] === 'function' &&
            typeof this[i] === 'undefined') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }}(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          // Check that we didn't get one last unshift.
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    module.exports = Writable;
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Stream = require('stream');
    
    util.inherits(Writable, Stream);
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    
    function WritableState(options, stream) {
      options = options || {};
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.buffer = [];
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = function() {};
    
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
    
      return ret;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
    
      return ret;
    }
    
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(stream, state);
    
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
    
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
    
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
    
        doWrite(stream, state, len, chunk, encoding, cb);
    
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          c++;
          break;
        }
      }
    
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (typeof chunk !== 'undefined' && chunk !== null)
        this.write(chunk, encoding);
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(stream, state) {
      return (state.ending &&
              state.length === 0 &&
              !state.finished &&
              !state.writing);
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit('finish');
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      process.nextTick(this.end.bind(this));
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      var ts = this._transformState = new TransformState(options, this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      this.once('finish', function() {
        if ('function' === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_passthrough.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a passthrough stream.
    // basically just the most minimal sort of Transform stream.
    // Every written chunk gets output as-is.
    
    module.exports = PassThrough;
    
    var Transform =  require('readable-stream/lib/_stream_transform');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(PassThrough, Transform);
    
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
    
      Transform.call(this, options);
    }
    
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    
  provide("readable-stream/lib/_stream_passthrough.js", module.exports);
}(global));

// pakmanager:readable-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
    exports = module.exports =  require('readable-stream/lib/_stream_readable.js');
    exports.Stream = Stream;
    exports.Readable = exports;
    exports.Writable =  require('readable-stream/lib/_stream_writable.js');
    exports.Duplex =  require('readable-stream/lib/_stream_duplex.js');
    exports.Transform =  require('readable-stream/lib/_stream_transform.js');
    exports.PassThrough =  require('readable-stream/lib/_stream_passthrough.js');
    
  provide("readable-stream", module.exports);
}(global));

// pakmanager:asap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestFlush = void 0;
    var isNodeJS = false;
    
    function flush() {
        /* jshint loopfunc: true */
    
        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;
    
            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
    
            try {
                task();
    
            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!
    
                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }
    
                    throw e;
    
                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }
    
            if (domain) {
                domain.exit();
            }
        }
    
        flushing = false;
    }
    
    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;
    
        requestFlush = function () {
            process.nextTick(flush);
        };
    
    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestFlush = setImmediate.bind(window, flush);
        } else {
            requestFlush = function () {
                setImmediate(flush);
            };
        }
    
    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        requestFlush = function () {
            channel.port2.postMessage(0);
        };
    
    } else {
        // old browsers
        requestFlush = function () {
            setTimeout(flush, 0);
        };
    }
    
    function asap(task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };
    
        if (!flushing) {
            flushing = true;
            requestFlush();
        }
    };
    
    module.exports = asap;
    
    
  provide("asap", module.exports);
}(global));

// pakmanager:source-map/source-map/base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var charToIntMap = {};
      var intToCharMap = {};
    
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        .split('')
        .forEach(function (ch, index) {
          charToIntMap[ch] = index;
          intToCharMap[index] = ch;
        });
    
      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function base64_encode(aNumber) {
        if (aNumber in intToCharMap) {
          return intToCharMap[aNumber];
        }
        throw new TypeError("Must be between 0 and 63: " + aNumber);
      };
    
      /**
       * Decode a single base 64 digit to an integer.
       */
      exports.decode = function base64_decode(aChar) {
        if (aChar in charToIntMap) {
          return charToIntMap[aChar];
        }
        throw new TypeError("Not a valid base 64 digit: " + aChar);
      };
    
    });
    
  provide("source-map/source-map/base64", module.exports);
}(global));

// pakmanager:source-map/source-map/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
    
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
    
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
    
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
    
      /**
       * Normalizes a path, or the path portion of a URL:
       *
       * - Replaces consequtive slashes with one slash.
       * - Removes unnecessary '.' parts.
       * - Removes unnecessary '<dir>/..' parts.
       *
       * Based on code in the Node.js 'path' core module.
       *
       * @param aPath The path or url to normalize.
       */
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = (path.charAt(0) === '/');
    
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              // The first part is blank if the path is absolute. Trying to go
              // above the root is a no-op. Therefore we can remove all '..' parts
              // directly after the root.
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
    
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
    
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
    
      /**
       * Joins two paths/URLs.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be joined with the root.
       *
       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
       *   first.
       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
       *   is updated with the result and aRoot is returned. Otherwise the result
       *   is returned.
       *   - If aPath is absolute, the result is aPath.
       *   - Otherwise the two paths are joined with a slash.
       * - Joining for example 'http://' and 'www.example.com' is also supported.
       */
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }
    
        // `join(foo, '//www.example.org')`
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
    
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
    
        // `join('http://', 'www.example.com')`
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
    
        var joined = aPath.charAt(0) === '/'
          ? aPath
          : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
    
      /**
       * Make a path relative to a URL or another path.
       *
       * @param aRoot The root path or URL.
       * @param aPath The path or URL to be made relative to aRoot.
       */
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
    
        aRoot = aRoot.replace(/\/$/, '');
    
        // XXX: It is possible to remove this block, and the tests still pass!
        var url = urlParse(aRoot);
        if (aPath.charAt(0) == "/" && url && url.path == "/") {
          return aPath.slice(1);
        }
    
        return aPath.indexOf(aRoot + '/') === 0
          ? aPath.substr(aRoot.length + 1)
          : aPath;
      }
      exports.relative = relative;
    
      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
    
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
    
      function strcmp(aStr1, aStr2) {
        var s1 = aStr1 || "";
        var s2 = aStr2 || "";
        return (s1 > s2) - (s1 < s2);
      }
    
      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp || onlyCompareOriginal) {
          return cmp;
        }
    
        cmp = strcmp(mappingA.name, mappingB.name);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        return mappingA.generatedColumn - mappingB.generatedColumn;
      };
      exports.compareByOriginalPositions = compareByOriginalPositions;
    
      /**
       * Comparator between two mappings where the generated positions are
       * compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
        var cmp;
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp || onlyCompareGenerated) {
          return cmp;
        }
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp) {
          return cmp;
        }
    
        return strcmp(mappingA.name, mappingB.name);
      };
      exports.compareByGeneratedPositions = compareByGeneratedPositions;
    
    });
    
  provide("source-map/source-map/util", module.exports);
}(global));

// pakmanager:source-map/source-map/base64-vlq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     *
     * Based on the Base 64 VLQ implementation in Closure Compiler:
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
     *
     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *  * Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above
     *    copyright notice, this list of conditions and the following
     *    disclaimer in the documentation and/or other materials provided
     *    with the distribution.
     *  * Neither the name of Google Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64 =  require('source-map/source-map/base64');
    
      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011
    
      var VLQ_BASE_SHIFT = 5;
    
      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    
      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;
    
      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
    
      /**
       * Converts from a two-complement value to a value where the sign bit is
       * is placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0
          ? ((-aValue) << 1) + 1
          : (aValue << 1) + 0;
      }
    
      /**
       * Converts to a two-complement value from a value where the sign bit is
       * is placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative
          ? -shifted
          : shifted;
      }
    
      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
    
        var vlq = toVLQSigned(aValue);
    
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
    
        return encoded;
      };
    
      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string via the out parameter.
       */
      exports.decode = function base64VLQ_decode(aStr, aOutParam) {
        var i = 0;
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
    
        do {
          if (i >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charAt(i++));
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
    
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aStr.slice(i);
      };
    
    });
    
  provide("source-map/source-map/base64-vlq", module.exports);
}(global));

// pakmanager:source-map/source-map/array-set
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
    
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
    
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var isDuplicate = this.has(aStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[util.toSetString(aStr)] = idx;
        }
      };
    
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        return Object.prototype.hasOwnProperty.call(this._set,
                                                    util.toSetString(aStr));
      };
    
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (this.has(aStr)) {
          return this._set[util.toSetString(aStr)];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
    
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
    
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
    
      exports.ArraySet = ArraySet;
    
    });
    
  provide("source-map/source-map/array-set", module.exports);
}(global));

// pakmanager:source-map/source-map/binary-search
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the next
        //      closest element that is less than that element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element which is less than the one we are searching for, so we
        //      return null.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return aHaystack[mid];
        }
        else if (cmp > 0) {
          // aHaystack[mid] is greater than our needle.
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
          }
          // We did not find an exact match, return the next closest one
          // (termination case 2).
          return aHaystack[mid];
        }
        else {
          // aHaystack[mid] is less than our needle.
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
          }
          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (2) or (3) and return the appropriate thing.
          return aLow < 0
            ? null
            : aHaystack[aLow];
        }
      }
    
      /**
       * This is an implementation of binary search which will always try and return
       * the next lowest value checked if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare) {
        return aHaystack.length > 0
          ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
          : null;
      };
    
    });
    
  provide("source-map/source-map/binary-search", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-generator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64VLQ =  require('source-map/source-map/base64-vlq');
      var util =  require('source-map/source-map/util');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
    
      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. You may pass an object with the following
       * properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: A root for all relative URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = [];
        this._sourcesContents = null;
      }
    
      SourceMapGenerator.prototype._version = 3;
    
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
    
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
              }
    
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
              };
    
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
    
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
    
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, 'generated');
          var original = util.getArg(aArgs, 'original', null);
          var source = util.getArg(aArgs, 'source', null);
          var name = util.getArg(aArgs, 'name', null);
    
          this._validateMapping(generated, original, source, name);
    
          if (source != null && !this._sources.has(source)) {
            this._sources.add(source);
          }
    
          if (name != null && !this._names.has(name)) {
            this._names.add(name);
          }
    
          this._mappings.push({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
          });
        };
    
      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
    
          if (aSourceContent != null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
              this._sourcesContents = {};
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
    
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          // If aSourceFile is omitted, we will use the file property of the SourceMap
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
                'or the source map\'s "file" property. Both were omitted.'
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          // Make "sourceFile" relative if an absolute Url is passed.
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          // Applying the SourceMap can add and remove items from the sources and
          // the names array.
          var newSources = new ArraySet();
          var newNames = new ArraySet();
    
          // Find mappings for the "sourceFile"
          this._mappings.forEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              // Check if it can be mapped by the source map, then update the mapping.
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source)
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
    
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
    
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
    
          }, this);
          this._sources = newSources;
          this._names = newNames;
    
          // Copy sourcesContents of applied map.
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
    
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                    aName) {
          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
              && aGenerated.line > 0 && aGenerated.column >= 0
              && !aOriginal && !aSource && !aName) {
            // Case 1.
            return;
          }
          else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                   && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                   && aGenerated.line > 0 && aGenerated.column >= 0
                   && aOriginal.line > 0 && aOriginal.column >= 0
                   && aSource) {
            // Cases 2 and 3.
            return;
          }
          else {
            throw new Error('Invalid mapping: ' + JSON.stringify({
              generated: aGenerated,
              source: aSource,
              original: aOriginal,
              name: aName
            }));
          }
        };
    
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = '';
          var mapping;
    
          // The mappings must be guaranteed to be in sorted order before we start
          // serializing them or else the generated line numbers (which are defined
          // via the ';' separators) will be all messed up. Note: it might be more
          // performant to maintain the sorting as we insert them, rather than as we
          // serialize them, but the big O is the same either way.
          this._mappings.sort(util.compareByGeneratedPositions);
    
          for (var i = 0, len = this._mappings.length; i < len; i++) {
            mapping = this._mappings[i];
    
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                result += ';';
                previousGeneratedLine++;
              }
            }
            else {
              if (i > 0) {
                if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
                  continue;
                }
                result += ',';
              }
            }
    
            result += base64VLQ.encode(mapping.generatedColumn
                                       - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
    
            if (mapping.source != null) {
              result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                         - previousSource);
              previousSource = this._sources.indexOf(mapping.source);
    
              // lines are stored 0-based in SourceMap spec version 3
              result += base64VLQ.encode(mapping.originalLine - 1
                                         - previousOriginalLine);
              previousOriginalLine = mapping.originalLine - 1;
    
              result += base64VLQ.encode(mapping.originalColumn
                                         - previousOriginalColumn);
              previousOriginalColumn = mapping.originalColumn;
    
              if (mapping.name != null) {
                result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                           - previousName);
                previousName = this._names.indexOf(mapping.name);
              }
            }
          }
    
          return result;
        };
    
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                        key)
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
    
      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
          }
    
          return map;
        };
    
      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this);
        };
    
      exports.SourceMapGenerator = SourceMapGenerator;
    
    });
    
  provide("source-map/source-map/source-map-generator", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-consumer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
      var binarySearch =  require('source-map/source-map/binary-search');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var base64VLQ =  require('source-map/source-map/base64-vlq');
    
      /**
       * A SourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The only parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: Optional. The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
    
        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
    
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
    
      /**
       * Create a SourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @returns SourceMapConsumer
       */
      SourceMapConsumer.fromSourceMap =
        function SourceMapConsumer_fromSourceMap(aSourceMap) {
          var smc = Object.create(SourceMapConsumer.prototype);
    
          smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
          smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                  smc.sourceRoot);
          smc.file = aSourceMap._file;
    
          smc.__generatedMappings = aSourceMap._mappings.slice()
            .sort(util.compareByGeneratedPositions);
          smc.__originalMappings = aSourceMap._mappings.slice()
            .sort(util.compareByOriginalPositions);
    
          return smc;
        };
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
    
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
    
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__generatedMappings;
        }
      });
    
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__originalMappings;
        }
      });
    
      SourceMapConsumer.prototype._nextCharIsMappingSeparator =
        function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
          var c = aStr.charAt(0);
          return c === ";" || c === ",";
        };
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var str = aStr;
          var temp = {};
          var mapping;
    
          while (str.length > 0) {
            if (str.charAt(0) === ';') {
              generatedLine++;
              str = str.slice(1);
              previousGeneratedColumn = 0;
            }
            else if (str.charAt(0) === ',') {
              str = str.slice(1);
            }
            else {
              mapping = {};
              mapping.generatedLine = generatedLine;
    
              // Generated column.
              base64VLQ.decode(str, temp);
              mapping.generatedColumn = previousGeneratedColumn + temp.value;
              previousGeneratedColumn = mapping.generatedColumn;
              str = temp.rest;
    
              if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
                // Original source.
                base64VLQ.decode(str, temp);
                mapping.source = this._sources.at(previousSource + temp.value);
                previousSource += temp.value;
                str = temp.rest;
                if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
                  throw new Error('Found a source, but no line and column');
                }
    
                // Original line.
                base64VLQ.decode(str, temp);
                mapping.originalLine = previousOriginalLine + temp.value;
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                str = temp.rest;
                if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
                  throw new Error('Found a source and line, but no column');
                }
    
                // Original column.
                base64VLQ.decode(str, temp);
                mapping.originalColumn = previousOriginalColumn + temp.value;
                previousOriginalColumn = mapping.originalColumn;
                str = temp.rest;
    
                if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
                  // Original name.
                  base64VLQ.decode(str, temp);
                  mapping.name = this._names.at(previousName + temp.value);
                  previousName += temp.value;
                  str = temp.rest;
                }
              }
    
              this.__generatedMappings.push(mapping);
              if (typeof mapping.originalLine === 'number') {
                this.__originalMappings.push(mapping);
              }
            }
          }
    
          this.__generatedMappings.sort(util.compareByGeneratedPositions);
          this.__originalMappings.sort(util.compareByOriginalPositions);
        };
    
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      SourceMapConsumer.prototype._findMapping =
        function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                               aColumnName, aComparator) {
          // To return the position we are searching for, we must first find the
          // mapping for the given position and then return the opposite position it
          // points to. Because the mappings are sorted, we can use binary search to
          // find the best mapping.
    
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError('Line must be greater than or equal to 1, got '
                                + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError('Column must be greater than or equal to 0, got '
                                + aNeedle[aColumnName]);
          }
    
          return binarySearch.search(aNeedle, aMappings, aComparator);
        };
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      SourceMapConsumer.prototype.originalPositionFor =
        function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          var mapping = this._findMapping(needle,
                                          this._generatedMappings,
                                          "generatedLine",
                                          "generatedColumn",
                                          util.compareByGeneratedPositions);
    
          if (mapping && mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source != null && this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
            return {
              source: source,
              line: util.getArg(mapping, 'originalLine', null),
              column: util.getArg(mapping, 'originalColumn', null),
              name: util.getArg(mapping, 'name', null)
            };
          }
    
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * availible.
       */
      SourceMapConsumer.prototype.sourceContentFor =
        function SourceMapConsumer_sourceContentFor(aSource) {
          if (!this.sourcesContent) {
            return null;
          }
    
          if (this.sourceRoot != null) {
            aSource = util.relative(this.sourceRoot, aSource);
          }
    
          if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
          }
    
          var url;
          if (this.sourceRoot != null
              && (url = util.urlParse(this.sourceRoot))) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file"
                && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
            }
    
            if ((!url.path || url.path == "/")
                && this._sources.has("/" + aSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
          }
    
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      SourceMapConsumer.prototype.generatedPositionFor =
        function SourceMapConsumer_generatedPositionFor(aArgs) {
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
    
          if (this.sourceRoot != null) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
    
          var mapping = this._findMapping(needle,
                                          this._originalMappings,
                                          "originalLine",
                                          "originalColumn",
                                          util.compareByOriginalPositions);
    
          if (mapping) {
            return {
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null)
            };
          }
    
          return {
            line: null,
            column: null
          };
        };
    
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
    
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping =
        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    
          var mappings;
          switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
          }
    
          var sourceRoot = this.sourceRoot;
          mappings.map(function (mapping) {
            var source = mapping.source;
            if (source != null && sourceRoot != null) {
              source = util.join(sourceRoot, source);
            }
            return {
              source: source,
              generatedLine: mapping.generatedLine,
              generatedColumn: mapping.generatedColumn,
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: mapping.name
            };
          }).forEach(aCallback, context);
        };
    
      exports.SourceMapConsumer = SourceMapConsumer;
    
    });
    
  provide("source-map/source-map/source-map-consumer", module.exports);
}(global));

// pakmanager:source-map/source-map/source-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
      var util =  require('source-map/source-map/util');
    
      // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
      // operating systems these days (capturing the result).
      var REGEX_NEWLINE = /(\r?\n)/;
    
      // Matches a Windows-style newline, or any character.
      var REGEX_CHARACTER = /\r\n|[\s\S]/g;
    
      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        if (aChunks != null) this.add(aChunks);
      }
    
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      SourceNode.fromStringWithSourceMap =
        function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          // The SourceNode we want to fill with the generated code
          // and the SourceMap
          var node = new SourceNode();
    
          // All even indices of this array are one line of the generated code,
          // while all odd indices are the newlines between two adjacent lines
          // (since `REGEX_NEWLINE` captures its match).
          // Processed fragments are removed from this array, by calling `shiftNextLine`.
          var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
          var shiftNextLine = function() {
            var lineContents = remainingLines.shift();
            // The last line of a file might not have a newline.
            var newLine = remainingLines.shift() || "";
            return lineContents + newLine;
          };
    
          // We need to remember the position of "remainingLines"
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    
          // The generate SourceNodes we need a code range.
          // To extract it current and last mapping is used.
          // Here we store the last mapping.
          var lastMapping = null;
    
          aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping !== null) {
              // We add the code from "lastMapping" to "mapping":
              // First check if there is a new line in between.
              if (lastGeneratedLine < mapping.generatedLine) {
                var code = "";
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
                // The remaining code is added without mapping
              } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[0];
                var code = nextLine.substr(0, mapping.generatedColumn -
                                              lastGeneratedColumn);
                remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                    lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
              }
            }
            // We add the generated code until the first mapping
            // to the SourceNode without any mapping.
            // Each line is added as separate string.
            while (lastGeneratedLine < mapping.generatedLine) {
              node.add(shiftNextLine());
              lastGeneratedLine++;
            }
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              node.add(nextLine.substr(0, mapping.generatedColumn));
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this);
          // We have processed all mappings.
          if (remainingLines.length > 0) {
            if (lastMapping) {
              // Associate the remaining code in the current line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
            }
            // and add the remaining lines without any mapping
            node.add(remainingLines.join(""));
          }
    
          // Copy sourcesContent into SourceNode
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
              }
              node.setSourceContent(sourceFile, content);
            }
          });
    
          return node;
    
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
              node.add(code);
            } else {
              var source = aRelativePath
                ? util.join(aRelativePath, mapping.source)
                : mapping.source;
              node.add(new SourceNode(mapping.originalLine,
                                      mapping.originalColumn,
                                      source,
                                      code,
                                      mapping.name));
            }
          }
        };
    
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        }
        else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length-1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        }
        else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk instanceof SourceNode) {
            chunk.walk(aFn);
          }
          else {
            if (chunk !== '') {
              aFn(chunk, { source: this.source,
                           line: this.line,
                           column: this.column,
                           name: this.name });
            }
          }
        }
      };
    
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len-1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
    
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild instanceof SourceNode) {
          lastChild.replaceRight(aPattern, aReplacement);
        }
        else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        }
        else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
    
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent =
        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
    
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents =
        function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i] instanceof SourceNode) {
              this.children[i].walkSourceContents(aFn);
            }
          }
    
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
    
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
    
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null
              && original.line !== null
              && original.column !== null) {
            if(lastOriginalSource !== original.source
               || lastOriginalLine !== original.line
               || lastOriginalColumn !== original.column
               || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          chunk.match(REGEX_CHARACTER).forEach(function (ch, idx, array) {
            if (REGEX_NEWLINE.test(ch)) {
              generated.line++;
              generated.column = 0;
              // Mappings end at eol
              if (idx + 1 === array.length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column += ch.length;
            }
          });
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
    
        return { code: generated.code, map: map };
      };
    
      exports.SourceNode = SourceNode;
    
    });
    
  provide("source-map/source-map/source-node", module.exports);
}(global));

// pakmanager:source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer =  require('source-map/source-map/source-map-consumer').SourceMapConsumer;
    exports.SourceNode =  require('source-map/source-map/source-node').SourceNode;
    
  provide("source-map", module.exports);
}(global));

// pakmanager:source-map-resolve/lib/resolve-url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    var url = require("url")
    
    function resolveUrl(/* ...urls */) {
      return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {
        return url.resolve(resolved, nextUrl)
      })
    }
    
    module.exports = resolveUrl
    
  provide("source-map-resolve/lib/resolve-url", module.exports);
}(global));

// pakmanager:source-map-resolve
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    var sourceMappingURL = require("source-map-url")
    var resolveUrl       =  require('source-map-resolve/lib/resolve-url')
    var urix             = require("urix")
    var atob             = require("atob")
    
    
    
    function callbackAsync(callback, error, result) {
      setImmediate(function() { callback(error, result) })
    }
    
    function parseMapToJSON(string) {
      return JSON.parse(string.replace(/^\)\]\}'/, ""))
    }
    
    
    
    function resolveSourceMap(code, codeUrl, read, callback) {
      var mapData
      try {
        mapData = resolveSourceMapHelper(code, codeUrl)
      } catch (error) {
        return callbackAsync(callback, error)
      }
      if (!mapData || mapData.map) {
        return callbackAsync(callback, null, mapData)
      }
      read(mapData.url, function(error, result) {
        if (error) {
          return callback(error)
        }
        try {
          mapData.map = parseMapToJSON(String(result))
        } catch (error) {
          return callback(error)
        }
        callback(null, mapData)
      })
    }
    
    function resolveSourceMapSync(code, codeUrl, read) {
      var mapData = resolveSourceMapHelper(code, codeUrl)
      if (!mapData || mapData.map) {
        return mapData
      }
      mapData.map = parseMapToJSON(String(read(mapData.url)))
      return mapData
    }
    
    var dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/
    var jsonMimeTypeRegex = /^(?:application|text)\/json$/
    
    function resolveSourceMapHelper(code, codeUrl) {
      codeUrl = urix(codeUrl)
    
      var url = sourceMappingURL.getFrom(code)
      if (!url) {
        return null
      }
    
      var dataUri = url.match(dataUriRegex)
      if (dataUri) {
        var mimeType = dataUri[1]
        var lastParameter = dataUri[2]
        var encoded = dataUri[3]
        if (!jsonMimeTypeRegex.test(mimeType)) {
          throw new Error("Unuseful data uri mime type: " + (mimeType || "text/plain"))
        }
        return {
          sourceMappingURL: url,
          url: null,
          sourcesRelativeTo: codeUrl,
          map: parseMapToJSON(lastParameter === ";base64" ? atob(encoded) : decodeURIComponent(encoded))
        }
      }
    
      var mapUrl = resolveUrl(codeUrl, url)
      return {
        sourceMappingURL: url,
        url: mapUrl,
        sourcesRelativeTo: mapUrl,
        map: null
      }
    }
    
    
    
    function resolveSources(map, mapUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options
        options = {}
      }
      var pending = map.sources.length
      var errored = false
      var result = {
        sourcesResolved: [],
        sourcesContent:  []
      }
    
      var done = function(error) {
        if (errored) {
          return
        }
        if (error) {
          errored = true
          return callback(error)
        }
        pending--
        if (pending === 0) {
          callback(null, result)
        }
      }
    
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl
        if (typeof sourceContent === "string") {
          result.sourcesContent[index] = sourceContent
          callbackAsync(done, null)
        } else {
          read(fullUrl, function(error, source) {
            result.sourcesContent[index] = String(source)
            done(error)
          })
        }
      })
    }
    
    function resolveSourcesSync(map, mapUrl, read, options) {
      var result = {
        sourcesResolved: [],
        sourcesContent:  []
      }
      resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {
        result.sourcesResolved[index] = fullUrl
        if (read !== null) {
          if (typeof sourceContent === "string") {
            result.sourcesContent[index] = sourceContent
          } else {
            result.sourcesContent[index] = String(read(fullUrl))
          }
        }
      })
      return result
    }
    
    var endingSlash = /\/?$/
    
    function resolveSourcesHelper(map, mapUrl, options, fn) {
      options = options || {}
      mapUrl = urix(mapUrl)
      var fullUrl
      var sourceContent
      for (var index = 0, len = map.sources.length; index < len; index++) {
        if (map.sourceRoot && !options.ignoreSourceRoot) {
          // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes
          // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root
          // does not make sense.
          fullUrl = resolveUrl(mapUrl, map.sourceRoot.replace(endingSlash, "/"), map.sources[index])
        } else {
          fullUrl = resolveUrl(mapUrl, map.sources[index])
        }
        sourceContent = (map.sourcesContent || [])[index]
        fn(fullUrl, sourceContent, index)
      }
    }
    
    
    
    function resolve(code, codeUrl, read, options, callback) {
      if (typeof options === "function") {
        callback = options
        options = {}
      }
      resolveSourceMap(code, codeUrl, read, function(error, mapData) {
        if (error) {
          return callback(error)
        }
        if (!mapData) {
          return callback(null, null)
        }
        resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {
          if (error) {
            return callback(error)
          }
          mapData.sourcesResolved = result.sourcesResolved
          mapData.sourcesContent  = result.sourcesContent
          callback(null, mapData)
        })
      })
    }
    
    function resolveSync(code, codeUrl, read, options) {
      var mapData = resolveSourceMapSync(code, codeUrl, read)
      if (!mapData) {
        return null
      }
      var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)
      mapData.sourcesResolved = result.sourcesResolved
      mapData.sourcesContent  = result.sourcesContent
      return mapData
    }
    
    
    
    module.exports = {
      resolveSourceMap:     resolveSourceMap,
      resolveSourceMapSync: resolveSourceMapSync,
      resolveSources:       resolveSources,
      resolveSourcesSync:   resolveSourcesSync,
      resolve:              resolve,
      resolveSync:          resolveSync
    }
    
  provide("source-map-resolve", module.exports);
}(global));

// pakmanager:async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * async
     * https://github.com/caolan/async
     *
     * Copyright 2010-2014 Caolan McMahon
     * Released under the MIT license
     */
    /*jshint onevar: false, indent:4 */
    /*global setImmediate: false, setTimeout: false, console: false */
    (function () {
    
        var async = {};
    
        // global on the server, window in the browser
        var root, previous_async;
    
        root = this;
        if (root != null) {
          previous_async = root.async;
        }
    
        async.noConflict = function () {
            root.async = previous_async;
            return async;
        };
    
        function only_once(fn) {
            var called = false;
            return function() {
                if (called) throw new Error("Callback was already called.");
                called = true;
                fn.apply(root, arguments);
            }
        }
    
        //// cross-browser compatiblity functions ////
    
        var _toString = Object.prototype.toString;
    
        var _isArray = Array.isArray || function (obj) {
            return _toString.call(obj) === '[object Array]';
        };
    
        var _each = function (arr, iterator) {
            if (arr.forEach) {
                return arr.forEach(iterator);
            }
            for (var i = 0; i < arr.length; i += 1) {
                iterator(arr[i], i, arr);
            }
        };
    
        var _map = function (arr, iterator) {
            if (arr.map) {
                return arr.map(iterator);
            }
            var results = [];
            _each(arr, function (x, i, a) {
                results.push(iterator(x, i, a));
            });
            return results;
        };
    
        var _reduce = function (arr, iterator, memo) {
            if (arr.reduce) {
                return arr.reduce(iterator, memo);
            }
            _each(arr, function (x, i, a) {
                memo = iterator(memo, x, i, a);
            });
            return memo;
        };
    
        var _keys = function (obj) {
            if (Object.keys) {
                return Object.keys(obj);
            }
            var keys = [];
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    keys.push(k);
                }
            }
            return keys;
        };
    
        //// exported async module functions ////
    
        //// nextTick implementation with browser-compatible fallback ////
        if (typeof process === 'undefined' || !(process.nextTick)) {
            if (typeof setImmediate === 'function') {
                async.nextTick = function (fn) {
                    // not a direct alias for IE10 compatibility
                    setImmediate(fn);
                };
                async.setImmediate = async.nextTick;
            }
            else {
                async.nextTick = function (fn) {
                    setTimeout(fn, 0);
                };
                async.setImmediate = async.nextTick;
            }
        }
        else {
            async.nextTick = process.nextTick;
            if (typeof setImmediate !== 'undefined') {
                async.setImmediate = function (fn) {
                  // not a direct alias for IE10 compatibility
                  setImmediate(fn);
                };
            }
            else {
                async.setImmediate = async.nextTick;
            }
        }
    
        async.each = function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length) {
                return callback();
            }
            var completed = 0;
            _each(arr, function (x) {
                iterator(x, only_once(done) );
            });
            function done(err) {
              if (err) {
                  callback(err);
                  callback = function () {};
              }
              else {
                  completed += 1;
                  if (completed >= arr.length) {
                      callback();
                  }
              }
            }
        };
        async.forEach = async.each;
    
        async.eachSeries = function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length) {
                return callback();
            }
            var completed = 0;
            var iterate = function () {
                iterator(arr[completed], function (err) {
                    if (err) {
                        callback(err);
                        callback = function () {};
                    }
                    else {
                        completed += 1;
                        if (completed >= arr.length) {
                            callback();
                        }
                        else {
                            iterate();
                        }
                    }
                });
            };
            iterate();
        };
        async.forEachSeries = async.eachSeries;
    
        async.eachLimit = function (arr, limit, iterator, callback) {
            var fn = _eachLimit(limit);
            fn.apply(null, [arr, iterator, callback]);
        };
        async.forEachLimit = async.eachLimit;
    
        var _eachLimit = function (limit) {
    
            return function (arr, iterator, callback) {
                callback = callback || function () {};
                if (!arr.length || limit <= 0) {
                    return callback();
                }
                var completed = 0;
                var started = 0;
                var running = 0;
    
                (function replenish () {
                    if (completed >= arr.length) {
                        return callback();
                    }
    
                    while (running < limit && started < arr.length) {
                        started += 1;
                        running += 1;
                        iterator(arr[started - 1], function (err) {
                            if (err) {
                                callback(err);
                                callback = function () {};
                            }
                            else {
                                completed += 1;
                                running -= 1;
                                if (completed >= arr.length) {
                                    callback();
                                }
                                else {
                                    replenish();
                                }
                            }
                        });
                    }
                })();
            };
        };
    
    
        var doParallel = function (fn) {
            return function () {
                var args = Array.prototype.slice.call(arguments);
                return fn.apply(null, [async.each].concat(args));
            };
        };
        var doParallelLimit = function(limit, fn) {
            return function () {
                var args = Array.prototype.slice.call(arguments);
                return fn.apply(null, [_eachLimit(limit)].concat(args));
            };
        };
        var doSeries = function (fn) {
            return function () {
                var args = Array.prototype.slice.call(arguments);
                return fn.apply(null, [async.eachSeries].concat(args));
            };
        };
    
    
        var _asyncMap = function (eachfn, arr, iterator, callback) {
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            if (!callback) {
                eachfn(arr, function (x, callback) {
                    iterator(x.value, function (err) {
                        callback(err);
                    });
                });
            } else {
                var results = [];
                eachfn(arr, function (x, callback) {
                    iterator(x.value, function (err, v) {
                        results[x.index] = v;
                        callback(err);
                    });
                }, function (err) {
                    callback(err, results);
                });
            }
        };
        async.map = doParallel(_asyncMap);
        async.mapSeries = doSeries(_asyncMap);
        async.mapLimit = function (arr, limit, iterator, callback) {
            return _mapLimit(limit)(arr, iterator, callback);
        };
    
        var _mapLimit = function(limit) {
            return doParallelLimit(limit, _asyncMap);
        };
    
        // reduce only has a series version, as doing reduce in parallel won't
        // work in many situations.
        async.reduce = function (arr, memo, iterator, callback) {
            async.eachSeries(arr, function (x, callback) {
                iterator(memo, x, function (err, v) {
                    memo = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, memo);
            });
        };
        // inject alias
        async.inject = async.reduce;
        // foldl alias
        async.foldl = async.reduce;
    
        async.reduceRight = function (arr, memo, iterator, callback) {
            var reversed = _map(arr, function (x) {
                return x;
            }).reverse();
            async.reduce(reversed, memo, iterator, callback);
        };
        // foldr alias
        async.foldr = async.reduceRight;
    
        var _filter = function (eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (v) {
                    if (v) {
                        results.push(x);
                    }
                    callback();
                });
            }, function (err) {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        };
        async.filter = doParallel(_filter);
        async.filterSeries = doSeries(_filter);
        // select alias
        async.select = async.filter;
        async.selectSeries = async.filterSeries;
    
        var _reject = function (eachfn, arr, iterator, callback) {
            var results = [];
            arr = _map(arr, function (x, i) {
                return {index: i, value: x};
            });
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (v) {
                    if (!v) {
                        results.push(x);
                    }
                    callback();
                });
            }, function (err) {
                callback(_map(results.sort(function (a, b) {
                    return a.index - b.index;
                }), function (x) {
                    return x.value;
                }));
            });
        };
        async.reject = doParallel(_reject);
        async.rejectSeries = doSeries(_reject);
    
        var _detect = function (eachfn, arr, iterator, main_callback) {
            eachfn(arr, function (x, callback) {
                iterator(x, function (result) {
                    if (result) {
                        main_callback(x);
                        main_callback = function () {};
                    }
                    else {
                        callback();
                    }
                });
            }, function (err) {
                main_callback();
            });
        };
        async.detect = doParallel(_detect);
        async.detectSeries = doSeries(_detect);
    
        async.some = function (arr, iterator, main_callback) {
            async.each(arr, function (x, callback) {
                iterator(x, function (v) {
                    if (v) {
                        main_callback(true);
                        main_callback = function () {};
                    }
                    callback();
                });
            }, function (err) {
                main_callback(false);
            });
        };
        // any alias
        async.any = async.some;
    
        async.every = function (arr, iterator, main_callback) {
            async.each(arr, function (x, callback) {
                iterator(x, function (v) {
                    if (!v) {
                        main_callback(false);
                        main_callback = function () {};
                    }
                    callback();
                });
            }, function (err) {
                main_callback(true);
            });
        };
        // all alias
        async.all = async.every;
    
        async.sortBy = function (arr, iterator, callback) {
            async.map(arr, function (x, callback) {
                iterator(x, function (err, criteria) {
                    if (err) {
                        callback(err);
                    }
                    else {
                        callback(null, {value: x, criteria: criteria});
                    }
                });
            }, function (err, results) {
                if (err) {
                    return callback(err);
                }
                else {
                    var fn = function (left, right) {
                        var a = left.criteria, b = right.criteria;
                        return a < b ? -1 : a > b ? 1 : 0;
                    };
                    callback(null, _map(results.sort(fn), function (x) {
                        return x.value;
                    }));
                }
            });
        };
    
        async.auto = function (tasks, callback) {
            callback = callback || function () {};
            var keys = _keys(tasks);
            var remainingTasks = keys.length
            if (!remainingTasks) {
                return callback();
            }
    
            var results = {};
    
            var listeners = [];
            var addListener = function (fn) {
                listeners.unshift(fn);
            };
            var removeListener = function (fn) {
                for (var i = 0; i < listeners.length; i += 1) {
                    if (listeners[i] === fn) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            };
            var taskComplete = function () {
                remainingTasks--
                _each(listeners.slice(0), function (fn) {
                    fn();
                });
            };
    
            addListener(function () {
                if (!remainingTasks) {
                    var theCallback = callback;
                    // prevent final callback from calling itself if it errors
                    callback = function () {};
    
                    theCallback(null, results);
                }
            });
    
            _each(keys, function (k) {
                var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                var taskCallback = function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    if (err) {
                        var safeResults = {};
                        _each(_keys(results), function(rkey) {
                            safeResults[rkey] = results[rkey];
                        });
                        safeResults[k] = args;
                        callback(err, safeResults);
                        // stop subsequent errors hitting callback multiple times
                        callback = function () {};
                    }
                    else {
                        results[k] = args;
                        async.setImmediate(taskComplete);
                    }
                };
                var requires = task.slice(0, Math.abs(task.length - 1)) || [];
                var ready = function () {
                    return _reduce(requires, function (a, x) {
                        return (a && results.hasOwnProperty(x));
                    }, true) && !results.hasOwnProperty(k);
                };
                if (ready()) {
                    task[task.length - 1](taskCallback, results);
                }
                else {
                    var listener = function () {
                        if (ready()) {
                            removeListener(listener);
                            task[task.length - 1](taskCallback, results);
                        }
                    };
                    addListener(listener);
                }
            });
        };
    
        async.retry = function(times, task, callback) {
            var DEFAULT_TIMES = 5;
            var attempts = [];
            // Use defaults if times not passed
            if (typeof times === 'function') {
                callback = task;
                task = times;
                times = DEFAULT_TIMES;
            }
            // Make sure times is a number
            times = parseInt(times, 10) || DEFAULT_TIMES;
            var wrappedTask = function(wrappedCallback, wrappedResults) {
                var retryAttempt = function(task, finalAttempt) {
                    return function(seriesCallback) {
                        task(function(err, result){
                            seriesCallback(!err || finalAttempt, {err: err, result: result});
                        }, wrappedResults);
                    };
                };
                while (times) {
                    attempts.push(retryAttempt(task, !(times-=1)));
                }
                async.series(attempts, function(done, data){
                    data = data[data.length - 1];
                    (wrappedCallback || callback)(data.err, data.result);
                });
            }
            // If a callback is passed, run this as a controll flow
            return callback ? wrappedTask() : wrappedTask
        };
    
        async.waterfall = function (tasks, callback) {
            callback = callback || function () {};
            if (!_isArray(tasks)) {
              var err = new Error('First argument to waterfall must be an array of functions');
              return callback(err);
            }
            if (!tasks.length) {
                return callback();
            }
            var wrapIterator = function (iterator) {
                return function (err) {
                    if (err) {
                        callback.apply(null, arguments);
                        callback = function () {};
                    }
                    else {
                        var args = Array.prototype.slice.call(arguments, 1);
                        var next = iterator.next();
                        if (next) {
                            args.push(wrapIterator(next));
                        }
                        else {
                            args.push(callback);
                        }
                        async.setImmediate(function () {
                            iterator.apply(null, args);
                        });
                    }
                };
            };
            wrapIterator(async.iterator(tasks))();
        };
    
        var _parallel = function(eachfn, tasks, callback) {
            callback = callback || function () {};
            if (_isArray(tasks)) {
                eachfn.map(tasks, function (fn, callback) {
                    if (fn) {
                        fn(function (err) {
                            var args = Array.prototype.slice.call(arguments, 1);
                            if (args.length <= 1) {
                                args = args[0];
                            }
                            callback.call(null, err, args);
                        });
                    }
                }, callback);
            }
            else {
                var results = {};
                eachfn.each(_keys(tasks), function (k, callback) {
                    tasks[k](function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        results[k] = args;
                        callback(err);
                    });
                }, function (err) {
                    callback(err, results);
                });
            }
        };
    
        async.parallel = function (tasks, callback) {
            _parallel({ map: async.map, each: async.each }, tasks, callback);
        };
    
        async.parallelLimit = function(tasks, limit, callback) {
            _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
        };
    
        async.series = function (tasks, callback) {
            callback = callback || function () {};
            if (_isArray(tasks)) {
                async.mapSeries(tasks, function (fn, callback) {
                    if (fn) {
                        fn(function (err) {
                            var args = Array.prototype.slice.call(arguments, 1);
                            if (args.length <= 1) {
                                args = args[0];
                            }
                            callback.call(null, err, args);
                        });
                    }
                }, callback);
            }
            else {
                var results = {};
                async.eachSeries(_keys(tasks), function (k, callback) {
                    tasks[k](function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        results[k] = args;
                        callback(err);
                    });
                }, function (err) {
                    callback(err, results);
                });
            }
        };
    
        async.iterator = function (tasks) {
            var makeCallback = function (index) {
                var fn = function () {
                    if (tasks.length) {
                        tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                };
                fn.next = function () {
                    return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                };
                return fn;
            };
            return makeCallback(0);
        };
    
        async.apply = function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            return function () {
                return fn.apply(
                    null, args.concat(Array.prototype.slice.call(arguments))
                );
            };
        };
    
        var _concat = function (eachfn, arr, fn, callback) {
            var r = [];
            eachfn(arr, function (x, cb) {
                fn(x, function (err, y) {
                    r = r.concat(y || []);
                    cb(err);
                });
            }, function (err) {
                callback(err, r);
            });
        };
        async.concat = doParallel(_concat);
        async.concatSeries = doSeries(_concat);
    
        async.whilst = function (test, iterator, callback) {
            if (test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.whilst(test, iterator, callback);
                });
            }
            else {
                callback();
            }
        };
    
        async.doWhilst = function (iterator, test, callback) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = Array.prototype.slice.call(arguments, 1);
                if (test.apply(null, args)) {
                    async.doWhilst(iterator, test, callback);
                }
                else {
                    callback();
                }
            });
        };
    
        async.until = function (test, iterator, callback) {
            if (!test()) {
                iterator(function (err) {
                    if (err) {
                        return callback(err);
                    }
                    async.until(test, iterator, callback);
                });
            }
            else {
                callback();
            }
        };
    
        async.doUntil = function (iterator, test, callback) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                var args = Array.prototype.slice.call(arguments, 1);
                if (!test.apply(null, args)) {
                    async.doUntil(iterator, test, callback);
                }
                else {
                    callback();
                }
            });
        };
    
        async.queue = function (worker, concurrency) {
            if (concurrency === undefined) {
                concurrency = 1;
            }
            function _insert(q, data, pos, callback) {
              if (!q.started){
                q.started = true;
              }
              if (!_isArray(data)) {
                  data = [data];
              }
              if(data.length == 0) {
                 // call drain immediately if there are no tasks
                 return async.setImmediate(function() {
                     if (q.drain) {
                         q.drain();
                     }
                 });
              }
              _each(data, function(task) {
                  var item = {
                      data: task,
                      callback: typeof callback === 'function' ? callback : null
                  };
    
                  if (pos) {
                    q.tasks.unshift(item);
                  } else {
                    q.tasks.push(item);
                  }
    
                  if (q.saturated && q.tasks.length === q.concurrency) {
                      q.saturated();
                  }
                  async.setImmediate(q.process);
              });
            }
    
            var workers = 0;
            var q = {
                tasks: [],
                concurrency: concurrency,
                saturated: null,
                empty: null,
                drain: null,
                started: false,
                paused: false,
                push: function (data, callback) {
                  _insert(q, data, false, callback);
                },
                kill: function () {
                  q.drain = null;
                  q.tasks = [];
                },
                unshift: function (data, callback) {
                  _insert(q, data, true, callback);
                },
                process: function () {
                    if (!q.paused && workers < q.concurrency && q.tasks.length) {
                        var task = q.tasks.shift();
                        if (q.empty && q.tasks.length === 0) {
                            q.empty();
                        }
                        workers += 1;
                        var next = function () {
                            workers -= 1;
                            if (task.callback) {
                                task.callback.apply(task, arguments);
                            }
                            if (q.drain && q.tasks.length + workers === 0) {
                                q.drain();
                            }
                            q.process();
                        };
                        var cb = only_once(next);
                        worker(task.data, cb);
                    }
                },
                length: function () {
                    return q.tasks.length;
                },
                running: function () {
                    return workers;
                },
                idle: function() {
                    return q.tasks.length + workers === 0;
                },
                pause: function () {
                    if (q.paused === true) { return; }
                    q.paused = true;
                    q.process();
                },
                resume: function () {
                    if (q.paused === false) { return; }
                    q.paused = false;
                    q.process();
                }
            };
            return q;
        };
        
        async.priorityQueue = function (worker, concurrency) {
            
            function _compareTasks(a, b){
              return a.priority - b.priority;
            };
            
            function _binarySearch(sequence, item, compare) {
              var beg = -1,
                  end = sequence.length - 1;
              while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                  beg = mid;
                } else {
                  end = mid - 1;
                }
              }
              return beg;
            }
            
            function _insert(q, data, priority, callback) {
              if (!q.started){
                q.started = true;
              }
              if (!_isArray(data)) {
                  data = [data];
              }
              if(data.length == 0) {
                 // call drain immediately if there are no tasks
                 return async.setImmediate(function() {
                     if (q.drain) {
                         q.drain();
                     }
                 });
              }
              _each(data, function(task) {
                  var item = {
                      data: task,
                      priority: priority,
                      callback: typeof callback === 'function' ? callback : null
                  };
                  
                  q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
    
                  if (q.saturated && q.tasks.length === q.concurrency) {
                      q.saturated();
                  }
                  async.setImmediate(q.process);
              });
            }
            
            // Start with a normal queue
            var q = async.queue(worker, concurrency);
            
            // Override push to accept second parameter representing priority
            q.push = function (data, priority, callback) {
              _insert(q, data, priority, callback);
            };
            
            // Remove unshift function
            delete q.unshift;
    
            return q;
        };
    
        async.cargo = function (worker, payload) {
            var working     = false,
                tasks       = [];
    
            var cargo = {
                tasks: tasks,
                payload: payload,
                saturated: null,
                empty: null,
                drain: null,
                drained: true,
                push: function (data, callback) {
                    if (!_isArray(data)) {
                        data = [data];
                    }
                    _each(data, function(task) {
                        tasks.push({
                            data: task,
                            callback: typeof callback === 'function' ? callback : null
                        });
                        cargo.drained = false;
                        if (cargo.saturated && tasks.length === payload) {
                            cargo.saturated();
                        }
                    });
                    async.setImmediate(cargo.process);
                },
                process: function process() {
                    if (working) return;
                    if (tasks.length === 0) {
                        if(cargo.drain && !cargo.drained) cargo.drain();
                        cargo.drained = true;
                        return;
                    }
    
                    var ts = typeof payload === 'number'
                                ? tasks.splice(0, payload)
                                : tasks.splice(0, tasks.length);
    
                    var ds = _map(ts, function (task) {
                        return task.data;
                    });
    
                    if(cargo.empty) cargo.empty();
                    working = true;
                    worker(ds, function () {
                        working = false;
    
                        var args = arguments;
                        _each(ts, function (data) {
                            if (data.callback) {
                                data.callback.apply(null, args);
                            }
                        });
    
                        process();
                    });
                },
                length: function () {
                    return tasks.length;
                },
                running: function () {
                    return working;
                }
            };
            return cargo;
        };
    
        var _console_fn = function (name) {
            return function (fn) {
                var args = Array.prototype.slice.call(arguments, 1);
                fn.apply(null, args.concat([function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (typeof console !== 'undefined') {
                        if (err) {
                            if (console.error) {
                                console.error(err);
                            }
                        }
                        else if (console[name]) {
                            _each(args, function (x) {
                                console[name](x);
                            });
                        }
                    }
                }]));
            };
        };
        async.log = _console_fn('log');
        async.dir = _console_fn('dir');
        /*async.info = _console_fn('info');
        async.warn = _console_fn('warn');
        async.error = _console_fn('error');*/
    
        async.memoize = function (fn, hasher) {
            var memo = {};
            var queues = {};
            hasher = hasher || function (x) {
                return x;
            };
            var memoized = function () {
                var args = Array.prototype.slice.call(arguments);
                var callback = args.pop();
                var key = hasher.apply(null, args);
                if (key in memo) {
                    async.nextTick(function () {
                        callback.apply(null, memo[key]);
                    });
                }
                else if (key in queues) {
                    queues[key].push(callback);
                }
                else {
                    queues[key] = [callback];
                    fn.apply(null, args.concat([function () {
                        memo[key] = arguments;
                        var q = queues[key];
                        delete queues[key];
                        for (var i = 0, l = q.length; i < l; i++) {
                          q[i].apply(null, arguments);
                        }
                    }]));
                }
            };
            memoized.memo = memo;
            memoized.unmemoized = fn;
            return memoized;
        };
    
        async.unmemoize = function (fn) {
          return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
          };
        };
    
        async.times = function (count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
                counter.push(i);
            }
            return async.map(counter, iterator, callback);
        };
    
        async.timesSeries = function (count, iterator, callback) {
            var counter = [];
            for (var i = 0; i < count; i++) {
                counter.push(i);
            }
            return async.mapSeries(counter, iterator, callback);
        };
    
        async.seq = function (/* functions... */) {
            var fns = arguments;
            return function () {
                var that = this;
                var args = Array.prototype.slice.call(arguments);
                var callback = args.pop();
                async.reduce(fns, args, function (newargs, fn, cb) {
                    fn.apply(that, newargs.concat([function () {
                        var err = arguments[0];
                        var nextargs = Array.prototype.slice.call(arguments, 1);
                        cb(err, nextargs);
                    }]))
                },
                function (err, results) {
                    callback.apply(that, [err].concat(results));
                });
            };
        };
    
        async.compose = function (/* functions... */) {
          return async.seq.apply(null, Array.prototype.reverse.call(arguments));
        };
    
        var _applyEach = function (eachfn, fns /*args...*/) {
            var go = function () {
                var that = this;
                var args = Array.prototype.slice.call(arguments);
                var callback = args.pop();
                return eachfn(fns, function (fn, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            };
            if (arguments.length > 2) {
                var args = Array.prototype.slice.call(arguments, 2);
                return go.apply(this, args);
            }
            else {
                return go;
            }
        };
        async.applyEach = doParallel(_applyEach);
        async.applyEachSeries = doSeries(_applyEach);
    
        async.forever = function (fn, callback) {
            function next(err) {
                if (err) {
                    if (callback) {
                        return callback(err);
                    }
                    throw err;
                }
                fn(next);
            }
            next();
        };
    
        // Node.js
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = async;
        }
        // AMD / RequireJS
        else if (typeof define !== 'undefined' && define.amd) {
            define([], function () {
                return async;
            });
        }
        // included directly via <script> tag
        else {
            root.async = async;
        }
    
    }());
    
  provide("async", module.exports);
}(global));

// pakmanager:optimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var minimist = require('minimist');
    var wordwrap = require('wordwrap');
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
             require('optimist')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
             require('optimist').argv
        to get a parsed version of process.argv.
    */
    
    var inst = Argv(process.argv.slice(2));
    Object.keys(inst).forEach(function (key) {
        Argv[key] = typeof inst[key] == 'function'
            ? inst[key].bind(inst)
            : inst[key];
    });
    
    var exports = module.exports = Argv;
    function Argv (processArgs, cwd) {
        var self = {};
        if (!cwd) cwd = process.cwd();
        
        self.$0 = process.argv
            .slice(0,2)
            .map(function (x) {
                var b = rebase(cwd, x);
                return x.match(/^\//) && b.length < x.length
                    ? b : x
            })
            .join(' ')
        ;
        
        if (process.env._ != undefined && process.argv[1] == process.env._) {
            self.$0 = process.env._.replace(
                path.dirname(process.execPath) + '/', ''
            );
        }
        
        var options = {
            boolean: [],
            string: [],
            alias: {},
            default: []
        };
        
        self.boolean = function (bools) {
            options.boolean.push.apply(options.boolean, [].concat(bools));
            return self;
        };
        
        self.string = function (strings) {
            options.string.push.apply(options.string, [].concat(strings));
            return self;
        };
        
        self.default = function (key, value) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.default(k, key[k]);
                });
            }
            else {
                options.default[key] = value;
            }
            return self;
        };
        
        self.alias = function (x, y) {
            if (typeof x === 'object') {
                Object.keys(x).forEach(function (key) {
                    self.alias(key, x[key]);
                });
            }
            else {
                options.alias[x] = (options.alias[x] || []).concat(y);
            }
            return self;
        };
        
        var demanded = {};
        self.demand = function (keys) {
            if (typeof keys == 'number') {
                if (!demanded._) demanded._ = 0;
                demanded._ += keys;
            }
            else if (Array.isArray(keys)) {
                keys.forEach(function (key) {
                    self.demand(key);
                });
            }
            else {
                demanded[keys] = true;
            }
            
            return self;
        };
        
        var usage;
        self.usage = function (msg, opts) {
            if (!opts && typeof msg === 'object') {
                opts = msg;
                msg = null;
            }
            
            usage = msg;
            
            if (opts) self.options(opts);
            
            return self;
        };
        
        function fail (msg) {
            self.showHelp();
            if (msg) console.error(msg);
            process.exit(1);
        }
        
        var checks = [];
        self.check = function (f) {
            checks.push(f);
            return self;
        };
        
        var descriptions = {};
        self.describe = function (key, desc) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.describe(k, key[k]);
                });
            }
            else {
                descriptions[key] = desc;
            }
            return self;
        };
        
        self.parse = function (args) {
            return parseArgs(args);
        };
        
        self.option = self.options = function (key, opt) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.options(k, key[k]);
                });
            }
            else {
                if (opt.alias) self.alias(key, opt.alias);
                if (opt.demand) self.demand(key);
                if (typeof opt.default !== 'undefined') {
                    self.default(key, opt.default);
                }
                
                if (opt.boolean || opt.type === 'boolean') {
                    self.boolean(key);
                }
                if (opt.string || opt.type === 'string') {
                    self.string(key);
                }
                
                var desc = opt.describe || opt.description || opt.desc;
                if (desc) {
                    self.describe(key, desc);
                }
            }
            
            return self;
        };
        
        var wrap = null;
        self.wrap = function (cols) {
            wrap = cols;
            return self;
        };
        
        self.showHelp = function (fn) {
            if (!fn) fn = console.error;
            fn(self.help());
        };
        
        self.help = function () {
            var keys = Object.keys(
                Object.keys(descriptions)
                .concat(Object.keys(demanded))
                .concat(Object.keys(options.default))
                .reduce(function (acc, key) {
                    if (key !== '_') acc[key] = true;
                    return acc;
                }, {})
            );
            
            var help = keys.length ? [ 'Options:' ] : [];
            
            if (usage) {
                help.unshift(usage.replace(/\$0/g, self.$0), '');
            }
            
            var switches = keys.reduce(function (acc, key) {
                acc[key] = [ key ].concat(options.alias[key] || [])
                    .map(function (sw) {
                        return (sw.length > 1 ? '--' : '-') + sw
                    })
                    .join(', ')
                ;
                return acc;
            }, {});
            
            var switchlen = longest(Object.keys(switches).map(function (s) {
                return switches[s] || '';
            }));
            
            var desclen = longest(Object.keys(descriptions).map(function (d) { 
                return descriptions[d] || '';
            }));
            
            keys.forEach(function (key) {
                var kswitch = switches[key];
                var desc = descriptions[key] || '';
                
                if (wrap) {
                    desc = wordwrap(switchlen + 4, wrap)(desc)
                        .slice(switchlen + 4)
                    ;
                }
                
                var spadding = new Array(
                    Math.max(switchlen - kswitch.length + 3, 0)
                ).join(' ');
                
                var dpadding = new Array(
                    Math.max(desclen - desc.length + 1, 0)
                ).join(' ');
                
                var type = null;
                
                if (options.boolean[key]) type = '[boolean]';
                if (options.string[key]) type = '[string]';
                
                if (!wrap && dpadding.length > 0) {
                    desc += dpadding;
                }
                
                var prelude = '  ' + kswitch + spadding;
                var extra = [
                    type,
                    demanded[key]
                        ? '[required]'
                        : null
                    ,
                    options.default[key] !== undefined
                        ? '[default: ' + JSON.stringify(options.default[key]) + ']'
                        : null
                    ,
                ].filter(Boolean).join('  ');
                
                var body = [ desc, extra ].filter(Boolean).join('  ');
                
                if (wrap) {
                    var dlines = desc.split('\n');
                    var dlen = dlines.slice(-1)[0].length
                        + (dlines.length === 1 ? prelude.length : 0)
                    
                    body = desc + (dlen + extra.length > wrap - 2
                        ? '\n'
                            + new Array(wrap - extra.length + 1).join(' ')
                            + extra
                        : new Array(wrap - extra.length - dlen + 1).join(' ')
                            + extra
                    );
                }
                
                help.push(prelude + body);
            });
            
            help.push('');
            return help.join('\n');
        };
        
        Object.defineProperty(self, 'argv', {
            get : function () { return parseArgs(processArgs) },
            enumerable : true,
        });
        
        function parseArgs (args) {
            var argv = minimist(args, options);
            argv.$0 = self.$0;
            
            if (demanded._ && argv._.length < demanded._) {
                fail('Not enough non-option arguments: got '
                    + argv._.length + ', need at least ' + demanded._
                );
            }
            
            var missing = [];
            Object.keys(demanded).forEach(function (key) {
                if (!argv[key]) missing.push(key);
            });
            
            if (missing.length) {
                fail('Missing required arguments: ' + missing.join(', '));
            }
            
            checks.forEach(function (f) {
                try {
                    if (f(argv) === false) {
                        fail('Argument check failed: ' + f.toString());
                    }
                }
                catch (err) {
                    fail(err)
                }
            });
            
            return argv;
        }
        
        function longest (xs) {
            return Math.max.apply(
                null,
                xs.map(function (x) { return x.length })
            );
        }
        
        return self;
    };
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase;
    function rebase (base, dir) {
        var ds = path.normalize(dir).split('/').slice(1);
        var bs = path.normalize(base).split('/').slice(1);
        
        for (var i = 0; ds[i] && ds[i] == bs[i]; i++);
        ds.splice(0, i); bs.splice(0, i);
        
        var p = path.normalize(
            bs.map(function () { return '..' }).concat(ds).join('/')
        ).replace(/\/$/,'').replace(/^$/, '.');
        return p.match(/^[.\/]/) ? p : './' + p;
    };
    
  provide("optimist", module.exports);
}(global));

// pakmanager:uglify-to-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var fs = require('fs')
    var PassThrough = require('stream').PassThrough
    var Transform = require('stream').Transform
    
    if (typeof Transform === 'undefined') {
      throw new Error('UglifyJS only supports browserify when using node >= 0.10.x')
    }
    
    var cache = {}
    module.exports = transform
    function transform(file) {
      if (!/tools\/node\.js$/.test(file.replace(/\\/g,'/'))) return new PassThrough();
      if (cache[file]) return makeStream(cache[file])
      var uglify = require(file)
      var src = 'var sys = require("util");\nvar MOZ_SourceMap = require("source-map");\nvar UglifyJS = exports;\n' + uglify.FILES.map(function (path) { return fs.readFileSync(path, 'utf8') }).join('\n')
    
      var ast = uglify.parse(src)
      ast.figure_out_scope()
    
      var variables = ast.variables
        .map(function (node, name) {
          return name
        })
    
      src += '\n\n' + variables.map(function (v) { return 'exports.' + v + ' = ' + v + ';' }).join('\n') + '\n\n'
    
      src += 'exports.AST_Node.warn_function = function (txt) { if (typeof console != "undefined" && typeof console.warn === "function") console.warn(txt) }\n\n'
    
      src += 'exports.minify = ' + uglify.minify.toString() + ';\n\n'
      src += 'exports.describe_ast = ' + uglify.describe_ast.toString() + ';'
    
      // TODO: remove once https://github.com/substack/node-browserify/issues/631 is resolved
      src = src.replace(/"for"/g, '"fo" + "r"')
    
      cache[file] = src
      return makeStream(src);
    }
    
    function makeStream(src) {
      var res = new Transform();
      res._transform = function (chunk, encoding, callback) { callback() }
      res._flush = function (callback) {
        res.push(src)
        callback()
      }
      return res;
    }
    
  provide("uglify-to-browserify", module.exports);
}(global));

// pakmanager:delayed-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream').Stream;
    var util = require('util');
    
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
    
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
    
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
    
      delayedStream.source = source;
    
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
    
      source.on('error', function() {});
      if (delayedStream.pauseStream) {
        source.pause();
      }
    
      return delayedStream;
    };
    
    DelayedStream.prototype.__defineGetter__('readable', function() {
      return this.source.readable;
    });
    
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
    
      this.source.resume();
    };
    
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    
    DelayedStream.prototype.release = function() {
      this._released = true;
    
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
    
      if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
    
      this._bufferedEvents.push(args);
    };
    
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
    
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
    
      this._maxDataSizeExceeded = true;
      var message =
        'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
      this.emit('error', new Error(message));
    };
    
  provide("delayed-stream", module.exports);
}(global));

// pakmanager:acorn-globals
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var acorn = require('acorn');
    var walk = require('acorn/util/walk');
    
    function isScope(node) {
      return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'Program';
    }
    function isBlockScope(node) {
      return node.type === 'BlockStatement' || isScope(node);
    }
    
    function declaresArguments(node) {
      return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunction';
    }
    function declaresThis(node) {
      return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';
    }
    
    module.exports = findGlobals;
    function findGlobals(source) {
      var globals = [];
      var ast = typeof source === 'string' ? acorn.parse(source, { ecmaVersion: 6, allowReturnOutsideFunction: true }) : source;
      if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {
        throw new TypeError('Source must be either a string of JavaScript or an acorn AST');
      }
      var declareFunction = function (node) {
        var fn = node;
        fn.locals = fn.locals || {};
        node.params.forEach(function (node) {
          fn.locals[node.name] = true;
        });
        if (node.id) {
          fn.locals[node.id.name] = true;
        }
      }
      walk.ancestor(ast, {
        'VariableDeclaration': function (node, parents) {
          var parent = null;
          for (var i = parents.length - 1; i >= 0 && parent === null; i--) {
            if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {
              parent = parents[i];
            }
          }
          parent.locals = parent.locals || {};
          node.declarations.forEach(function (declaration) {
            parent.locals[declaration.id.name] = true;
          });
        },
        'FunctionDeclaration': function (node, parents) {
          var parent = null;
          for (var i = parents.length - 2; i >= 0 && parent === null; i--) {
            if (isScope(parents[i])) {
              parent = parents[i];
            }
          }
          parent.locals = parent.locals || {};
          parent.locals[node.id.name] = true;
          declareFunction(node);
        },
        'Function': declareFunction,
        'TryStatement': function (node) {
          node.handler.body.locals = node.handler.body.locals || {};
          node.handler.body.locals[node.handler.param.name] = true;
        }
      });
      walk.ancestor(ast, {
        'Identifier': function (node, parents) {
          var name = node.name;
          if (name === 'undefined') return;
          for (var i = 0; i < parents.length; i++) {
            if (name === 'arguments' && declaresArguments(parents[i])) {
              return;
            }
            if (parents[i].locals && name in parents[i].locals) {
              return;
            }
          }
          node.parents = parents;
          globals.push(node);
        },
        ThisExpression: function (node, parents) {
          for (var i = 0; i < parents.length; i++) {
            if (declaresThis(parents[i])) {
              return;
            }
          }
          node.parents = parents;
          globals.push(node);
        }
      });
      var groupedGlobals = {};
      globals.forEach(function (node) {
        groupedGlobals[node.name] = (groupedGlobals[node.name] || []);
        groupedGlobals[node.name].push(node);
      });
      return Object.keys(groupedGlobals).sort().map(function (name) {
        return {name: name, nodes: groupedGlobals[name]};
      });
    }
    
  provide("acorn-globals", module.exports);
}(global));

// pakmanager:readdirp/stream-api
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var si = typeof setImmediate !== 'undefined' ? setImmediate : function (fn) { setTimeout(fn, 0) };
    
    var stream = require('readable-stream');
    var util = require('util');
    
    var Readable = stream.Readable;
    
    module.exports = ReaddirpReadable;
    
    util.inherits(ReaddirpReadable, Readable);
    
    function ReaddirpReadable (opts) {
      if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);
    
      opts = opts || {};
      
      opts.objectMode = true;
      Readable.call(this, opts);
    
      // backpressure not implemented at this point
      this.highWaterMark = Infinity;
    
      this._destroyed = false;
      this._paused = false;
      this._warnings = [];
      this._errors = [];
    
      this._pauseResumeErrors();
    }
    
    var proto = ReaddirpReadable.prototype;
    
    proto._pauseResumeErrors = function () {
      var self = this;
      self.on('pause', function () { self._paused = true });
      self.on('resume', function () {
        if (self._destroyed) return;
        self._paused = false;
    
        self._warnings.forEach(function (err) { self.emit('warn', err) });
        self._warnings.length = 0;
    
        self._errors.forEach(function (err) { self.emit('error', err) });
        self._errors.length = 0;
      })
    }
    
    // called for each entry
    proto._processEntry = function (entry) {
      if (this._destroyed) return;
      this.push(entry);
    }
    
    proto._read = function () { }
    
    proto.destroy = function () {
      // when stream is destroyed it will emit nothing further, not even errors or warnings
      this.push(null);
      this.readable = false;
      this._destroyed = true;
      this.emit('close');
    }
    
    proto._done = function () {
      this.push(null);
    }
    
    // we emit errors and warnings async since we may handle errors like invalid args
    // within the initial event loop before any event listeners subscribed
    proto._handleError = function (err) {
      var self = this;
      si(function () { 
        if (self._paused) return self._warnings.push(err);
        if (!self._destroyed) self.emit('warn', err);
      });
    }
    
    proto._handleFatalError = function (err) {
      var self = this;
      si(function () { 
        if (self._paused) return self._errors.push(err);
        if (!self._destroyed) self.emit('error', err);
      });
    }
    
    function createStreamAPI () {
      var stream = new ReaddirpReadable();
    
      return { 
          stream           :  stream
        , processEntry     :  stream._processEntry.bind(stream)
        , done             :  stream._done.bind(stream)
        , handleError      :  stream._handleError.bind(stream)
        , handleFatalError :  stream._handleFatalError.bind(stream)
      };
    }
    
    module.exports = createStreamAPI;
    
  provide("readdirp/stream-api", module.exports);
}(global));

// pakmanager:readdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs        =  require('graceful-fs')
      , path      =  require('path')
      , minimatch =  require('minimatch')
      , toString  =  Object.prototype.toString
      ;
    
    // Standard helpers
    function isFunction (obj) {
      return toString.call(obj) === '[object Function]';
    }
    
    function isString (obj) {
      return toString.call(obj) === '[object String]';
    }
    
    function isRegExp (obj) {
      return toString.call(obj) === '[object RegExp]';
    }
    
    function isUndefined (obj) {
      return obj === void 0;
    }
    
    /** 
     * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
     * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
     * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
     *                                when callback2 is not given, it behaves like explained in callback2
     * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
     *                                function (err, fileInfos) { ... }
     */
    function readdir(opts, callback1, callback2) {
      var stream
        , handleError
        , handleFatalError
        , pending = 0
        , errors = []
        , readdirResult = {
            directories: []
          , files: []
        }
        , fileProcessed
        , allProcessed
        , realRoot
        , aborted = false
        ;
    
      // If no callbacks were given we will use a streaming interface
      if (isUndefined(callback1)) {
        var api          =   require('readdirp/stream-api')();
        stream           =  api.stream;
        callback1        =  api.processEntry;
        callback2        =  api.done;
        handleError      =  api.handleError;
        handleFatalError =  api.handleFatalError;
    
        stream.on('close', function () { aborted = true; });
      } else {
        handleError      =  function (err) { errors.push(err); };
        handleFatalError =  function (err) {
          handleError(err);
          allProcessed(errors, null);
        };
      }
    
      if (isUndefined(opts)){
        handleFatalError(new Error (
          'Need to pass at least one argument: opts! \n' +
          'https://github.com/thlorenz/readdirp#options'
          )
        );
        return stream;
      }
    
      opts.root            =  opts.root            || '.';
      opts.fileFilter      =  opts.fileFilter      || function() { return true; };
      opts.directoryFilter =  opts.directoryFilter || function() { return true; };
      opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
      opts.entryType       =  opts.entryType       || 'files';
    
      var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);
    
      if (isUndefined(callback2)) {
        fileProcessed = function() { };
        allProcessed = callback1;
      } else {
        fileProcessed = callback1;
        allProcessed = callback2;
      }
    
      function normalizeFilter (filter) {
    
        if (isUndefined(filter)) return undefined;
    
        function isNegated (filters) {
    
          function negated(f) { 
            return f.indexOf('!') === 0; 
          }
    
          var some = filters.some(negated);
          if (!some) {
            return false;
          } else {
            if (filters.every(negated)) {
              return true;
            } else {
              // if we detect illegal filters, bail out immediately
              throw new Error(
                'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
                'https://github.com/thlorenz/readdirp#filters'
              );
            }
          }
        }
    
        // Turn all filters into a function
        if (isFunction(filter)) {
    
          return filter;
    
        } else if (isString(filter)) {
    
          return function (entryInfo) {
            return minimatch(entryInfo.name, filter.trim());
          };
    
        } else if (filter && Array.isArray(filter)) {
    
          if (filter) filter = filter.map(function (f) {
            return f.trim();
          });
    
          return isNegated(filter) ?
            // use AND to concat multiple negated filters
            function (entryInfo) {
              return filter.every(function (f) {
                return minimatch(entryInfo.name, f);
              });
            }
            :
            // use OR to concat multiple inclusive filters
            function (entryInfo) {
              return filter.some(function (f) {
                return minimatch(entryInfo.name, f);
              });
            };
        }
      }
    
      function processDir(currentDir, entries, callProcessed) {
        if (aborted) return;
        var total = entries.length
          , processed = 0
          , entryInfos = []
          ;
    
        fs.realpath(currentDir, function(err, realCurrentDir) {
          if (aborted) return;
          if (err) {
            handleError(err);
            callProcessed(entryInfos);
            return;
          }
    
          var relDir = path.relative(realRoot, realCurrentDir);
    
          if (entries.length === 0) {
            callProcessed([]);
          } else {
            entries.forEach(function (entry) { 
    
              var fullPath = path.join(realCurrentDir, entry)
                , relPath  = path.join(relDir, entry);
    
              statfn(fullPath, function (err, stat) {
                if (err) {
                  handleError(err);
                } else {
                  entryInfos.push({
                      name          :  entry
                    , path          :  relPath   // relative to root
                    , fullPath      :  fullPath
    
                    , parentDir     :  relDir    // relative to root
                    , fullParentDir :  realCurrentDir
    
                    , stat          :  stat
                  });
                }
                processed++;
                if (processed === total) callProcessed(entryInfos);
              });
            });
          }
        });
      }
    
      function readdirRec(currentDir, depth, callCurrentDirProcessed) {
        if (aborted) return;
    
        fs.readdir(currentDir, function (err, entries) {
          if (err) {
            handleError(err);
            callCurrentDirProcessed();
            return;
          }
    
          processDir(currentDir, entries, function(entryInfos) {
    
            var subdirs = entryInfos
              .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });
    
            subdirs.forEach(function (di) { 
              if(opts.entryType === 'directories' || opts.entryType === 'both') {
                fileProcessed(di);
              }
              readdirResult.directories.push(di); 
            });
    
            entryInfos
              .filter(function(ei) { return ei.stat.isFile() && opts.fileFilter(ei); })
              .forEach(function (fi) { 
                if(opts.entryType === 'files' || opts.entryType === 'both'){
                  fileProcessed(fi);
                }
                readdirResult.files.push(fi); 
              });
    
            var pendingSubdirs = subdirs.length;
    
            // Be done if no more subfolders exist or we reached the maximum desired depth
            if(pendingSubdirs === 0 || depth === opts.depth) {
              callCurrentDirProcessed();
            } else {
              // recurse into subdirs, keeping track of which ones are done 
              // and call back once all are processed
              subdirs.forEach(function (subdir) {
                readdirRec(subdir.fullPath, depth + 1, function () {
                  pendingSubdirs = pendingSubdirs - 1;
                  if(pendingSubdirs === 0) { 
                    callCurrentDirProcessed();
                  }
                });
              });
            }
          });
        });
      }
    
      // Validate and normalize filters
      try {
        opts.fileFilter = normalizeFilter(opts.fileFilter);
        opts.directoryFilter = normalizeFilter(opts.directoryFilter);
      } catch (err) {
        // if we detect illegal filters, bail out immediately
        handleFatalError(err);
        return stream;
      }
    
      // If filters were valid get on with the show
      fs.realpath(opts.root, function(err, res) {
        if (err) {
          handleFatalError(err);
          return stream;
        }
    
        realRoot = res;
        readdirRec(opts.root, 0, function () { 
          // All errors are collected into the errors array
          if (errors.length > 0) {
            allProcessed(errors, readdirResult); 
          } else {
            allProcessed(null, readdirResult);
          }
        });
      });
    
      return stream;
    }
    
    module.exports = readdir;
    
  provide("readdirp", module.exports);
}(global));

// pakmanager:promise/lib/core.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var asap = require('asap')
    
    module.exports = Promise;
    function Promise(fn) {
      if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
      if (typeof fn !== 'function') throw new TypeError('not a function')
      var state = null
      var value = null
      var deferreds = []
      var self = this
    
      this.then = function(onFulfilled, onRejected) {
        return new self.constructor(function(resolve, reject) {
          handle(new Handler(onFulfilled, onRejected, resolve, reject))
        })
      }
    
      function handle(deferred) {
        if (state === null) {
          deferreds.push(deferred)
          return
        }
        asap(function() {
          var cb = state ? deferred.onFulfilled : deferred.onRejected
          if (cb === null) {
            (state ? deferred.resolve : deferred.reject)(value)
            return
          }
          var ret
          try {
            ret = cb(value)
          }
          catch (e) {
            deferred.reject(e)
            return
          }
          deferred.resolve(ret)
        })
      }
    
      function resolve(newValue) {
        try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
          if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
          if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
            var then = newValue.then
            if (typeof then === 'function') {
              doResolve(then.bind(newValue), resolve, reject)
              return
            }
          }
          state = true
          value = newValue
          finale()
        } catch (e) { reject(e) }
      }
    
      function reject(newValue) {
        state = false
        value = newValue
        finale()
      }
    
      function finale() {
        for (var i = 0, len = deferreds.length; i < len; i++)
          handle(deferreds[i])
        deferreds = null
      }
    
      doResolve(fn, resolve, reject)
    }
    
    
    function Handler(onFulfilled, onRejected, resolve, reject){
      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
      this.onRejected = typeof onRejected === 'function' ? onRejected : null
      this.resolve = resolve
      this.reject = reject
    }
    
    /**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */
    function doResolve(fn, onFulfilled, onRejected) {
      var done = false;
      try {
        fn(function (value) {
          if (done) return
          done = true
          onFulfilled(value)
        }, function (reason) {
          if (done) return
          done = true
          onRejected(reason)
        })
      } catch (ex) {
        if (done) return
        done = true
        onRejected(ex)
      }
    }
    
  provide("promise/lib/core.js", module.exports);
}(global));

// pakmanager:promise/lib/done.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Promise =  require('promise/lib/core.js')
    var asap = require('asap')
    
    module.exports = Promise
    Promise.prototype.done = function (onFulfilled, onRejected) {
      var self = arguments.length ? this.then.apply(this, arguments) : this
      self.then(null, function (err) {
        asap(function () {
          throw err
        })
      })
    }
  provide("promise/lib/done.js", module.exports);
}(global));

// pakmanager:promise/lib/es6-extensions.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    //This file contains the ES6 extensions to the core Promises/A+ API
    
    var Promise =  require('promise/lib/core.js')
    var asap = require('asap')
    
    module.exports = Promise
    
    /* Static Functions */
    
    function ValuePromise(value) {
      this.then = function (onFulfilled) {
        if (typeof onFulfilled !== 'function') return this
        return new Promise(function (resolve, reject) {
          asap(function () {
            try {
              resolve(onFulfilled(value))
            } catch (ex) {
              reject(ex);
            }
          })
        })
      }
    }
    ValuePromise.prototype = Promise.prototype
    
    var TRUE = new ValuePromise(true)
    var FALSE = new ValuePromise(false)
    var NULL = new ValuePromise(null)
    var UNDEFINED = new ValuePromise(undefined)
    var ZERO = new ValuePromise(0)
    var EMPTYSTRING = new ValuePromise('')
    
    Promise.resolve = function (value) {
      if (value instanceof Promise) return value
    
      if (value === null) return NULL
      if (value === undefined) return UNDEFINED
      if (value === true) return TRUE
      if (value === false) return FALSE
      if (value === 0) return ZERO
      if (value === '') return EMPTYSTRING
    
      if (typeof value === 'object' || typeof value === 'function') {
        try {
          var then = value.then
          if (typeof then === 'function') {
            return new Promise(then.bind(value))
          }
        } catch (ex) {
          return new Promise(function (resolve, reject) {
            reject(ex)
          })
        }
      }
    
      return new ValuePromise(value)
    }
    
    Promise.all = function (arr) {
      var args = Array.prototype.slice.call(arr)
    
      return new Promise(function (resolve, reject) {
        if (args.length === 0) return resolve([])
        var remaining = args.length
        function res(i, val) {
          try {
            if (val && (typeof val === 'object' || typeof val === 'function')) {
              var then = val.then
              if (typeof then === 'function') {
                then.call(val, function (val) { res(i, val) }, reject)
                return
              }
            }
            args[i] = val
            if (--remaining === 0) {
              resolve(args);
            }
          } catch (ex) {
            reject(ex)
          }
        }
        for (var i = 0; i < args.length; i++) {
          res(i, args[i])
        }
      })
    }
    
    Promise.reject = function (value) {
      return new Promise(function (resolve, reject) { 
        reject(value);
      });
    }
    
    Promise.race = function (values) {
      return new Promise(function (resolve, reject) { 
        values.forEach(function(value){
          Promise.resolve(value).then(resolve, reject);
        })
      });
    }
    
    /* Prototype Methods */
    
    Promise.prototype['catch'] = function (onRejected) {
      return this.then(null, onRejected);
    }
    
  provide("promise/lib/es6-extensions.js", module.exports);
}(global));

// pakmanager:promise/lib/node-extensions.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    //This file contains then/promise specific extensions that are only useful for node.js interop
    
    var Promise =  require('promise/lib/core.js')
    var asap = require('asap')
    
    module.exports = Promise
    
    /* Static Functions */
    
    Promise.denodeify = function (fn, argumentCount) {
      argumentCount = argumentCount || Infinity
      return function () {
        var self = this
        var args = Array.prototype.slice.call(arguments)
        return new Promise(function (resolve, reject) {
          while (args.length && args.length > argumentCount) {
            args.pop()
          }
          args.push(function (err, res) {
            if (err) reject(err)
            else resolve(res)
          })
          fn.apply(self, args)
        })
      }
    }
    Promise.nodeify = function (fn) {
      return function () {
        var args = Array.prototype.slice.call(arguments)
        var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
        var ctx = this
        try {
          return fn.apply(this, arguments).nodeify(callback, ctx)
        } catch (ex) {
          if (callback === null || typeof callback == 'undefined') {
            return new Promise(function (resolve, reject) { reject(ex) })
          } else {
            asap(function () {
              callback.call(ctx, ex)
            })
          }
        }
      }
    }
    
    Promise.prototype.nodeify = function (callback, ctx) {
      if (typeof callback != 'function') return this
    
      this.then(function (value) {
        asap(function () {
          callback.call(ctx, null, value)
        })
      }, function (err) {
        asap(function () {
          callback.call(ctx, err)
        })
      })
    }
    
  provide("promise/lib/node-extensions.js", module.exports);
}(global));

// pakmanager:promise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports =  require('promise/lib/core.js')
     require('promise/lib/done.js')
     require('promise/lib/es6-extensions.js')
     require('promise/lib/node-extensions.js')
  provide("promise", module.exports);
}(global));

// pakmanager:css/lib/stringify/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Compiler`.
     */
    
    module.exports = Compiler;
    
    /**
     * Initialize a compiler.
     *
     * @param {Type} name
     * @return {Type}
     * @api public
     */
    
    function Compiler(opts) {
      this.options = opts || {};
    }
    
    /**
     * Emit `str`
     */
    
    Compiler.prototype.emit = function(str) {
      return str;
    };
    
    /**
     * Visit `node`.
     */
    
    Compiler.prototype.visit = function(node){
      return this[node.type](node);
    };
    
    /**
     * Map visit over array of `nodes`, optionally using a `delim`
     */
    
    Compiler.prototype.mapVisit = function(nodes, delim){
      var buf = '';
      delim = delim || '';
    
      for (var i = 0, length = nodes.length; i < length; i++) {
        buf += this.visit(nodes[i]);
        if (delim && i < length - 1) buf += this.emit(delim);
      }
    
      return buf;
    };
    
  provide("css/lib/stringify/compiler", module.exports);
}(global));

// pakmanager:css/lib/stringify/compress
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('css/lib/stringify/compiler');
    var inherits = require('inherits');
    
    /**
     * Expose compiler.
     */
    
    module.exports = Compiler;
    
    /**
     * Initialize a new `Compiler`.
     */
    
    function Compiler(options) {
      Base.call(this, options);
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    inherits(Compiler, Base);
    
    /**
     * Compile `node`.
     */
    
    Compiler.prototype.compile = function(node){
      return node.stylesheet
        .rules.map(this.visit, this)
        .join('');
    };
    
    /**
     * Visit comment node.
     */
    
    Compiler.prototype.comment = function(node){
      return this.emit('', node.position);
    };
    
    /**
     * Visit import node.
     */
    
    Compiler.prototype.import = function(node){
      return this.emit('@import ' + node.import + ';', node.position);
    };
    
    /**
     * Visit media node.
     */
    
    Compiler.prototype.media = function(node){
      return this.emit('@media ' + node.media, node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit document node.
     */
    
    Compiler.prototype.document = function(node){
      var doc = '@' + (node.vendor || '') + 'document ' + node.document;
    
      return this.emit(doc, node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit charset node.
     */
    
    Compiler.prototype.charset = function(node){
      return this.emit('@charset ' + node.charset + ';', node.position);
    };
    
    /**
     * Visit namespace node.
     */
    
    Compiler.prototype.namespace = function(node){
      return this.emit('@namespace ' + node.namespace + ';', node.position);
    };
    
    /**
     * Visit supports node.
     */
    
    Compiler.prototype.supports = function(node){
      return this.emit('@supports ' + node.supports, node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit keyframes node.
     */
    
    Compiler.prototype.keyframes = function(node){
      return this.emit('@'
        + (node.vendor || '')
        + 'keyframes '
        + node.name, node.position)
        + this.emit('{')
        + this.mapVisit(node.keyframes)
        + this.emit('}');
    };
    
    /**
     * Visit keyframe node.
     */
    
    Compiler.prototype.keyframe = function(node){
      var decls = node.declarations;
    
      return this.emit(node.values.join(','), node.position)
        + this.emit('{')
        + this.mapVisit(decls)
        + this.emit('}');
    };
    
    /**
     * Visit page node.
     */
    
    Compiler.prototype.page = function(node){
      var sel = node.selectors.length
        ? node.selectors.join(', ')
        : '';
    
      return this.emit('@page ' + sel, node.position)
        + this.emit('{')
        + this.mapVisit(node.declarations)
        + this.emit('}');
    };
    
    /**
     * Visit font-face node.
     */
    
    Compiler.prototype['font-face'] = function(node){
      return this.emit('@font-face', node.position)
        + this.emit('{')
        + this.mapVisit(node.declarations)
        + this.emit('}');
    };
    
    /**
     * Visit host node.
     */
    
    Compiler.prototype.host = function(node){
      return this.emit('@host', node.position)
        + this.emit('{')
        + this.mapVisit(node.rules)
        + this.emit('}');
    };
    
    /**
     * Visit custom-media node.
     */
    
    Compiler.prototype['custom-media'] = function(node){
      return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
    };
    
    /**
     * Visit rule node.
     */
    
    Compiler.prototype.rule = function(node){
      var decls = node.declarations;
      if (!decls.length) return '';
    
      return this.emit(node.selectors.join(','), node.position)
        + this.emit('{')
        + this.mapVisit(decls)
        + this.emit('}');
    };
    
    /**
     * Visit declaration node.
     */
    
    Compiler.prototype.declaration = function(node){
      return this.emit(node.property + ':' + node.value, node.position) + this.emit(';');
    };
    
    
  provide("css/lib/stringify/compress", module.exports);
}(global));

// pakmanager:css/lib/stringify/identity
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('css/lib/stringify/compiler');
    var inherits = require('inherits');
    
    /**
     * Expose compiler.
     */
    
    module.exports = Compiler;
    
    /**
     * Initialize a new `Compiler`.
     */
    
    function Compiler(options) {
      options = options || {};
      Base.call(this, options);
      this.indentation = options.indent;
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    inherits(Compiler, Base);
    
    /**
     * Compile `node`.
     */
    
    Compiler.prototype.compile = function(node){
      return this.stylesheet(node);
    };
    
    /**
     * Visit stylesheet node.
     */
    
    Compiler.prototype.stylesheet = function(node){
      return this.mapVisit(node.stylesheet.rules, '\n\n');
    };
    
    /**
     * Visit comment node.
     */
    
    Compiler.prototype.comment = function(node){
      return this.emit(this.indent() + '/*' + node.comment + '*/', node.position);
    };
    
    /**
     * Visit import node.
     */
    
    Compiler.prototype.import = function(node){
      return this.emit('@import ' + node.import + ';', node.position);
    };
    
    /**
     * Visit media node.
     */
    
    Compiler.prototype.media = function(node){
      return this.emit('@media ' + node.media, node.position)
        + this.emit(
            ' {\n'
            + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit document node.
     */
    
    Compiler.prototype.document = function(node){
      var doc = '@' + (node.vendor || '') + 'document ' + node.document;
    
      return this.emit(doc, node.position)
        + this.emit(
            ' '
          + ' {\n'
          + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit charset node.
     */
    
    Compiler.prototype.charset = function(node){
      return this.emit('@charset ' + node.charset + ';', node.position);
    };
    
    /**
     * Visit namespace node.
     */
    
    Compiler.prototype.namespace = function(node){
      return this.emit('@namespace ' + node.namespace + ';', node.position);
    };
    
    /**
     * Visit supports node.
     */
    
    Compiler.prototype.supports = function(node){
      return this.emit('@supports ' + node.supports, node.position)
        + this.emit(
          ' {\n'
          + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit keyframes node.
     */
    
    Compiler.prototype.keyframes = function(node){
      return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position)
        + this.emit(
          ' {\n'
          + this.indent(1))
        + this.mapVisit(node.keyframes, '\n')
        + this.emit(
            this.indent(-1)
            + '}');
    };
    
    /**
     * Visit keyframe node.
     */
    
    Compiler.prototype.keyframe = function(node){
      var decls = node.declarations;
    
      return this.emit(this.indent())
        + this.emit(node.values.join(', '), node.position)
        + this.emit(
          ' {\n'
          + this.indent(1))
        + this.mapVisit(decls, '\n')
        + this.emit(
          this.indent(-1)
          + '\n'
          + this.indent() + '}\n');
    };
    
    /**
     * Visit page node.
     */
    
    Compiler.prototype.page = function(node){
      var sel = node.selectors.length
        ? node.selectors.join(', ') + ' '
        : '';
    
      return this.emit('@page ' + sel, node.position)
        + this.emit('{\n')
        + this.emit(this.indent(1))
        + this.mapVisit(node.declarations, '\n')
        + this.emit(this.indent(-1))
        + this.emit('\n}');
    };
    
    /**
     * Visit font-face node.
     */
    
    Compiler.prototype['font-face'] = function(node){
      return this.emit('@font-face ', node.position)
        + this.emit('{\n')
        + this.emit(this.indent(1))
        + this.mapVisit(node.declarations, '\n')
        + this.emit(this.indent(-1))
        + this.emit('\n}');
    };
    
    /**
     * Visit host node.
     */
    
    Compiler.prototype.host = function(node){
      return this.emit('@host', node.position)
        + this.emit(
            ' {\n'
            + this.indent(1))
        + this.mapVisit(node.rules, '\n\n')
        + this.emit(
            this.indent(-1)
            + '\n}');
    };
    
    /**
     * Visit custom-media node.
     */
    
    Compiler.prototype['custom-media'] = function(node){
      return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
    };
    
    /**
     * Visit rule node.
     */
    
    Compiler.prototype.rule = function(node){
      var indent = this.indent();
      var decls = node.declarations;
      if (!decls.length) return '';
    
      return this.emit(node.selectors.map(function(s){ return indent + s }).join(',\n'), node.position)
        + this.emit(' {\n')
        + this.emit(this.indent(1))
        + this.mapVisit(decls, '\n')
        + this.emit(this.indent(-1))
        + this.emit('\n' + this.indent() + '}');
    };
    
    /**
     * Visit declaration node.
     */
    
    Compiler.prototype.declaration = function(node){
      return this.emit(this.indent())
        + this.emit(node.property + ': ' + node.value, node.position)
        + this.emit(';');
    };
    
    /**
     * Increase, decrease or return current indentation.
     */
    
    Compiler.prototype.indent = function(level) {
      this.level = this.level || 1;
    
      if (null != level) {
        this.level += level;
        return '';
      }
    
      return Array(this.level).join(this.indentation || '  ');
    };
    
  provide("css/lib/stringify/identity", module.exports);
}(global));

// pakmanager:css/lib/stringify/source-map-support
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var SourceMap = require('source-map').SourceMapGenerator;
    var SourceMapConsumer = require('source-map').SourceMapConsumer;
    var sourceMapResolve = require('source-map-resolve');
    var urix = require('urix');
    var fs = require('fs');
    var path = require('path');
    
    /**
     * Expose `mixin()`.
     */
    
    module.exports = mixin;
    
    /**
     * Mixin source map support into `compiler`.
     *
     * @param {Compiler} compiler
     * @api public
     */
    
    function mixin(compiler) {
      compiler._comment = compiler.comment;
      compiler.map = new SourceMap();
      compiler.position = { line: 1, column: 1 };
      compiler.files = {};
      for (var k in exports) compiler[k] = exports[k];
    }
    
    /**
     * Update position.
     *
     * @param {String} str
     * @api private
     */
    
    exports.updatePosition = function(str) {
      var lines = str.match(/\n/g);
      if (lines) this.position.line += lines.length;
      var i = str.lastIndexOf('\n');
      this.position.column = ~i ? str.length - i : this.position.column + str.length;
    };
    
    /**
     * Emit `str`.
     *
     * @param {String} str
     * @param {Object} [pos]
     * @return {String}
     * @api private
     */
    
    exports.emit = function(str, pos) {
      if (pos) {
        var sourceFile = urix(pos.source || 'source.css');
    
        this.map.addMapping({
          source: sourceFile,
          generated: {
            line: this.position.line,
            column: Math.max(this.position.column - 1, 0)
          },
          original: {
            line: pos.start.line,
            column: pos.start.column - 1
          }
        });
    
        this.addFile(sourceFile, pos);
      }
    
      this.updatePosition(str);
    
      return str;
    };
    
    /**
     * Adds a file to the source map output if it has not already been added
     * @param {String} file
     * @param {Object} pos
     */
    
    exports.addFile = function(file, pos) {
      if (typeof pos.content !== 'string') return;
      if (Object.prototype.hasOwnProperty.call(this.files, file)) return;
    
      this.files[file] = pos.content;
    };
    
    /**
     * Applies any original source maps to the output and embeds the source file
     * contents in the source map.
     */
    
    exports.applySourceMaps = function() {
      Object.keys(this.files).forEach(function(file) {
        var content = this.files[file];
        this.map.setSourceContent(file, content);
    
        if (this.options.inputSourcemaps !== false) {
          var originalMap = sourceMapResolve.resolveSync(
            content, file, fs.readFileSync);
          if (originalMap) {
            var map = new SourceMapConsumer(originalMap.map);
            var relativeTo = originalMap.sourcesRelativeTo;
            this.map.applySourceMap(map, file, urix(path.dirname(relativeTo)));
          }
        }
      }, this);
    };
    
    /**
     * Process comments, drops sourceMap comments.
     * @param {Object} node
     */
    
    exports.comment = function(node) {
      if (/^# sourceMappingURL=/.test(node.comment))
        return this.emit('', node.position);
      else
        return this._comment(node);
    };
    
  provide("css/lib/stringify/source-map-support", module.exports);
}(global));

// pakmanager:css/lib/parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // http://www.w3.org/TR/CSS21/grammar.html
    // https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
    var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
    
    module.exports = function(css, options){
      options = options || {};
    
      /**
       * Positional.
       */
    
      var lineno = 1;
      var column = 1;
    
      /**
       * Update lineno and column based on `str`.
       */
    
      function updatePosition(str) {
        var lines = str.match(/\n/g);
        if (lines) lineno += lines.length;
        var i = str.lastIndexOf('\n');
        column = ~i ? str.length - i : column + str.length;
      }
    
      /**
       * Mark position and patch `node.position`.
       */
    
      function position() {
        var start = { line: lineno, column: column };
        return function(node){
          node.position = new Position(start);
          whitespace();
          return node;
        };
      }
    
      /**
       * Store position information for a node
       */
    
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column: column };
        this.source = options.source;
      }
    
      /**
       * Non-enumerable source string
       */
    
      Position.prototype.content = css;
    
      /**
       * Error `msg`.
       */
    
      function error(msg) {
        if (options.silent === true) {
          return false;
        }
    
        var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = css;
        throw err;
      }
    
      /**
       * Parse stylesheet.
       */
    
      function stylesheet() {
        return {
          type: 'stylesheet',
          stylesheet: {
            rules: rules()
          }
        };
      }
    
      /**
       * Opening brace.
       */
    
      function open() {
        return match(/^{\s*/);
      }
    
      /**
       * Closing brace.
       */
    
      function close() {
        return match(/^}/);
      }
    
      /**
       * Parse ruleset.
       */
    
      function rules() {
        var node;
        var rules = [];
        whitespace();
        comments(rules);
        while (css.length && css.charAt(0) != '}' && (node = atrule() || rule())) {
          if (node !== false) {
            rules.push(node);
            comments(rules);
          }
        }
        return rules;
      }
    
      /**
       * Match `re` and return captures.
       */
    
      function match(re) {
        var m = re.exec(css);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        css = css.slice(str.length);
        return m;
      }
    
      /**
       * Parse whitespace.
       */
    
      function whitespace() {
        match(/^\s*/);
      }
    
      /**
       * Parse comments;
       */
    
      function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }
    
      /**
       * Parse comment.
       */
    
      function comment() {
        var pos = position();
        if ('/' != css.charAt(0) || '*' != css.charAt(1)) return;
    
        var i = 2;
        while ("" != css.charAt(i) && ('*' != css.charAt(i) || '/' != css.charAt(i + 1))) ++i;
        i += 2;
    
        if ("" === css.charAt(i-1)) {
          return error('End of comment missing');
        }
    
        var str = css.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        css = css.slice(i);
        column += 2;
    
        return pos({
          type: 'comment',
          comment: str
        });
      }
    
      /**
       * Parse selector.
       */
    
      function selector() {
        var m = match(/^([^{]+)/);
        if (!m) return;
        /* @fix Remove all comments from selectors
         * http://ostermiller.org/findcomment.html */
        return trim(m[0])
          .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
          .replace(/(?:"[^"]*"|'[^']*')/g, function(m) {
            return m.replace(/,/g, '\u200C');
          })
          .split(/\s*(?![^(]*\)),\s*/)
          .map(function(s) {
            return s.replace(/\u200C/g, ',');
          });
      }
    
      /**
       * Parse declaration.
       */
    
      function declaration() {
        var pos = position();
    
        // prop
        var prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
        if (!prop) return;
        prop = trim(prop[0]);
    
        // :
        if (!match(/^:\s*/)) return error("property missing ':'");
    
        // val
        var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    
        var ret = pos({
          type: 'declaration',
          property: prop.replace(commentre, ''),
          value: val ? trim(val[0]).replace(commentre, '') : ''
        });
    
        // ;
        match(/^[;\s]*/);
    
        return ret;
      }
    
      /**
       * Parse declarations.
       */
    
      function declarations() {
        var decls = [];
    
        if (!open()) return error("missing '{'");
        comments(decls);
    
        // declarations
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
    
        if (!close()) return error("missing '}'");
        return decls;
      }
    
      /**
       * Parse keyframe.
       */
    
      function keyframe() {
        var m;
        var vals = [];
        var pos = position();
    
        while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
          vals.push(m[1]);
          match(/^,\s*/);
        }
    
        if (!vals.length) return;
    
        return pos({
          type: 'keyframe',
          values: vals,
          declarations: declarations()
        });
      }
    
      /**
       * Parse keyframes.
       */
    
      function atkeyframes() {
        var pos = position();
        var m = match(/^@([-\w]+)?keyframes */);
    
        if (!m) return;
        var vendor = m[1];
    
        // identifier
        var m = match(/^([-\w]+)\s*/);
        if (!m) return error("@keyframes missing name");
        var name = m[1];
    
        if (!open()) return error("@keyframes missing '{'");
    
        var frame;
        var frames = comments();
        while (frame = keyframe()) {
          frames.push(frame);
          frames = frames.concat(comments());
        }
    
        if (!close()) return error("@keyframes missing '}'");
    
        return pos({
          type: 'keyframes',
          name: name,
          vendor: vendor,
          keyframes: frames
        });
      }
    
      /**
       * Parse supports.
       */
    
      function atsupports() {
        var pos = position();
        var m = match(/^@supports *([^{]+)/);
    
        if (!m) return;
        var supports = trim(m[1]);
    
        if (!open()) return error("@supports missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@supports missing '}'");
    
        return pos({
          type: 'supports',
          supports: supports,
          rules: style
        });
      }
    
      /**
       * Parse host.
       */
    
      function athost() {
        var pos = position();
        var m = match(/^@host */);
    
        if (!m) return;
    
        if (!open()) return error("@host missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@host missing '}'");
    
        return pos({
          type: 'host',
          rules: style
        });
      }
    
      /**
       * Parse media.
       */
    
      function atmedia() {
        var pos = position();
        var m = match(/^@media *([^{]+)/);
    
        if (!m) return;
        var media = trim(m[1]);
    
        if (!open()) return error("@media missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@media missing '}'");
    
        return pos({
          type: 'media',
          media: media,
          rules: style
        });
      }
    
    
      /**
       * Parse custom-media.
       */
    
      function atcustommedia() {
        var pos = position();
        var m = match(/^@custom-media (--[^\s]+) *([^{;]+);/);
        if (!m) return;
    
        return pos({
          type: 'custom-media',
          name: trim(m[1]),
          media: trim(m[2])
        });
      }
    
      /**
       * Parse paged media.
       */
    
      function atpage() {
        var pos = position();
        var m = match(/^@page */);
        if (!m) return;
    
        var sel = selector() || [];
    
        if (!open()) return error("@page missing '{'");
        var decls = comments();
    
        // declarations
        var decl;
        while (decl = declaration()) {
          decls.push(decl);
          decls = decls.concat(comments());
        }
    
        if (!close()) return error("@page missing '}'");
    
        return pos({
          type: 'page',
          selectors: sel,
          declarations: decls
        });
      }
    
      /**
       * Parse document.
       */
    
      function atdocument() {
        var pos = position();
        var m = match(/^@([-\w]+)?document *([^{]+)/);
        if (!m) return;
    
        var vendor = trim(m[1]);
        var doc = trim(m[2]);
    
        if (!open()) return error("@document missing '{'");
    
        var style = comments().concat(rules());
    
        if (!close()) return error("@document missing '}'");
    
        return pos({
          type: 'document',
          document: doc,
          vendor: vendor,
          rules: style
        });
      }
    
      /**
       * Parse font-face.
       */
    
      function atfontface() {
        var pos = position();
        var m = match(/^@font-face */);
        if (!m) return;
    
        if (!open()) return error("@font-face missing '{'");
        var decls = comments();
    
        // declarations
        var decl;
        while (decl = declaration()) {
          decls.push(decl);
          decls = decls.concat(comments());
        }
    
        if (!close()) return error("@font-face missing '}'");
    
        return pos({
          type: 'font-face',
          declarations: decls
        });
      }
    
      /**
       * Parse import
       */
    
      var atimport = _compileAtrule('import');
    
      /**
       * Parse charset
       */
    
      var atcharset = _compileAtrule('charset');
    
      /**
       * Parse namespace
       */
    
      var atnamespace = _compileAtrule('namespace');
    
      /**
       * Parse non-block at-rules
       */
    
    
      function _compileAtrule(name) {
        var re = new RegExp('^@' + name + ' *([^;\\n]+);');
        return function() {
          var pos = position();
          var m = match(re);
          if (!m) return;
          var ret = { type: name };
          ret[name] = m[1].trim();
          return pos(ret);
        }
      }
    
      /**
       * Parse at rule.
       */
    
      function atrule() {
        if (css[0] != '@') return;
    
        return atkeyframes()
          || atmedia()
          || atcustommedia()
          || atsupports()
          || atimport()
          || atcharset()
          || atnamespace()
          || atdocument()
          || atpage()
          || athost()
          || atfontface();
      }
    
      /**
       * Parse rule.
       */
    
      function rule() {
        var pos = position();
        var sel = selector();
    
        if (!sel) return error('selector missing');
        comments();
    
        return pos({
          type: 'rule',
          selectors: sel,
          declarations: declarations()
        });
      }
    
      return addParent(stylesheet());
    };
    
    /**
     * Trim `str`.
     */
    
    function trim(str) {
      return str ? str.replace(/^\s+|\s+$/g, '') : '';
    }
    
    /**
     * Adds non-enumerable parent node reference to each node.
     */
    
    function addParent(obj, parent) {
      var isNode = obj && typeof obj.type === 'string';
      var childParent = isNode ? obj : parent;
    
      for (var k in obj) {
        var value = obj[k];
        if (Array.isArray(value)) {
          value.forEach(function(v) { addParent(v, childParent); });
        } else if (value && typeof value === 'object') {
          addParent(value, childParent);
        }
      }
    
      if (isNode) {
        Object.defineProperty(obj, 'parent', {
          configurable: true,
          writable: true,
          enumerable: false,
          value: parent || null
        });
      }
    
      return obj;
    }
    
  provide("css/lib/parse", module.exports);
}(global));

// pakmanager:css/lib/stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Compressed =  require('css/lib/stringify/compress');
    var Identity =  require('css/lib/stringify/identity');
    
    /**
     * Stringfy the given AST `node`.
     *
     * Options:
     *
     *  - `compress` space-optimized output
     *  - `sourcemap` return an object with `.code` and `.map`
     *
     * @param {Object} node
     * @param {Object} [options]
     * @return {String}
     * @api public
     */
    
    module.exports = function(node, options){
      options = options || {};
    
      var compiler = options.compress
        ? new Compressed(options)
        : new Identity(options);
    
      // source maps
      if (options.sourcemap) {
        var sourcemaps =  require('css/lib/stringify/source-map-support');
        sourcemaps(compiler);
    
        var code = compiler.compile(node);
        compiler.applySourceMaps();
    
        var map = options.sourcemap === 'generator'
          ? compiler.map
          : compiler.map.toJSON();
    
        return { code: code, map: map };
      }
    
      var code = compiler.compile(node);
      return code;
    };
    
  provide("css/lib/stringify", module.exports);
}(global));

// pakmanager:css
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.parse =  require('css/lib/parse');
    exports.stringify =  require('css/lib/stringify');
    
  provide("css", module.exports);
}(global));

// pakmanager:clone
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    
    // shim for Node's 'util' package
    // DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).
    var util = {
      isArray: function (ar) {
        return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
      },
      isDate: function (d) {
        return typeof d === 'object' && objectToString(d) === '[object Date]';
      },
      isRegExp: function (re) {
        return typeof re === 'object' && objectToString(re) === '[object RegExp]';
      },
      getRegExpFlags: function (re) {
        var flags = '';
        re.global && (flags += 'g');
        re.ignoreCase && (flags += 'i');
        re.multiline && (flags += 'm');
        return flags;
      }
    };
    
    
    if (typeof module === 'object')
      module.exports = clone;
    
    /**
     * Clones (copies) an Object using deep copying.
     *
     * This function supports circular references by default, but if you are certain
     * there are no circular references in your object, you can save some CPU time
     * by calling clone(obj, false).
     *
     * Caution: if `circular` is false and `parent` contains circular references,
     * your program may enter an infinite loop and crash.
     *
     * @param `parent` - the object to be cloned
     * @param `circular` - set to true if the object to be cloned may contain
     *    circular references. (optional - true by default)
     * @param `depth` - set to a number if the object is only to be cloned to
     *    a particular depth. (optional - defaults to Infinity)
     * @param `prototype` - sets the prototype to be used when cloning an object.
     *    (optional - defaults to parent prototype).
    */
    
    function clone(parent, circular, depth, prototype) {
      // maintain two arrays for circular references, where corresponding parents
      // and children have the same index
      var allParents = [];
      var allChildren = [];
    
      var useBuffer = typeof Buffer != 'undefined';
    
      if (typeof circular == 'undefined')
        circular = true;
    
      if (typeof depth == 'undefined')
        depth = Infinity;
    
      // recurse this function so we don't reset allParents and allChildren
      function _clone(parent, depth) {
        // cloning null always returns null
        if (parent === null)
          return null;
    
        if (depth == 0)
          return parent;
    
        var child;
        if (typeof parent != 'object') {
          return parent;
        }
    
        if (util.isArray(parent)) {
          child = [];
        } else if (util.isRegExp(parent)) {
          child = new RegExp(parent.source, util.getRegExpFlags(parent));
          if (parent.lastIndex) child.lastIndex = parent.lastIndex;
        } else if (util.isDate(parent)) {
          child = new Date(parent.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent)) {
          child = new Buffer(parent.length);
          parent.copy(child);
          return child;
        } else {
          if (typeof prototype == 'undefined') child = Object.create(Object.getPrototypeOf(parent));
          else child = Object.create(prototype);
        }
    
        if (circular) {
          var index = allParents.indexOf(parent);
    
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent);
          allChildren.push(child);
        }
    
        for (var i in parent) {
          child[i] = _clone(parent[i], depth - 1);
        }
    
        return child;
      }
    
      return _clone(parent, depth);
    }
    
    /**
     * Simple flat clone using prototype, accepts only objects, usefull for property
     * override on FLAT configuration object (no nested props).
     *
     * USE WITH CAUTION! This may not behave as you wish if you do not know how this
     * works.
     */
    clone.clonePrototype = function(parent) {
      if (parent === null)
        return null;
    
      var c = function () {};
      c.prototype = parent;
      return new c();
    };
    
  provide("clone", module.exports);
}(global));

// pakmanager:uglify-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require("path");
    var fs = require("fs");
    var vm = require("vm");
    var sys = require("util");
    
    var UglifyJS = vm.createContext({
        sys           : sys,
        console       : console,
        MOZ_SourceMap : require("source-map")
    });
    
    function load_global(file) {
        file = path.resolve(path.dirname(module.filename), file);
        try {
            var code = fs.readFileSync(file, "utf8");
            return vm.runInContext(code, UglifyJS, file);
        } catch(ex) {
            // XXX: in case of a syntax error, the message is kinda
            // useless. (no location information).
            sys.debug("ERROR in file: " + file + " / " + ex);
            process.exit(1);
        }
    };
    
    var FILES = exports.FILES = [
        "../lib/utils.js",
        "../lib/ast.js",
        "../lib/parse.js",
        "../lib/transform.js",
        "../lib/scope.js",
        "../lib/output.js",
        "../lib/compress.js",
        "../lib/sourcemap.js",
        "../lib/mozilla-ast.js"
    ].map(function(file){
        return path.join(path.dirname(fs.realpathSync(__filename)), file);
    });
    
    FILES.forEach(load_global);
    
    UglifyJS.AST_Node.warn_function = function(txt) {
        sys.error("WARN: " + txt);
    };
    
    // XXX: perhaps we shouldn't export everything but heck, I'm lazy.
    for (var i in UglifyJS) {
        if (UglifyJS.hasOwnProperty(i)) {
            exports[i] = UglifyJS[i];
        }
    }
    
    exports.minify = function(files, options) {
        options = UglifyJS.defaults(options, {
            spidermonkey : false,
            outSourceMap : null,
            sourceRoot   : null,
            inSourceMap  : null,
            fromString   : false,
            warnings     : false,
            mangle       : {},
            output       : null,
            compress     : {}
        });
        UglifyJS.base54.reset();
    
        // 1. parse
        var toplevel = null,
            sourcesContent = {};
    
        if (options.spidermonkey) {
            toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
        } else {
            if (typeof files == "string")
                files = [ files ];
            files.forEach(function(file){
                var code = options.fromString
                    ? file
                    : fs.readFileSync(file, "utf8");
                sourcesContent[file] = code;
                toplevel = UglifyJS.parse(code, {
                    filename: options.fromString ? "?" : file,
                    toplevel: toplevel
                });
            });
        }
    
        // 2. compress
        if (options.compress) {
            var compress = { warnings: options.warnings };
            UglifyJS.merge(compress, options.compress);
            toplevel.figure_out_scope();
            var sq = UglifyJS.Compressor(compress);
            toplevel = toplevel.transform(sq);
        }
    
        // 3. mangle
        if (options.mangle) {
            toplevel.figure_out_scope();
            toplevel.compute_char_frequency();
            toplevel.mangle_names(options.mangle);
        }
    
        // 4. output
        var inMap = options.inSourceMap;
        var output = {};
        if (typeof options.inSourceMap == "string") {
            inMap = fs.readFileSync(options.inSourceMap, "utf8");
        }
        if (options.outSourceMap) {
            output.source_map = UglifyJS.SourceMap({
                file: options.outSourceMap,
                orig: inMap,
                root: options.sourceRoot
            });
            if (options.sourceMapIncludeSources) {
                for (var file in sourcesContent) {
                    if (sourcesContent.hasOwnProperty(file)) {
                        output.source_map.get().setSourceContent(file, sourcesContent[file]);
                    }
                }
            }
    
        }
        if (options.output) {
            UglifyJS.merge(output, options.output);
        }
        var stream = UglifyJS.OutputStream(output);
        toplevel.print(stream);
    
        if(options.outSourceMap){
            stream += "\n//# sourceMappingURL=" + options.outSourceMap;
        }
    
        return {
            code : stream + "",
            map  : output.source_map + ""
        };
    };
    
    // exports.describe_ast = function() {
    //     function doitem(ctor) {
    //         var sub = {};
    //         ctor.SUBCLASSES.forEach(function(ctor){
    //             sub[ctor.TYPE] = doitem(ctor);
    //         });
    //         var ret = {};
    //         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
    //         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
    //         return ret;
    //     }
    //     return doitem(UglifyJS.AST_Node).sub;
    // }
    
    exports.describe_ast = function() {
        var out = UglifyJS.OutputStream({ beautify: true });
        function doitem(ctor) {
            out.print("AST_" + ctor.TYPE);
            var props = ctor.SELF_PROPS.filter(function(prop){
                return !/^\$/.test(prop);
            });
            if (props.length > 0) {
                out.space();
                out.with_parens(function(){
                    props.forEach(function(prop, i){
                        if (i) out.space();
                        out.print(prop);
                    });
                });
            }
            if (ctor.documentation) {
                out.space();
                out.print_string(ctor.documentation);
            }
            if (ctor.SUBCLASSES.length > 0) {
                out.space();
                out.with_block(function(){
                    ctor.SUBCLASSES.forEach(function(ctor, i){
                        out.indent();
                        doitem(ctor);
                        out.newline();
                    });
                });
            }
        };
        doitem(UglifyJS.AST_Node);
        return out + "";
    };
    
  provide("uglify-js", module.exports);
}(global));

// pakmanager:wrappy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Returns a wrapper function that returns a wrapped callback
    // The wrapper function should do some stuff, and return a
    // presumably different callback function.
    // This makes sure that own properties are retained, so that
    // decorations and such are not lost along the way.
    module.exports = wrappy
    function wrappy (fn, cb) {
      if (fn && cb) return wrappy(fn)(cb)
    
      if (typeof fn !== 'function')
        throw new TypeError('need wrapper function')
    
      Object.keys(fn).forEach(function (k) {
        wrapper[k] = fn[k]
      })
    
      return wrapper
    
      function wrapper() {
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        var ret = fn.apply(this, args)
        var cb = args[args.length-1]
        if (typeof ret === 'function' && ret !== cb) {
          Object.keys(cb).forEach(function (k) {
            ret[k] = cb[k]
          })
        }
        return ret
      }
    }
    
  provide("wrappy", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseCreate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNative =  require('lodash-node/modern/internals/isNative'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        noop =  require('lodash-node/modern/utilities/noop');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate;
    
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || global.Object();
        };
      }());
    }
    
    module.exports = baseCreate;
    
  provide("lodash-node/modern/internals/baseCreate", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isObject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var objectTypes =  require('lodash-node/modern/internals/objectTypes');
    
    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }
    
    module.exports = isObject;
    
  provide("lodash-node/modern/objects/isObject", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/setBindData
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNative =  require('lodash-node/modern/internals/isNative'),
        noop =  require('lodash-node/modern/utilities/noop');
    
    /** Used as the property descriptor for `__bindData__` */
    var descriptor = {
      'configurable': false,
      'enumerable': false,
      'value': null,
      'writable': false
    };
    
    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());
    
    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };
    
    module.exports = setBindData;
    
  provide("lodash-node/modern/internals/setBindData", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/slice
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Slices the `collection` from the `start` index up to, but not including,
     * the `end` index.
     *
     * Note: This function is used instead of `Array#slice` to support node lists
     * in IE < 9 and to ensure dense arrays are returned.
     *
     * @private
     * @param {Array|Object|string} collection The collection to slice.
     * @param {number} start The start index.
     * @param {number} end The end index.
     * @returns {Array} Returns the new array.
     */
    function slice(array, start, end) {
      start || (start = 0);
      if (typeof end == 'undefined') {
        end = array ? array.length : 0;
      }
      var index = -1,
          length = end - start || 0,
          result = Array(length < 0 ? 0 : length);
    
      while (++index < length) {
        result[index] = array[start + index];
      }
      return result;
    }
    
    module.exports = slice;
    
  provide("lodash-node/modern/internals/slice", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/createWrapper
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseBind =  require('lodash-node/modern/internals/baseBind'),
        baseCreateWrapper =  require('lodash-node/modern/internals/baseCreateWrapper'),
        isFunction =  require('lodash-node/modern/objects/isFunction'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];
    
    /** Native method shortcuts */
    var push = arrayRef.push,
        unshift = arrayRef.unshift;
    
    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;
    
      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }
    
    module.exports = createWrapper;
    
  provide("lodash-node/modern/internals/createWrapper", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/isNative
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );
    
    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }
    
    module.exports = isNative;
    
  provide("lodash-node/modern/internals/isNative", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/noop
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }
    
    module.exports = noop;
    
  provide("lodash-node/modern/utilities/noop", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseBind
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreate =  require('lodash-node/modern/internals/baseCreate'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        setBindData =  require('lodash-node/modern/internals/setBindData'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];
    
    /** Native method shortcuts */
    var push = arrayRef.push;
    
    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];
    
      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }
    
    module.exports = baseBind;
    
  provide("lodash-node/modern/internals/baseBind", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseCreateWrapper
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreate =  require('lodash-node/modern/internals/baseCreate'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        setBindData =  require('lodash-node/modern/internals/setBindData'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];
    
    /** Native method shortcuts */
    var push = arrayRef.push;
    
    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];
    
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;
    
      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }
    
    module.exports = baseCreateWrapper;
    
  provide("lodash-node/modern/internals/baseCreateWrapper", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isFunction
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }
    
    module.exports = isFunction;
    
  provide("lodash-node/modern/objects/isFunction", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/bind
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createWrapper =  require('lodash-node/modern/internals/createWrapper'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }
    
    module.exports = bind;
    
  provide("lodash-node/modern/functions/bind", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/identity
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }
    
    module.exports = identity;
    
  provide("lodash-node/modern/utilities/identity", module.exports);
}(global));

// pakmanager:lodash-node/modern/support
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNative =  require('lodash-node/modern/internals/isNative');
    
    /** Used to detect functions containing a `this` reference */
    var reThis = /\bthis\b/;
    
    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = {};
    
    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });
    
    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';
    
    module.exports = support;
    
  provide("lodash-node/modern/support", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/objectTypes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to determine if values are of the language type Object */
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    
    module.exports = objectTypes;
    
  provide("lodash-node/modern/internals/objectTypes", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseCreateCallback
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var bind =  require('lodash-node/modern/functions/bind'),
        identity =  require('lodash-node/modern/utilities/identity'),
        setBindData =  require('lodash-node/modern/internals/setBindData'),
        support =  require('lodash-node/modern/support');
    
    /** Used to detected named functions */
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    
    /** Used to detect functions containing a `this` reference */
    var reThis = /\bthis\b/;
    
    /** Native method shortcuts */
    var fnToString = Function.prototype.toString;
    
    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }
    
    module.exports = baseCreateCallback;
    
  provide("lodash-node/modern/internals/baseCreateCallback", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/arrayPool
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to pool arrays and objects used internally */
    var arrayPool = [];
    
    module.exports = arrayPool;
    
  provide("lodash-node/modern/internals/arrayPool", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/maxPoolSize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used as the max size of the `arrayPool` and `objectPool` */
    var maxPoolSize = 40;
    
    module.exports = maxPoolSize;
    
  provide("lodash-node/modern/internals/maxPoolSize", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/shimKeys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var objectTypes =  require('lodash-node/modern/internals/objectTypes');
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };
    
    module.exports = shimKeys;
    
  provide("lodash-node/modern/internals/shimKeys", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/forIn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        objectTypes =  require('lodash-node/modern/internals/objectTypes');
    
    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };
    
    module.exports = forIn;
    
  provide("lodash-node/modern/objects/forIn", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/getArray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var arrayPool =  require('lodash-node/modern/internals/arrayPool');
    
    /**
     * Gets an array from the array pool or creates a new one if the pool is empty.
     *
     * @private
     * @returns {Array} The array from the pool.
     */
    function getArray() {
      return arrayPool.pop() || [];
    }
    
    module.exports = getArray;
    
  provide("lodash-node/modern/internals/getArray", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/releaseArray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var arrayPool =  require('lodash-node/modern/internals/arrayPool'),
        maxPoolSize =  require('lodash-node/modern/internals/maxPoolSize');
    
    /**
     * Releases the given array back to the array pool.
     *
     * @private
     * @param {Array} [array] The array to release.
     */
    function releaseArray(array) {
      array.length = 0;
      if (arrayPool.length < maxPoolSize) {
        arrayPool.push(array);
      }
    }
    
    module.exports = releaseArray;
    
  provide("lodash-node/modern/internals/releaseArray", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/keyPrefix
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
    var keyPrefix = +new Date + '';
    
    module.exports = keyPrefix;
    
  provide("lodash-node/modern/internals/keyPrefix", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/objectPool
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to pool arrays and objects used internally */
    var objectPool = [];
    
    module.exports = objectPool;
    
  provide("lodash-node/modern/internals/objectPool", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/keys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNative =  require('lodash-node/modern/internals/isNative'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        shimKeys =  require('lodash-node/modern/internals/shimKeys');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;
    
    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };
    
    module.exports = keys;
    
  provide("lodash-node/modern/objects/keys", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseIsEqual
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forIn =  require('lodash-node/modern/objects/forIn'),
        getArray =  require('lodash-node/modern/internals/getArray'),
        isFunction =  require('lodash-node/modern/objects/isFunction'),
        objectTypes =  require('lodash-node/modern/internals/objectTypes'),
        releaseArray =  require('lodash-node/modern/internals/releaseArray');
    
    /** `Object#toString` result shortcuts */
    var argsClass = '[object Arguments]',
        arrayClass = '[object Array]',
        boolClass = '[object Boolean]',
        dateClass = '[object Date]',
        numberClass = '[object Number]',
        objectClass = '[object Object]',
        regexpClass = '[object RegExp]',
        stringClass = '[object String]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;
    
      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);
    
      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;
    
        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);
    
        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');
    
        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;
    
        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());
    
      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;
    
      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);
    
      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;
    
        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];
    
            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });
    
        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();
    
      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
    
    module.exports = baseIsEqual;
    
  provide("lodash-node/modern/internals/baseIsEqual", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }
    
    module.exports = property;
    
  provide("lodash-node/modern/utilities/property", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/htmlEscapes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    
    module.exports = htmlEscapes;
    
  provide("lodash-node/modern/internals/htmlEscapes", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseIndexOf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * The base implementation of `_.indexOf` without support for binary searches
     * or `fromIndex` constraints.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0;
    
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    
    module.exports = baseIndexOf;
    
  provide("lodash-node/modern/internals/baseIndexOf", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/cachePush
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var keyPrefix =  require('lodash-node/modern/internals/keyPrefix');
    
    /**
     * Adds a given value to the corresponding cache object.
     *
     * @private
     * @param {*} value The value to add to the cache.
     */
    function cachePush(value) {
      var cache = this.cache,
          type = typeof value;
    
      if (type == 'boolean' || value == null) {
        cache[value] = true;
      } else {
        if (type != 'number' && type != 'string') {
          type = 'object';
        }
        var key = type == 'number' ? value : keyPrefix + value,
            typeCache = cache[type] || (cache[type] = {});
    
        if (type == 'object') {
          (typeCache[key] || (typeCache[key] = [])).push(value);
        } else {
          typeCache[key] = true;
        }
      }
    }
    
    module.exports = cachePush;
    
  provide("lodash-node/modern/internals/cachePush", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/getObject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var objectPool =  require('lodash-node/modern/internals/objectPool');
    
    /**
     * Gets an object from the object pool or creates a new one if the pool is empty.
     *
     * @private
     * @returns {Object} The object from the pool.
     */
    function getObject() {
      return objectPool.pop() || {
        'array': null,
        'cache': null,
        'criteria': null,
        'false': false,
        'index': 0,
        'null': false,
        'number': null,
        'object': null,
        'push': null,
        'string': null,
        'true': false,
        'undefined': false,
        'value': null
      };
    }
    
    module.exports = getObject;
    
  provide("lodash-node/modern/internals/getObject", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/releaseObject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var maxPoolSize =  require('lodash-node/modern/internals/maxPoolSize'),
        objectPool =  require('lodash-node/modern/internals/objectPool');
    
    /**
     * Releases the given object back to the object pool.
     *
     * @private
     * @param {Object} [object] The object to release.
     */
    function releaseObject(object) {
      var cache = object.cache;
      if (cache) {
        releaseObject(cache);
      }
      object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
      if (objectPool.length < maxPoolSize) {
        objectPool.push(object);
      }
    }
    
    module.exports = releaseObject;
    
  provide("lodash-node/modern/internals/releaseObject", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/forOwn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        keys =  require('lodash-node/modern/objects/keys'),
        objectTypes =  require('lodash-node/modern/internals/objectTypes');
    
    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;
    
        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };
    
    module.exports = forOwn;
    
  provide("lodash-node/modern/objects/forOwn", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/createCallback
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        baseIsEqual =  require('lodash-node/modern/internals/baseIsEqual'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        keys =  require('lodash-node/modern/objects/keys'),
        property =  require('lodash-node/modern/utilities/property');
    
    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];
    
      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;
    
        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }
    
    module.exports = createCallback;
    
  provide("lodash-node/modern/functions/createCallback", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/shimIsPlainObject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forIn =  require('lodash-node/modern/objects/forIn'),
        isFunction =  require('lodash-node/modern/objects/isFunction');
    
    /** `Object#toString` result shortcuts */
    var objectClass = '[object Object]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;
    
      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }
    
    module.exports = shimIsPlainObject;
    
  provide("lodash-node/modern/internals/shimIsPlainObject", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/escapeHtmlChar
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var htmlEscapes =  require('lodash-node/modern/internals/htmlEscapes');
    
    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }
    
    module.exports = escapeHtmlChar;
    
  provide("lodash-node/modern/internals/escapeHtmlChar", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/reUnescapedHtml
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var htmlEscapes =  require('lodash-node/modern/internals/htmlEscapes'),
        keys =  require('lodash-node/modern/objects/keys');
    
    /** Used to match HTML entities and HTML characters */
    var reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
    
    module.exports = reUnescapedHtml;
    
  provide("lodash-node/modern/internals/reUnescapedHtml", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/invert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var keys =  require('lodash-node/modern/objects/keys');
    
    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};
    
      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }
    
    module.exports = invert;
    
  provide("lodash-node/modern/objects/invert", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/cacheIndexOf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseIndexOf =  require('lodash-node/modern/internals/baseIndexOf'),
        keyPrefix =  require('lodash-node/modern/internals/keyPrefix');
    
    /**
     * An implementation of `_.contains` for cache objects that mimics the return
     * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache object to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var type = typeof value;
      cache = cache.cache;
    
      if (type == 'boolean' || value == null) {
        return cache[value] ? 0 : -1;
      }
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value;
      cache = (cache = cache[type]) && cache[key];
    
      return type == 'object'
        ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
        : (cache ? 0 : -1);
    }
    
    module.exports = cacheIndexOf;
    
  provide("lodash-node/modern/internals/cacheIndexOf", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/createCache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var cachePush =  require('lodash-node/modern/internals/cachePush'),
        getObject =  require('lodash-node/modern/internals/getObject'),
        releaseObject =  require('lodash-node/modern/internals/releaseObject');
    
    /**
     * Creates a cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [array=[]] The array to search.
     * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
     */
    function createCache(array) {
      var index = -1,
          length = array.length,
          first = array[0],
          mid = array[(length / 2) | 0],
          last = array[length - 1];
    
      if (first && typeof first == 'object' &&
          mid && typeof mid == 'object' && last && typeof last == 'object') {
        return false;
      }
      var cache = getObject();
      cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
    
      var result = getObject();
      result.array = array;
      result.cache = cache;
      result.push = cachePush;
    
      while (++index < length) {
        result.push(array[index]);
      }
      return result;
    }
    
    module.exports = createCache;
    
  provide("lodash-node/modern/internals/createCache", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/largeArraySize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used as the size when optimizations are enabled for large arrays */
    var largeArraySize = 75;
    
    module.exports = largeArraySize;
    
  provide("lodash-node/modern/internals/largeArraySize", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isArguments
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** `Object#toString` result shortcuts */
    var argsClass = '[object Arguments]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }
    
    module.exports = isArguments;
    
  provide("lodash-node/modern/objects/isArguments", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isArray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNative =  require('lodash-node/modern/internals/isNative');
    
    /** `Object#toString` result shortcuts */
    var arrayClass = '[object Array]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;
    
    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };
    
    module.exports = isArray;
    
  provide("lodash-node/modern/objects/isArray", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/charAtCallback
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Used by `_.max` and `_.min` as the default callback when a given
     * collection is a string value.
     *
     * @private
     * @param {string} value The character to inspect.
     * @returns {number} Returns the code unit of given character.
     */
    function charAtCallback(value) {
      return value.charCodeAt(0);
    }
    
    module.exports = charAtCallback;
    
  provide("lodash-node/modern/internals/charAtCallback", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/forEach
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;
    
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }
    
    module.exports = forEach;
    
  provide("lodash-node/modern/collections/forEach", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isString
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** `Object#toString` result shortcuts */
    var stringClass = '[object String]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }
    
    module.exports = isString;
    
  provide("lodash-node/modern/objects/isString", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;
    
      callback = createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }
    
    module.exports = map;
    
  provide("lodash-node/modern/collections/map", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseRandom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Native method shortcuts */
    var floor = Math.floor;
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeRandom = Math.random;
    
    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }
    
    module.exports = baseRandom;
    
  provide("lodash-node/modern/internals/baseRandom", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/now
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNative =  require('lodash-node/modern/internals/isNative');
    
    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };
    
    module.exports = now;
    
  provide("lodash-node/modern/utilities/now", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/assign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        keys =  require('lodash-node/modern/objects/keys'),
        objectTypes =  require('lodash-node/modern/internals/objectTypes');
    
    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;
    
        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };
    
    module.exports = assign;
    
  provide("lodash-node/modern/objects/assign", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isPlainObject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNative =  require('lodash-node/modern/internals/isNative'),
        shimIsPlainObject =  require('lodash-node/modern/internals/shimIsPlainObject');
    
    /** `Object#toString` result shortcuts */
    var objectClass = '[object Object]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /** Native method shortcuts */
    var getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf;
    
    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
    
      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };
    
    module.exports = isPlainObject;
    
  provide("lodash-node/modern/objects/isPlainObject", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/escape
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var escapeHtmlChar =  require('lodash-node/modern/internals/escapeHtmlChar'),
        keys =  require('lodash-node/modern/objects/keys'),
        reUnescapedHtml =  require('lodash-node/modern/internals/reUnescapedHtml');
    
    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }
    
    module.exports = escape;
    
  provide("lodash-node/modern/utilities/escape", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/reInterpolate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to match "interpolate" template delimiters */
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    
    module.exports = reInterpolate;
    
  provide("lodash-node/modern/internals/reInterpolate", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/htmlUnescapes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var htmlEscapes =  require('lodash-node/modern/internals/htmlEscapes'),
        invert =  require('lodash-node/modern/objects/invert');
    
    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);
    
    module.exports = htmlUnescapes;
    
  provide("lodash-node/modern/internals/htmlUnescapes", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseDifference
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseIndexOf =  require('lodash-node/modern/internals/baseIndexOf'),
        cacheIndexOf =  require('lodash-node/modern/internals/cacheIndexOf'),
        createCache =  require('lodash-node/modern/internals/createCache'),
        largeArraySize =  require('lodash-node/modern/internals/largeArraySize'),
        releaseObject =  require('lodash-node/modern/internals/releaseObject');
    
    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = baseIndexOf,
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize,
          result = [];
    
      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }
    
    module.exports = baseDifference;
    
  provide("lodash-node/modern/internals/baseDifference", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseFlatten
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isArguments =  require('lodash-node/modern/objects/isArguments'),
        isArray =  require('lodash-node/modern/objects/isArray');
    
    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];
    
      while (++index < length) {
        var value = array[index];
    
        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;
    
          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }
    
    module.exports = baseFlatten;
    
  provide("lodash-node/modern/internals/baseFlatten", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/sortedIndex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        identity =  require('lodash-node/modern/utilities/identity');
    
    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;
    
      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? createCallback(callback, thisArg, 1) : identity;
      value = callback(value);
    
      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }
    
    module.exports = sortedIndex;
    
  provide("lodash-node/modern/arrays/sortedIndex", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseUniq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseIndexOf =  require('lodash-node/modern/internals/baseIndexOf'),
        cacheIndexOf =  require('lodash-node/modern/internals/cacheIndexOf'),
        createCache =  require('lodash-node/modern/internals/createCache'),
        getArray =  require('lodash-node/modern/internals/getArray'),
        largeArraySize =  require('lodash-node/modern/internals/largeArraySize'),
        releaseArray =  require('lodash-node/modern/internals/releaseArray'),
        releaseObject =  require('lodash-node/modern/internals/releaseObject');
    
    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = baseIndexOf,
          length = array ? array.length : 0,
          result = [];
    
      var isLarge = !isSorted && length >= largeArraySize,
          seen = (callback || isLarge) ? getArray() : result;
    
      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;
    
        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }
    
    module.exports = baseUniq;
    
  provide("lodash-node/modern/internals/baseUniq", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/max
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var charAtCallback =  require('lodash-node/modern/internals/charAtCallback'),
        createCallback =  require('lodash-node/modern/functions/createCallback'),
        forEach =  require('lodash-node/modern/collections/forEach'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        isString =  require('lodash-node/modern/objects/isString');
    
    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;
    
      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;
    
        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : createCallback(callback, thisArg, 3);
    
        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }
    
    module.exports = max;
    
  provide("lodash-node/modern/collections/max", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/pluck
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var map =  require('lodash-node/modern/collections/map');
    
    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;
    
    module.exports = pluck;
    
  provide("lodash-node/modern/collections/pluck", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/lodashWrapper
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    
    module.exports = lodashWrapper;
    
  provide("lodash-node/modern/internals/lodashWrapper", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/createAggregator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray');
    
    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = createCallback(callback, thisArg, 3);
    
        var index = -1,
            length = collection ? collection.length : 0;
    
        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }
    
    module.exports = createAggregator;
    
  provide("lodash-node/modern/internals/createAggregator", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/forEachRight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        isString =  require('lodash-node/modern/objects/isString'),
        keys =  require('lodash-node/modern/objects/keys');
    
    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }
    
    module.exports = forEachRight;
    
  provide("lodash-node/modern/collections/forEachRight", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/filter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = createCallback(callback, thisArg, 3);
    
      var index = -1,
          length = collection ? collection.length : 0;
    
      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }
    
    module.exports = filter;
    
  provide("lodash-node/modern/collections/filter", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/shuffle
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseRandom =  require('lodash-node/modern/internals/baseRandom'),
        forEach =  require('lodash-node/modern/collections/forEach');
    
    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);
    
      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }
    
    module.exports = shuffle;
    
  provide("lodash-node/modern/collections/shuffle", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/values
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var keys =  require('lodash-node/modern/objects/keys');
    
    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);
    
      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }
    
    module.exports = values;
    
  provide("lodash-node/modern/objects/values", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/compareAscending
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Used by `sortBy` to compare transformed `collection` elements, stable sorting
     * them in ascending order.
     *
     * @private
     * @param {Object} a The object to compare to `b`.
     * @param {Object} b The object to compare to `a`.
     * @returns {number} Returns the sort order indicator of `1` or `-1`.
     */
    function compareAscending(a, b) {
      var ac = a.criteria,
          bc = b.criteria,
          index = -1,
          length = ac.length;
    
      while (++index < length) {
        var value = ac[index],
            other = bc[index];
    
        if (value !== other) {
          if (value > other || typeof value == 'undefined') {
            return 1;
          }
          if (value < other || typeof other == 'undefined') {
            return -1;
          }
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to return the same value for
      // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
      //
      // This also ensures a stable sort in V8 and other engines.
      // See http://code.google.com/p/v8/issues/detail?id=90
      return a.index - b.index;
    }
    
    module.exports = compareAscending;
    
  provide("lodash-node/modern/internals/compareAscending", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/functions
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forIn =  require('lodash-node/modern/objects/forIn'),
        isFunction =  require('lodash-node/modern/objects/isFunction');
    
    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }
    
    module.exports = functions;
    
  provide("lodash-node/modern/objects/functions", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/debounce
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        now =  require('lodash-node/modern/utilities/now');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max;
    
    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;
    
      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };
    
      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };
    
      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);
    
        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;
    
          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }
    
    module.exports = debounce;
    
  provide("lodash-node/modern/functions/debounce", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseClone
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var assign =  require('lodash-node/modern/objects/assign'),
        forEach =  require('lodash-node/modern/collections/forEach'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        getArray =  require('lodash-node/modern/internals/getArray'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        releaseArray =  require('lodash-node/modern/internals/releaseArray'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /** Used to match regexp flags from their coerced string values */
    var reFlags = /\w*$/;
    
    /** `Object#toString` result shortcuts */
    var argsClass = '[object Arguments]',
        arrayClass = '[object Array]',
        boolClass = '[object Boolean]',
        dateClass = '[object Date]',
        funcClass = '[object Function]',
        numberClass = '[object Number]',
        objectClass = '[object Object]',
        regexpClass = '[object RegExp]',
        stringClass = '[object String]';
    
    /** Used to identify object classifications that `_.clone` supports */
    var cloneableClasses = {};
    cloneableClasses[funcClass] = false;
    cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
    cloneableClasses[boolClass] = cloneableClasses[dateClass] =
    cloneableClasses[numberClass] = cloneableClasses[objectClass] =
    cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;
    
    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);
    
          case numberClass:
          case stringClass:
            return new ctor(value);
    
          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());
    
        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);
    
      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });
    
      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
    
    module.exports = baseClone;
    
  provide("lodash-node/modern/internals/baseClone", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/forOwnRight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        keys =  require('lodash-node/modern/objects/keys');
    
    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;
    
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }
    
    module.exports = forOwnRight;
    
  provide("lodash-node/modern/objects/forOwnRight", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isNumber
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** `Object#toString` result shortcuts */
    var numberClass = '[object Number]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }
    
    module.exports = isNumber;
    
  provide("lodash-node/modern/objects/isNumber", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/baseMerge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forEach =  require('lodash-node/modern/collections/forEach'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        isPlainObject =  require('lodash-node/modern/objects/isPlainObject');
    
    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];
    
        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);
    
            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }
    
    module.exports = baseMerge;
    
  provide("lodash-node/modern/internals/baseMerge", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/defaults
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var keys =  require('lodash-node/modern/objects/keys'),
        objectTypes =  require('lodash-node/modern/internals/objectTypes');
    
    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;
    
        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };
    
    module.exports = defaults;
    
  provide("lodash-node/modern/objects/defaults", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/escapeStringChar
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to escape characters for inclusion in compiled string literals */
    var stringEscapes = {
      '\\': '\\',
      "'": "'",
      '\n': 'n',
      '\r': 'r',
      '\t': 't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
    
    /**
     * Used by `template` to escape characters for inclusion in compiled
     * string literals.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeStringChar(match) {
      return '\\' + stringEscapes[match];
    }
    
    module.exports = escapeStringChar;
    
  provide("lodash-node/modern/internals/escapeStringChar", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/templateSettings
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var escape =  require('lodash-node/modern/utilities/escape'),
        reInterpolate =  require('lodash-node/modern/internals/reInterpolate');
    
    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var templateSettings = {
    
      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,
    
      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,
    
      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,
    
      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',
    
      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {
    
        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': { 'escape': escape }
      }
    };
    
    module.exports = templateSettings;
    
  provide("lodash-node/modern/utilities/templateSettings", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/reEscapedHtml
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var htmlUnescapes =  require('lodash-node/modern/internals/htmlUnescapes'),
        keys =  require('lodash-node/modern/objects/keys');
    
    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g');
    
    module.exports = reEscapedHtml;
    
  provide("lodash-node/modern/internals/reEscapedHtml", module.exports);
}(global));

// pakmanager:lodash-node/modern/internals/unescapeHtmlChar
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var htmlUnescapes =  require('lodash-node/modern/internals/htmlUnescapes');
    
    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }
    
    module.exports = unescapeHtmlChar;
    
  provide("lodash-node/modern/internals/unescapeHtmlChar", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/compact
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];
    
      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }
    
    module.exports = compact;
    
  provide("lodash-node/modern/arrays/compact", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/difference
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseDifference =  require('lodash-node/modern/internals/baseDifference'),
        baseFlatten =  require('lodash-node/modern/internals/baseFlatten');
    
    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }
    
    module.exports = difference;
    
  provide("lodash-node/modern/arrays/difference", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/rest
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max;
    
    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;
    
        callback = createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }
    
    module.exports = rest;
    
  provide("lodash-node/modern/arrays/rest", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/findIndex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback');
    
    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;
    
      callback = createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    
    module.exports = findIndex;
    
  provide("lodash-node/modern/arrays/findIndex", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/findLastIndex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback');
    
    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }
    
    module.exports = findLastIndex;
    
  provide("lodash-node/modern/arrays/findLastIndex", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/first
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max,
        nativeMin = Math.min;
    
    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;
    
      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }
    
    module.exports = first;
    
  provide("lodash-node/modern/arrays/first", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/flatten
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseFlatten =  require('lodash-node/modern/internals/baseFlatten'),
        map =  require('lodash-node/modern/collections/map');
    
    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }
    
    module.exports = flatten;
    
  provide("lodash-node/modern/arrays/flatten", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/indexOf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseIndexOf =  require('lodash-node/modern/internals/baseIndexOf'),
        sortedIndex =  require('lodash-node/modern/arrays/sortedIndex');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max;
    
    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }
    
    module.exports = indexOf;
    
  provide("lodash-node/modern/arrays/indexOf", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/initial
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max,
        nativeMin = Math.min;
    
    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;
    
      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }
    
    module.exports = initial;
    
  provide("lodash-node/modern/arrays/initial", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/intersection
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseIndexOf =  require('lodash-node/modern/internals/baseIndexOf'),
        cacheIndexOf =  require('lodash-node/modern/internals/cacheIndexOf'),
        createCache =  require('lodash-node/modern/internals/createCache'),
        getArray =  require('lodash-node/modern/internals/getArray'),
        isArguments =  require('lodash-node/modern/objects/isArguments'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        largeArraySize =  require('lodash-node/modern/internals/largeArraySize'),
        releaseArray =  require('lodash-node/modern/internals/releaseArray'),
        releaseObject =  require('lodash-node/modern/internals/releaseObject');
    
    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = baseIndexOf,
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();
    
      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];
    
      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];
    
        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }
    
    module.exports = intersection;
    
  provide("lodash-node/modern/arrays/intersection", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/last
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max;
    
    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;
    
      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }
    
    module.exports = last;
    
  provide("lodash-node/modern/arrays/last", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/lastIndexOf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max,
        nativeMin = Math.min;
    
    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    
    module.exports = lastIndexOf;
    
  provide("lodash-node/modern/arrays/lastIndexOf", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/zipObject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isArray =  require('lodash-node/modern/objects/isArray');
    
    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};
    
      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }
    
    module.exports = zipObject;
    
  provide("lodash-node/modern/arrays/zipObject", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/pull
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];
    
    /** Native method shortcuts */
    var splice = arrayRef.splice;
    
    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;
    
      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }
    
    module.exports = pull;
    
  provide("lodash-node/modern/arrays/pull", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/range
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Native method shortcuts */
    var ceil = Math.ceil;
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max;
    
    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);
    
      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);
    
      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }
    
    module.exports = range;
    
  provide("lodash-node/modern/arrays/range", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/remove
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback');
    
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];
    
    /** Native method shortcuts */
    var splice = arrayRef.splice;
    
    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];
    
      callback = createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }
    
    module.exports = remove;
    
  provide("lodash-node/modern/arrays/remove", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/union
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseFlatten =  require('lodash-node/modern/internals/baseFlatten'),
        baseUniq =  require('lodash-node/modern/internals/baseUniq');
    
    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }
    
    module.exports = union;
    
  provide("lodash-node/modern/arrays/union", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/uniq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseUniq =  require('lodash-node/modern/internals/baseUniq'),
        createCallback =  require('lodash-node/modern/functions/createCallback');
    
    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }
    
    module.exports = uniq;
    
  provide("lodash-node/modern/arrays/uniq", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/zip
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var max =  require('lodash-node/modern/collections/max'),
        pluck =  require('lodash-node/modern/collections/pluck');
    
    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);
    
      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }
    
    module.exports = zip;
    
  provide("lodash-node/modern/arrays/zip", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/without
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseDifference =  require('lodash-node/modern/internals/baseDifference'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }
    
    module.exports = without;
    
  provide("lodash-node/modern/arrays/without", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays/xor
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseDifference =  require('lodash-node/modern/internals/baseDifference'),
        baseUniq =  require('lodash-node/modern/internals/baseUniq'),
        isArguments =  require('lodash-node/modern/objects/isArguments'),
        isArray =  require('lodash-node/modern/objects/isArray');
    
    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;
    
      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }
    
    module.exports = xor;
    
  provide("lodash-node/modern/arrays/xor", module.exports);
}(global));

// pakmanager:lodash-node/modern/chaining/chain
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var lodashWrapper =  require('lodash-node/modern/internals/lodashWrapper');
    
    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }
    
    module.exports = chain;
    
  provide("lodash-node/modern/chaining/chain", module.exports);
}(global));

// pakmanager:lodash-node/modern/chaining/tap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }
    
    module.exports = tap;
    
  provide("lodash-node/modern/chaining/tap", module.exports);
}(global));

// pakmanager:lodash-node/modern/chaining/wrapperValueOf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forEach =  require('lodash-node/modern/collections/forEach'),
        support =  require('lodash-node/modern/support');
    
    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }
    
    module.exports = wrapperValueOf;
    
  provide("lodash-node/modern/chaining/wrapperValueOf", module.exports);
}(global));

// pakmanager:lodash-node/modern/chaining/wrapperChain
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }
    
    module.exports = wrapperChain;
    
  provide("lodash-node/modern/chaining/wrapperChain", module.exports);
}(global));

// pakmanager:lodash-node/modern/chaining/wrapperToString
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }
    
    module.exports = wrapperToString;
    
  provide("lodash-node/modern/chaining/wrapperToString", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/every
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = createCallback(callback, thisArg, 3);
    
      var index = -1,
          length = collection ? collection.length : 0;
    
      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }
    
    module.exports = every;
    
  provide("lodash-node/modern/collections/every", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/some
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray');
    
    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = createCallback(callback, thisArg, 3);
    
      var index = -1,
          length = collection ? collection.length : 0;
    
      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }
    
    module.exports = some;
    
  provide("lodash-node/modern/collections/some", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/at
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseFlatten =  require('lodash-node/modern/internals/baseFlatten'),
        isString =  require('lodash-node/modern/objects/isString');
    
    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);
    
      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }
    
    module.exports = at;
    
  provide("lodash-node/modern/collections/at", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/contains
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseIndexOf =  require('lodash-node/modern/internals/baseIndexOf'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        isString =  require('lodash-node/modern/objects/isString');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max;
    
    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = baseIndexOf,
          length = collection ? collection.length : 0,
          result = false;
    
      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }
    
    module.exports = contains;
    
  provide("lodash-node/modern/collections/contains", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/countBy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createAggregator =  require('lodash-node/modern/internals/createAggregator');
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });
    
    module.exports = countBy;
    
  provide("lodash-node/modern/collections/countBy", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/find
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = createCallback(callback, thisArg, 3);
    
      var index = -1,
          length = collection ? collection.length : 0;
    
      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }
    
    module.exports = find;
    
  provide("lodash-node/modern/collections/find", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/findLast
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forEachRight =  require('lodash-node/modern/collections/forEachRight');
    
    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }
    
    module.exports = findLast;
    
  provide("lodash-node/modern/collections/findLast", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/reduce
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = createCallback(callback, thisArg, 4);
    
      var index = -1,
          length = collection.length;
    
      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }
    
    module.exports = reduce;
    
  provide("lodash-node/modern/collections/reduce", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/reduceRight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forEachRight =  require('lodash-node/modern/collections/forEachRight');
    
    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }
    
    module.exports = reduceRight;
    
  provide("lodash-node/modern/collections/reduceRight", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/groupBy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createAggregator =  require('lodash-node/modern/internals/createAggregator');
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });
    
    module.exports = groupBy;
    
  provide("lodash-node/modern/collections/groupBy", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/indexBy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createAggregator =  require('lodash-node/modern/internals/createAggregator');
    
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });
    
    module.exports = indexBy;
    
  provide("lodash-node/modern/collections/indexBy", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/invoke
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forEach =  require('lodash-node/modern/collections/forEach'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);
    
      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }
    
    module.exports = invoke;
    
  provide("lodash-node/modern/collections/invoke", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/min
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var charAtCallback =  require('lodash-node/modern/internals/charAtCallback'),
        createCallback =  require('lodash-node/modern/functions/createCallback'),
        forEach =  require('lodash-node/modern/collections/forEach'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        isString =  require('lodash-node/modern/objects/isString');
    
    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;
    
      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;
    
        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : createCallback(callback, thisArg, 3);
    
        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }
    
    module.exports = min;
    
  provide("lodash-node/modern/collections/min", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/reject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        filter =  require('lodash-node/modern/collections/filter');
    
    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }
    
    module.exports = reject;
    
  provide("lodash-node/modern/collections/reject", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/sample
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseRandom =  require('lodash-node/modern/internals/baseRandom'),
        isString =  require('lodash-node/modern/objects/isString'),
        shuffle =  require('lodash-node/modern/collections/shuffle'),
        values =  require('lodash-node/modern/objects/values');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMax = Math.max,
        nativeMin = Math.min;
    
    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }
    
    module.exports = sample;
    
  provide("lodash-node/modern/collections/sample", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/size
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var keys =  require('lodash-node/modern/objects/keys');
    
    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }
    
    module.exports = size;
    
  provide("lodash-node/modern/collections/size", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/sortBy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var compareAscending =  require('lodash-node/modern/internals/compareAscending'),
        createCallback =  require('lodash-node/modern/functions/createCallback'),
        forEach =  require('lodash-node/modern/collections/forEach'),
        getArray =  require('lodash-node/modern/internals/getArray'),
        getObject =  require('lodash-node/modern/internals/getObject'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        map =  require('lodash-node/modern/collections/map'),
        releaseArray =  require('lodash-node/modern/internals/releaseArray'),
        releaseObject =  require('lodash-node/modern/internals/releaseObject');
    
    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);
    
      if (!isArr) {
        callback = createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });
    
      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }
    
    module.exports = sortBy;
    
  provide("lodash-node/modern/collections/sortBy", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/toArray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isString =  require('lodash-node/modern/objects/isString'),
        slice =  require('lodash-node/modern/internals/slice'),
        values =  require('lodash-node/modern/objects/values');
    
    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }
    
    module.exports = toArray;
    
  provide("lodash-node/modern/collections/toArray", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections/where
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var filter =  require('lodash-node/modern/collections/filter');
    
    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;
    
    module.exports = where;
    
  provide("lodash-node/modern/collections/where", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/after
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction');
    
    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }
    
    module.exports = after;
    
  provide("lodash-node/modern/functions/after", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/bindAll
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseFlatten =  require('lodash-node/modern/internals/baseFlatten'),
        createWrapper =  require('lodash-node/modern/internals/createWrapper'),
        functions =  require('lodash-node/modern/objects/functions');
    
    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;
    
      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }
    
    module.exports = bindAll;
    
  provide("lodash-node/modern/functions/bindAll", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/bindKey
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createWrapper =  require('lodash-node/modern/internals/createWrapper'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }
    
    module.exports = bindKey;
    
  provide("lodash-node/modern/functions/bindKey", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/compose
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction');
    
    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;
    
      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;
    
        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }
    
    module.exports = compose;
    
  provide("lodash-node/modern/functions/compose", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/curry
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createWrapper =  require('lodash-node/modern/internals/createWrapper');
    
    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }
    
    module.exports = curry;
    
  provide("lodash-node/modern/functions/curry", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/defer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }
    
    module.exports = defer;
    
  provide("lodash-node/modern/functions/defer", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/delay
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }
    
    module.exports = delay;
    
  provide("lodash-node/modern/functions/delay", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/memoize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction'),
        keyPrefix =  require('lodash-node/modern/internals/keyPrefix');
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
    
        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }
    
    module.exports = memoize;
    
  provide("lodash-node/modern/functions/memoize", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/once
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction');
    
    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;
    
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);
    
        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }
    
    module.exports = once;
    
  provide("lodash-node/modern/functions/once", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/partial
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createWrapper =  require('lodash-node/modern/internals/createWrapper'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }
    
    module.exports = partial;
    
  provide("lodash-node/modern/functions/partial", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/partialRight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createWrapper =  require('lodash-node/modern/internals/createWrapper'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }
    
    module.exports = partialRight;
    
  provide("lodash-node/modern/functions/partialRight", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/throttle
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var debounce =  require('lodash-node/modern/functions/debounce'),
        isFunction =  require('lodash-node/modern/objects/isFunction'),
        isObject =  require('lodash-node/modern/objects/isObject');
    
    /** Used as an internal `_.debounce` options object */
    var debounceOptions = {
      'leading': false,
      'maxWait': 0,
      'trailing': false
    };
    
    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;
    
      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;
    
      return debounce(func, wait, debounceOptions);
    }
    
    module.exports = throttle;
    
  provide("lodash-node/modern/functions/throttle", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions/wrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createWrapper =  require('lodash-node/modern/internals/createWrapper');
    
    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }
    
    module.exports = wrap;
    
  provide("lodash-node/modern/functions/wrap", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/clone
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseClone =  require('lodash-node/modern/internals/baseClone'),
        baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback');
    
    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }
    
    module.exports = clone;
    
  provide("lodash-node/modern/objects/clone", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/cloneDeep
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseClone =  require('lodash-node/modern/internals/baseClone'),
        baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback');
    
    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }
    
    module.exports = cloneDeep;
    
  provide("lodash-node/modern/objects/cloneDeep", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/create
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var assign =  require('lodash-node/modern/objects/assign'),
        baseCreate =  require('lodash-node/modern/internals/baseCreate');
    
    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }
    
    module.exports = create;
    
  provide("lodash-node/modern/objects/create", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/findKey
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    
    module.exports = findKey;
    
  provide("lodash-node/modern/objects/findKey", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/findLastKey
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwnRight =  require('lodash-node/modern/objects/forOwnRight');
    
    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    
    module.exports = findLastKey;
    
  provide("lodash-node/modern/objects/findLastKey", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/forInRight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        forIn =  require('lodash-node/modern/objects/forIn');
    
    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];
    
      forIn(object, function(value, key) {
        pairs.push(key, value);
      });
    
      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }
    
    module.exports = forInRight;
    
  provide("lodash-node/modern/objects/forInRight", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/has
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }
    
    module.exports = has;
    
  provide("lodash-node/modern/objects/has", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isBoolean
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** `Object#toString` result shortcuts */
    var boolClass = '[object Boolean]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }
    
    module.exports = isBoolean;
    
  provide("lodash-node/modern/objects/isBoolean", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isDate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** `Object#toString` result shortcuts */
    var dateClass = '[object Date]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }
    
    module.exports = isDate;
    
  provide("lodash-node/modern/objects/isDate", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isElement
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }
    
    module.exports = isElement;
    
  provide("lodash-node/modern/objects/isElement", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isEmpty
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forOwn =  require('lodash-node/modern/objects/forOwn'),
        isFunction =  require('lodash-node/modern/objects/isFunction');
    
    /** `Object#toString` result shortcuts */
    var argsClass = '[object Arguments]',
        arrayClass = '[object Array]',
        objectClass = '[object Object]',
        stringClass = '[object String]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;
    
      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }
    
    module.exports = isEmpty;
    
  provide("lodash-node/modern/objects/isEmpty", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isEqual
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        baseIsEqual =  require('lodash-node/modern/internals/baseIsEqual');
    
    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }
    
    module.exports = isEqual;
    
  provide("lodash-node/modern/objects/isEqual", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isFinite
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeIsFinite = global.isFinite,
        nativeIsNaN = global.isNaN;
    
    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }
    
    module.exports = isFinite;
    
  provide("lodash-node/modern/objects/isFinite", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isNaN
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isNumber =  require('lodash-node/modern/objects/isNumber');
    
    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }
    
    module.exports = isNaN;
    
  provide("lodash-node/modern/objects/isNaN", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isNull
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }
    
    module.exports = isNull;
    
  provide("lodash-node/modern/objects/isNull", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isRegExp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** `Object#toString` result shortcuts */
    var regexpClass = '[object RegExp]';
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;
    
    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }
    
    module.exports = isRegExp;
    
  provide("lodash-node/modern/objects/isRegExp", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/isUndefined
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }
    
    module.exports = isUndefined;
    
  provide("lodash-node/modern/objects/isUndefined", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/mapValues
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var createCallback =  require('lodash-node/modern/functions/createCallback'),
        forOwn =  require('lodash-node/modern/objects/forOwn');
    
    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = createCallback(callback, thisArg, 3);
    
      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }
    
    module.exports = mapValues;
    
  provide("lodash-node/modern/objects/mapValues", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/merge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback'),
        baseMerge =  require('lodash-node/modern/internals/baseMerge'),
        getArray =  require('lodash-node/modern/internals/getArray'),
        isObject =  require('lodash-node/modern/objects/isObject'),
        releaseArray =  require('lodash-node/modern/internals/releaseArray'),
        slice =  require('lodash-node/modern/internals/slice');
    
    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;
    
      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();
    
      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }
    
    module.exports = merge;
    
  provide("lodash-node/modern/objects/merge", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/omit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseDifference =  require('lodash-node/modern/internals/baseDifference'),
        baseFlatten =  require('lodash-node/modern/internals/baseFlatten'),
        createCallback =  require('lodash-node/modern/functions/createCallback'),
        forIn =  require('lodash-node/modern/objects/forIn');
    
    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));
    
        var index = -1,
            length = props.length;
    
        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }
    
    module.exports = omit;
    
  provide("lodash-node/modern/objects/omit", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/pairs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var keys =  require('lodash-node/modern/objects/keys');
    
    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);
    
      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }
    
    module.exports = pairs;
    
  provide("lodash-node/modern/objects/pairs", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/pick
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseFlatten =  require('lodash-node/modern/internals/baseFlatten'),
        createCallback =  require('lodash-node/modern/functions/createCallback'),
        forIn =  require('lodash-node/modern/objects/forIn'),
        isObject =  require('lodash-node/modern/objects/isObject');
    
    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;
    
        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }
    
    module.exports = pick;
    
  provide("lodash-node/modern/objects/pick", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects/transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreate =  require('lodash-node/modern/internals/baseCreate'),
        createCallback =  require('lodash-node/modern/functions/createCallback'),
        forEach =  require('lodash-node/modern/collections/forEach'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray');
    
    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;
    
          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }
    
    module.exports = transform;
    
  provide("lodash-node/modern/objects/transform", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/constant
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }
    
    module.exports = constant;
    
  provide("lodash-node/modern/utilities/constant", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/mixin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var forEach =  require('lodash-node/modern/collections/forEach'),
        functions =  require('lodash-node/modern/objects/functions'),
        isFunction =  require('lodash-node/modern/objects/isFunction'),
        isObject =  require('lodash-node/modern/objects/isObject');
    
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];
    
    /** Native method shortcuts */
    var push = arrayRef.push;
    
    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);
    
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);
    
      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];
    
            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }
    
    module.exports = mixin;
    
  provide("lodash-node/modern/utilities/mixin", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/noConflict
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = global._;
    
    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      global._ = oldDash;
      return this;
    }
    
    module.exports = noConflict;
    
  provide("lodash-node/modern/utilities/noConflict", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/parseInt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isString =  require('lodash-node/modern/objects/isString');
    
    /** Used to detect and test whitespace */
    var whitespace = (
      // whitespace
      ' \t\x0B\f\xA0\ufeff' +
    
      // line terminators
      '\n\r\u2028\u2029' +
    
      // unicode category "Zs" space separators
      '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
    );
    
    /** Used to match leading whitespace and zeros to be removed */
    var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeParseInt = global.parseInt;
    
    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };
    
    module.exports = parseInt;
    
  provide("lodash-node/modern/utilities/parseInt", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/random
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseRandom =  require('lodash-node/modern/internals/baseRandom');
    
    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeMin = Math.min,
        nativeRandom = Math.random;
    
    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;
    
      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }
    
    module.exports = random;
    
  provide("lodash-node/modern/utilities/random", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/result
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var isFunction =  require('lodash-node/modern/objects/isFunction');
    
    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }
    
    module.exports = result;
    
  provide("lodash-node/modern/utilities/result", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/template
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var defaults =  require('lodash-node/modern/objects/defaults'),
        escape =  require('lodash-node/modern/utilities/escape'),
        escapeStringChar =  require('lodash-node/modern/internals/escapeStringChar'),
        keys =  require('lodash-node/modern/objects/keys'),
        reInterpolate =  require('lodash-node/modern/internals/reInterpolate'),
        templateSettings =  require('lodash-node/modern/utilities/templateSettings'),
        values =  require('lodash-node/modern/objects/values');
    
    /** Used to match empty string literals in compiled template source */
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    
    /**
     * Used to match ES6 template delimiters
     * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
     */
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    
    /** Used to ensure capturing order of template delimiters */
    var reNoMatch = /($^)/;
    
    /** Used to match unescaped characters in compiled string literals */
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    
    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = templateSettings.imports._.templateSettings || templateSettings;
      text = String(text || '');
    
      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);
    
      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);
    
      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";
    
      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');
    
      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
    
        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
    
        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;
    
        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });
    
      source += "';\n";
    
      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;
    
      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');
    
      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';
    
      try {
        var result = Function(importsKeys, 'return ' + source ).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }
    
    module.exports = template;
    
  provide("lodash-node/modern/utilities/template", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/times
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var baseCreateCallback =  require('lodash-node/modern/internals/baseCreateCallback');
    
    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);
    
      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }
    
    module.exports = times;
    
  provide("lodash-node/modern/utilities/times", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/unescape
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var keys =  require('lodash-node/modern/objects/keys'),
        reEscapedHtml =  require('lodash-node/modern/internals/reEscapedHtml'),
        unescapeHtmlChar =  require('lodash-node/modern/internals/unescapeHtmlChar');
    
    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }
    
    module.exports = unescape;
    
  provide("lodash-node/modern/utilities/unescape", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities/uniqueId
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    /** Used to generate unique IDs */
    var idCounter = 0;
    
    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }
    
    module.exports = uniqueId;
    
  provide("lodash-node/modern/utilities/uniqueId", module.exports);
}(global));

// pakmanager:lodash-node/modern/arrays
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    module.exports = {
      'compact':  require('lodash-node/modern/arrays/compact'),
      'difference':  require('lodash-node/modern/arrays/difference'),
      'drop':  require('lodash-node/modern/arrays/rest'),
      'findIndex':  require('lodash-node/modern/arrays/findIndex'),
      'findLastIndex':  require('lodash-node/modern/arrays/findLastIndex'),
      'first':  require('lodash-node/modern/arrays/first'),
      'flatten':  require('lodash-node/modern/arrays/flatten'),
      'head':  require('lodash-node/modern/arrays/first'),
      'indexOf':  require('lodash-node/modern/arrays/indexOf'),
      'initial':  require('lodash-node/modern/arrays/initial'),
      'intersection':  require('lodash-node/modern/arrays/intersection'),
      'last':  require('lodash-node/modern/arrays/last'),
      'lastIndexOf':  require('lodash-node/modern/arrays/lastIndexOf'),
      'object':  require('lodash-node/modern/arrays/zipObject'),
      'pull':  require('lodash-node/modern/arrays/pull'),
      'range':  require('lodash-node/modern/arrays/range'),
      'remove':  require('lodash-node/modern/arrays/remove'),
      'rest':  require('lodash-node/modern/arrays/rest'),
      'sortedIndex':  require('lodash-node/modern/arrays/sortedIndex'),
      'tail':  require('lodash-node/modern/arrays/rest'),
      'take':  require('lodash-node/modern/arrays/first'),
      'union':  require('lodash-node/modern/arrays/union'),
      'uniq':  require('lodash-node/modern/arrays/uniq'),
      'unique':  require('lodash-node/modern/arrays/uniq'),
      'unzip':  require('lodash-node/modern/arrays/zip'),
      'without':  require('lodash-node/modern/arrays/without'),
      'xor':  require('lodash-node/modern/arrays/xor'),
      'zip':  require('lodash-node/modern/arrays/zip'),
      'zipObject':  require('lodash-node/modern/arrays/zipObject')
    };
    
  provide("lodash-node/modern/arrays", module.exports);
}(global));

// pakmanager:lodash-node/modern/chaining
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    module.exports = {
      'chain':  require('lodash-node/modern/chaining/chain'),
      'tap':  require('lodash-node/modern/chaining/tap'),
      'value':  require('lodash-node/modern/chaining/wrapperValueOf'),
      'wrapperChain':  require('lodash-node/modern/chaining/wrapperChain'),
      'wrapperToString':  require('lodash-node/modern/chaining/wrapperToString'),
      'wrapperValueOf':  require('lodash-node/modern/chaining/wrapperValueOf')
    };
    
  provide("lodash-node/modern/chaining", module.exports);
}(global));

// pakmanager:lodash-node/modern/collections
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    module.exports = {
      'all':  require('lodash-node/modern/collections/every'),
      'any':  require('lodash-node/modern/collections/some'),
      'at':  require('lodash-node/modern/collections/at'),
      'collect':  require('lodash-node/modern/collections/map'),
      'contains':  require('lodash-node/modern/collections/contains'),
      'countBy':  require('lodash-node/modern/collections/countBy'),
      'detect':  require('lodash-node/modern/collections/find'),
      'each':  require('lodash-node/modern/collections/forEach'),
      'eachRight':  require('lodash-node/modern/collections/forEachRight'),
      'every':  require('lodash-node/modern/collections/every'),
      'filter':  require('lodash-node/modern/collections/filter'),
      'find':  require('lodash-node/modern/collections/find'),
      'findLast':  require('lodash-node/modern/collections/findLast'),
      'findWhere':  require('lodash-node/modern/collections/find'),
      'foldl':  require('lodash-node/modern/collections/reduce'),
      'foldr':  require('lodash-node/modern/collections/reduceRight'),
      'forEach':  require('lodash-node/modern/collections/forEach'),
      'forEachRight':  require('lodash-node/modern/collections/forEachRight'),
      'groupBy':  require('lodash-node/modern/collections/groupBy'),
      'include':  require('lodash-node/modern/collections/contains'),
      'indexBy':  require('lodash-node/modern/collections/indexBy'),
      'inject':  require('lodash-node/modern/collections/reduce'),
      'invoke':  require('lodash-node/modern/collections/invoke'),
      'map':  require('lodash-node/modern/collections/map'),
      'max':  require('lodash-node/modern/collections/max'),
      'min':  require('lodash-node/modern/collections/min'),
      'pluck':  require('lodash-node/modern/collections/pluck'),
      'reduce':  require('lodash-node/modern/collections/reduce'),
      'reduceRight':  require('lodash-node/modern/collections/reduceRight'),
      'reject':  require('lodash-node/modern/collections/reject'),
      'sample':  require('lodash-node/modern/collections/sample'),
      'select':  require('lodash-node/modern/collections/filter'),
      'shuffle':  require('lodash-node/modern/collections/shuffle'),
      'size':  require('lodash-node/modern/collections/size'),
      'some':  require('lodash-node/modern/collections/some'),
      'sortBy':  require('lodash-node/modern/collections/sortBy'),
      'toArray':  require('lodash-node/modern/collections/toArray'),
      'where':  require('lodash-node/modern/collections/where')
    };
    
  provide("lodash-node/modern/collections", module.exports);
}(global));

// pakmanager:lodash-node/modern/functions
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    module.exports = {
      'after':  require('lodash-node/modern/functions/after'),
      'bind':  require('lodash-node/modern/functions/bind'),
      'bindAll':  require('lodash-node/modern/functions/bindAll'),
      'bindKey':  require('lodash-node/modern/functions/bindKey'),
      'compose':  require('lodash-node/modern/functions/compose'),
      'createCallback':  require('lodash-node/modern/functions/createCallback'),
      'curry':  require('lodash-node/modern/functions/curry'),
      'debounce':  require('lodash-node/modern/functions/debounce'),
      'defer':  require('lodash-node/modern/functions/defer'),
      'delay':  require('lodash-node/modern/functions/delay'),
      'memoize':  require('lodash-node/modern/functions/memoize'),
      'once':  require('lodash-node/modern/functions/once'),
      'partial':  require('lodash-node/modern/functions/partial'),
      'partialRight':  require('lodash-node/modern/functions/partialRight'),
      'throttle':  require('lodash-node/modern/functions/throttle'),
      'wrap':  require('lodash-node/modern/functions/wrap')
    };
    
  provide("lodash-node/modern/functions", module.exports);
}(global));

// pakmanager:lodash-node/modern/objects
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    module.exports = {
      'assign':  require('lodash-node/modern/objects/assign'),
      'clone':  require('lodash-node/modern/objects/clone'),
      'cloneDeep':  require('lodash-node/modern/objects/cloneDeep'),
      'create':  require('lodash-node/modern/objects/create'),
      'defaults':  require('lodash-node/modern/objects/defaults'),
      'extend':  require('lodash-node/modern/objects/assign'),
      'findKey':  require('lodash-node/modern/objects/findKey'),
      'findLastKey':  require('lodash-node/modern/objects/findLastKey'),
      'forIn':  require('lodash-node/modern/objects/forIn'),
      'forInRight':  require('lodash-node/modern/objects/forInRight'),
      'forOwn':  require('lodash-node/modern/objects/forOwn'),
      'forOwnRight':  require('lodash-node/modern/objects/forOwnRight'),
      'functions':  require('lodash-node/modern/objects/functions'),
      'has':  require('lodash-node/modern/objects/has'),
      'invert':  require('lodash-node/modern/objects/invert'),
      'isArguments':  require('lodash-node/modern/objects/isArguments'),
      'isArray':  require('lodash-node/modern/objects/isArray'),
      'isBoolean':  require('lodash-node/modern/objects/isBoolean'),
      'isDate':  require('lodash-node/modern/objects/isDate'),
      'isElement':  require('lodash-node/modern/objects/isElement'),
      'isEmpty':  require('lodash-node/modern/objects/isEmpty'),
      'isEqual':  require('lodash-node/modern/objects/isEqual'),
      'isFinite':  require('lodash-node/modern/objects/isFinite'),
      'isFunction':  require('lodash-node/modern/objects/isFunction'),
      'isNaN':  require('lodash-node/modern/objects/isNaN'),
      'isNull':  require('lodash-node/modern/objects/isNull'),
      'isNumber':  require('lodash-node/modern/objects/isNumber'),
      'isObject':  require('lodash-node/modern/objects/isObject'),
      'isPlainObject':  require('lodash-node/modern/objects/isPlainObject'),
      'isRegExp':  require('lodash-node/modern/objects/isRegExp'),
      'isString':  require('lodash-node/modern/objects/isString'),
      'isUndefined':  require('lodash-node/modern/objects/isUndefined'),
      'keys':  require('lodash-node/modern/objects/keys'),
      'mapValues':  require('lodash-node/modern/objects/mapValues'),
      'merge':  require('lodash-node/modern/objects/merge'),
      'methods':  require('lodash-node/modern/objects/functions'),
      'omit':  require('lodash-node/modern/objects/omit'),
      'pairs':  require('lodash-node/modern/objects/pairs'),
      'pick':  require('lodash-node/modern/objects/pick'),
      'transform':  require('lodash-node/modern/objects/transform'),
      'values':  require('lodash-node/modern/objects/values')
    };
    
  provide("lodash-node/modern/objects", module.exports);
}(global));

// pakmanager:lodash-node/modern/utilities
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    
    module.exports = {
      'constant':  require('lodash-node/modern/utilities/constant'),
      'createCallback':  require('lodash-node/modern/functions/createCallback'),
      'escape':  require('lodash-node/modern/utilities/escape'),
      'identity':  require('lodash-node/modern/utilities/identity'),
      'mixin':  require('lodash-node/modern/utilities/mixin'),
      'noConflict':  require('lodash-node/modern/utilities/noConflict'),
      'noop':  require('lodash-node/modern/utilities/noop'),
      'now':  require('lodash-node/modern/utilities/now'),
      'parseInt':  require('lodash-node/modern/utilities/parseInt'),
      'property':  require('lodash-node/modern/utilities/property'),
      'random':  require('lodash-node/modern/utilities/random'),
      'result':  require('lodash-node/modern/utilities/result'),
      'template':  require('lodash-node/modern/utilities/template'),
      'templateSettings':  require('lodash-node/modern/utilities/templateSettings'),
      'times':  require('lodash-node/modern/utilities/times'),
      'unescape':  require('lodash-node/modern/utilities/unescape'),
      'uniqueId':  require('lodash-node/modern/utilities/uniqueId')
    };
    
  provide("lodash-node/modern/utilities", module.exports);
}(global));

// pakmanager:lodash-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @license
     * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
     * Build: `lodash modularize modern exports="node" -o ./modern/`
     * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <http://lodash.com/license>
     */
    var arrays =  require('lodash-node/modern/arrays'),
        chaining =  require('lodash-node/modern/chaining'),
        collections =  require('lodash-node/modern/collections'),
        functions =  require('lodash-node/modern/functions'),
        objects =  require('lodash-node/modern/objects'),
        utilities =  require('lodash-node/modern/utilities'),
        forEach =  require('lodash-node/modern/collections/forEach'),
        forOwn =  require('lodash-node/modern/objects/forOwn'),
        isArray =  require('lodash-node/modern/objects/isArray'),
        lodashWrapper =  require('lodash-node/modern/internals/lodashWrapper'),
        mixin =  require('lodash-node/modern/utilities/mixin'),
        support =  require('lodash-node/modern/support'),
        templateSettings =  require('lodash-node/modern/utilities/templateSettings');
    
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];
    
    /** Used for native method references */
    var objectProto = Object.prototype;
    
    /** Native method shortcuts */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;
    
    // wrap `_.mixin` so it works when provided only one argument
    mixin = (function(fn) {
      var functions = objects.functions;
      return function(object, source, options) {
        if (!source || (!options && !functions(source).length)) {
          if (options == null) {
            options = source;
          }
          source = object;
          object = lodash;
        }
        return fn(object, source, options);
      };
    }(mixin));
    
    // add functions that return wrapped values when chaining
    lodash.after = functions.after;
    lodash.assign = objects.assign;
    lodash.at = collections.at;
    lodash.bind = functions.bind;
    lodash.bindAll = functions.bindAll;
    lodash.bindKey = functions.bindKey;
    lodash.chain = chaining.chain;
    lodash.compact = arrays.compact;
    lodash.compose = functions.compose;
    lodash.constant = utilities.constant;
    lodash.countBy = collections.countBy;
    lodash.create = objects.create;
    lodash.createCallback = functions.createCallback;
    lodash.curry = functions.curry;
    lodash.debounce = functions.debounce;
    lodash.defaults = objects.defaults;
    lodash.defer = functions.defer;
    lodash.delay = functions.delay;
    lodash.difference = arrays.difference;
    lodash.filter = collections.filter;
    lodash.flatten = arrays.flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = collections.forEachRight;
    lodash.forIn = objects.forIn;
    lodash.forInRight = objects.forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = objects.forOwnRight;
    lodash.functions = objects.functions;
    lodash.groupBy = collections.groupBy;
    lodash.indexBy = collections.indexBy;
    lodash.initial = arrays.initial;
    lodash.intersection = arrays.intersection;
    lodash.invert = objects.invert;
    lodash.invoke = collections.invoke;
    lodash.keys = objects.keys;
    lodash.map = collections.map;
    lodash.mapValues = objects.mapValues;
    lodash.max = collections.max;
    lodash.memoize = functions.memoize;
    lodash.merge = objects.merge;
    lodash.min = collections.min;
    lodash.omit = objects.omit;
    lodash.once = functions.once;
    lodash.pairs = objects.pairs;
    lodash.partial = functions.partial;
    lodash.partialRight = functions.partialRight;
    lodash.pick = objects.pick;
    lodash.pluck = collections.pluck;
    lodash.property = utilities.property;
    lodash.pull = arrays.pull;
    lodash.range = arrays.range;
    lodash.reject = collections.reject;
    lodash.remove = arrays.remove;
    lodash.rest = arrays.rest;
    lodash.shuffle = collections.shuffle;
    lodash.sortBy = collections.sortBy;
    lodash.tap = chaining.tap;
    lodash.throttle = functions.throttle;
    lodash.times = utilities.times;
    lodash.toArray = collections.toArray;
    lodash.transform = objects.transform;
    lodash.union = arrays.union;
    lodash.uniq = arrays.uniq;
    lodash.values = objects.values;
    lodash.where = collections.where;
    lodash.without = arrays.without;
    lodash.wrap = functions.wrap;
    lodash.xor = arrays.xor;
    lodash.zip = arrays.zip;
    lodash.zipObject = arrays.zipObject;
    
    // add aliases
    lodash.collect = collections.map;
    lodash.drop = arrays.rest;
    lodash.each = forEach;
    lodash.eachRight = collections.forEachRight;
    lodash.extend = objects.assign;
    lodash.methods = objects.functions;
    lodash.object = arrays.zipObject;
    lodash.select = collections.filter;
    lodash.tail = arrays.rest;
    lodash.unique = arrays.uniq;
    lodash.unzip = arrays.zip;
    
    // add functions to `lodash.prototype`
    mixin(lodash);
    
    // add functions that return unwrapped values when chaining
    lodash.clone = objects.clone;
    lodash.cloneDeep = objects.cloneDeep;
    lodash.contains = collections.contains;
    lodash.escape = utilities.escape;
    lodash.every = collections.every;
    lodash.find = collections.find;
    lodash.findIndex = arrays.findIndex;
    lodash.findKey = objects.findKey;
    lodash.findLast = collections.findLast;
    lodash.findLastIndex = arrays.findLastIndex;
    lodash.findLastKey = objects.findLastKey;
    lodash.has = objects.has;
    lodash.identity = utilities.identity;
    lodash.indexOf = arrays.indexOf;
    lodash.isArguments = objects.isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = objects.isBoolean;
    lodash.isDate = objects.isDate;
    lodash.isElement = objects.isElement;
    lodash.isEmpty = objects.isEmpty;
    lodash.isEqual = objects.isEqual;
    lodash.isFinite = objects.isFinite;
    lodash.isFunction = objects.isFunction;
    lodash.isNaN = objects.isNaN;
    lodash.isNull = objects.isNull;
    lodash.isNumber = objects.isNumber;
    lodash.isObject = objects.isObject;
    lodash.isPlainObject = objects.isPlainObject;
    lodash.isRegExp = objects.isRegExp;
    lodash.isString = objects.isString;
    lodash.isUndefined = objects.isUndefined;
    lodash.lastIndexOf = arrays.lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = utilities.noConflict;
    lodash.noop = utilities.noop;
    lodash.now = utilities.now;
    lodash.parseInt = utilities.parseInt;
    lodash.random = utilities.random;
    lodash.reduce = collections.reduce;
    lodash.reduceRight = collections.reduceRight;
    lodash.result = utilities.result;
    lodash.size = collections.size;
    lodash.some = collections.some;
    lodash.sortedIndex = arrays.sortedIndex;
    lodash.template = utilities.template;
    lodash.unescape = utilities.unescape;
    lodash.uniqueId = utilities.uniqueId;
    
    // add aliases
    lodash.all = collections.every;
    lodash.any = collections.some;
    lodash.detect = collections.find;
    lodash.findWhere = collections.find;
    lodash.foldl = collections.reduce;
    lodash.foldr = collections.reduceRight;
    lodash.include = collections.contains;
    lodash.inject = collections.reduce;
    
    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);
    
    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = arrays.first;
    lodash.last = arrays.last;
    lodash.sample = collections.sample;
    
    // add aliases
    lodash.take = arrays.first;
    lodash.head = arrays.first;
    
    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);
    
          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });
    
    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';
    
    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = chaining.wrapperChain;
    lodash.prototype.toString = chaining.wrapperToString;
    lodash.prototype.value = chaining.wrapperValueOf;
    lodash.prototype.valueOf = chaining.wrapperValueOf;
    
    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);
    
        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });
    
    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });
    
    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });
    
    lodash.support = support;
    (lodash.templateSettings = utilities.templateSettings).imports._ = lodash;
    module.exports = lodash;
    
  provide("lodash-node", module.exports);
}(global));

// pakmanager:ms
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options.long
        ? long(val)
        : short(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 's':
          return n * s;
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function long(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
  provide("ms", module.exports);
}(global));

// pakmanager:combined-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util');
    var Stream = require('stream').Stream;
    var DelayedStream = require('delayed-stream');
    
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
    
      this._released = false;
      this._streams = [];
      this._currentStream = null;
    }
    util.inherits(CombinedStream, Stream);
    
    CombinedStream.create = function(options) {
      var combinedStream = new this();
    
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
    
      return combinedStream;
    };
    
    CombinedStream.isStreamLike = function(stream) {
      return (typeof stream !== 'function')
        && (typeof stream !== 'string')
        && (typeof stream !== 'boolean')    
        && (typeof stream !== 'number')
        && (!Buffer.isBuffer(stream));
    };
    
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
    
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          stream.on('data', this._checkDataSize.bind(this));
    
          stream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams,
          });
        }
    
        this._handleErrors(stream);
    
        if (this.pauseStreams) {
          stream.pause();
        }
      }
    
      this._streams.push(stream);
      return this;
    };
    
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      var stream = this._streams.shift();
    
    
      if (typeof stream == 'undefined') {
        this.end();
        return;
      }
    
      if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
      }
    
      var getStream = stream;
      getStream(function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
          stream.on('data', this._checkDataSize.bind(this));
          this._handleErrors(stream);
        }
    
        this._pipeNext(stream);
      }.bind(this));
    };
    
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
    
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on('end', this._getNext.bind(this))
        stream.pipe(this, {end: false});
        return;
      }
    
      var value = stream;
      this.write(value);
      this._getNext();
    };
    
    CombinedStream.prototype._handleErrors = function(stream) {
      var self = this;
      stream.on('error', function(err) {
        self._emitError(err);
      });
    };
    
    CombinedStream.prototype.write = function(data) {
      this.emit('data', data);
    };
    
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
    
      this.emit('pause');
    };
    
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
    
      this.emit('resume');
    };
    
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit('end');
    };
    
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit('close');
    };
    
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
    
      var message =
        'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
      this._emitError(new Error(message));
    };
    
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
    
      var self = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
    
        self.dataSize += stream.dataSize;
      });
    
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit('error', err);
    };
    
  provide("combined-stream", module.exports);
}(global));

// pakmanager:mime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    
    function Mime() {
      // Map of extension -> mime type
      this.types = Object.create(null);
    
      // Map of mime type -> extension
      this.extensions = Object.create(null);
    }
    
    /**
     * Define mimetype -> extension mappings.  Each key is a mime-type that maps
     * to an array of extensions associated with the type.  The first extension is
     * used as the default extension for the type.
     *
     * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
     *
     * @param map (Object) type definitions
     */
    Mime.prototype.define = function (map) {
      for (var type in map) {
        var exts = map[type];
    
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts]) {
            console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
              this.types[exts] + ' to ' + type);
          }
    
          this.types[exts[i]] = type;
        }
    
        // Default extension is the first one we encounter
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    
    /**
     * Load an Apache2-style ".types" file
     *
     * This may be called multiple times (it's expected).  Where files declare
     * overlapping types/extensions, the last file wins.
     *
     * @param file (String) path of file to load.
     */
    Mime.prototype.load = function(file) {
    
      this._loading = file;
      // Read file and split into lines
      var map = {},
          content = fs.readFileSync(file, 'ascii'),
          lines = content.split(/[\r\n]+/);
    
      lines.forEach(function(line) {
        // Clean up whitespace/comments, and split into fields
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
        map[fields.shift()] = fields;
      });
    
      this.define(map);
    
      this._loading = null;
    };
    
    /**
     * Lookup a mime type based on extension
     */
    Mime.prototype.lookup = function(path, fallback) {
      var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
    
      return this.types[ext] || fallback || this.default_type;
    };
    
    /**
     * Return file extension associated with a mime type
     */
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    
    // Default instance
    var mime = new Mime();
    
    // Load local copy of
    // http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
    mime.load(path.join(__dirname, 'types/mime.types'));
    
    // Load additional types from node.js community
    mime.load(path.join(__dirname, 'types/node.types'));
    
    // Default type
    mime.default_type = mime.lookup('bin');
    
    //
    // Additional API specific to the default instance
    //
    
    mime.Mime = Mime;
    
    /**
     * Lookup a charset based on mime type.
     */
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        // Assume text types are utf8
        return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
      }
    };
    
    module.exports = mime;
    
  provide("mime", module.exports);
}(global));

// pakmanager:character-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports = (module.exports = parse);
    exports.parse = parse;
    function parse(src, state, options) {
      options = options || {};
      state = state || exports.defaultState();
      var start = options.start || 0;
      var end = options.end || src.length;
      var index = start;
      while (index < end) {
        if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {
          throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);
        }
        exports.parseChar(src[index++], state);
      }
      return state;
    }
    
    exports.parseMax = parseMax;
    function parseMax(src, options) {
      options = options || {};
      var start = options.start || 0;
      var index = start;
      var state = exports.defaultState();
      while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {
        if (index >= src.length) {
          throw new Error('The end of the string was reached with no closing bracket found.');
        }
        exports.parseChar(src[index++], state);
      }
      var end = index - 1;
      return {
        start: start,
        end: end,
        src: src.substring(start, end)
      };
    }
    
    exports.parseUntil = parseUntil;
    function parseUntil(src, delimiter, options) {
      options = options || {};
      var includeLineComment = options.includeLineComment || false;
      var start = options.start || 0;
      var index = start;
      var state = exports.defaultState();
      while (state.isString() || state.regexp || state.blockComment ||
             (!includeLineComment && state.lineComment) || !startsWith(src, delimiter, index)) {
        exports.parseChar(src[index++], state);
      }
      var end = index;
      return {
        start: start,
        end: end,
        src: src.substring(start, end)
      };
    }
    
    
    exports.parseChar = parseChar;
    function parseChar(character, state) {
      if (character.length !== 1) throw new Error('Character must be a string of length 1');
      state = state || exports.defaultState();
      state.src = state.src || '';
      state.src += character;
      var wasComment = state.blockComment || state.lineComment;
      var lastChar = state.history ? state.history[0] : '';
    
      if (state.regexpStart) {
        if (character === '/' || character == '*') {
          state.regexp = false;
        }
        state.regexpStart = false;
      }
      if (state.lineComment) {
        if (character === '\n') {
          state.lineComment = false;
        }
      } else if (state.blockComment) {
        if (state.lastChar === '*' && character === '/') {
          state.blockComment = false;
        }
      } else if (state.singleQuote) {
        if (character === '\'' && !state.escaped) {
          state.singleQuote = false;
        } else if (character === '\\' && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
      } else if (state.doubleQuote) {
        if (character === '"' && !state.escaped) {
          state.doubleQuote = false;
        } else if (character === '\\' && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
      } else if (state.regexp) {
        if (character === '/' && !state.escaped) {
          state.regexp = false;
        } else if (character === '\\' && !state.escaped) {
          state.escaped = true;
        } else {
          state.escaped = false;
        }
      } else if (lastChar === '/' && character === '/') {
        state.history = state.history.substr(1);
        state.lineComment = true;
      } else if (lastChar === '/' && character === '*') {
        state.history = state.history.substr(1);
        state.blockComment = true;
      } else if (character === '/' && isRegexp(state.history)) {
        state.regexp = true;
        state.regexpStart = true;
      } else if (character === '\'') {
        state.singleQuote = true;
      } else if (character === '"') {
        state.doubleQuote = true;
      } else if (character === '(') {
        state.roundDepth++;
      } else if (character === ')') {
        state.roundDepth--;
      } else if (character === '{') {
        state.curlyDepth++;
      } else if (character === '}') {
        state.curlyDepth--;
      } else if (character === '[') {
        state.squareDepth++;
      } else if (character === ']') {
        state.squareDepth--;
      }
      if (!state.blockComment && !state.lineComment && !wasComment) state.history = character + state.history;
      state.lastChar = character; // store last character for ending block comments
      return state;
    }
    
    exports.defaultState = function () { return new State() };
    function State() {
      this.lineComment = false;
      this.blockComment = false;
    
      this.singleQuote = false;
      this.doubleQuote = false;
      this.regexp = false;
    
      this.escaped = false;
    
      this.roundDepth = 0;
      this.curlyDepth = 0;
      this.squareDepth = 0;
    
      this.history = ''
      this.lastChar = ''
    }
    State.prototype.isString = function () {
      return this.singleQuote || this.doubleQuote;
    }
    State.prototype.isComment = function () {
      return this.lineComment || this.blockComment;
    }
    State.prototype.isNesting = function () {
      return this.isString() || this.isComment() || this.regexp || this.roundDepth > 0 || this.curlyDepth > 0 || this.squareDepth > 0
    }
    
    function startsWith(str, start, i) {
      return str.substr(i || 0, start.length) === start;
    }
    
    exports.isPunctuator = isPunctuator
    function isPunctuator(c) {
      if (!c) return true; // the start of a string is a punctuator
      var code = c.charCodeAt(0)
    
      switch (code) {
        case 46:   // . dot
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
        case 126:  // ~
        case 37:   // %
        case 38:   // &
        case 42:   // *:
        case 43:   // +
        case 45:   // -
        case 47:   // /
        case 60:   // <
        case 62:   // >
        case 94:   // ^
        case 124:  // |
        case 33:   // !
        case 61:   // =
          return true;
        default:
          return false;
      }
    }
    exports.isKeyword = isKeyword
    function isKeyword(id) {
      return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||
             (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||
             (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||
             (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||
             (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||
             (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||
             (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||
             (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static') ||
             (id === 'yield') || (id === 'let');
    }
    
    function isRegexp(history) {
      //could be start of regexp or divide sign
    
      history = history.replace(/^\s*/, '');
    
      //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide
      if (history[0] === ')') return false;
      //unless it's a function expression, it's a regexp, so we assume it's a regexp
      if (history[0] === '}') return true;
      //any punctuation means it's a regexp
      if (isPunctuator(history[0])) return true;
      //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)
      if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0].split('').reverse().join(''))) return true;
    
      return false;
    }
    
  provide("character-parser", module.exports);
}(global));

// pakmanager:commander
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var spawn = require('child_process').spawn;
    var path = require('path');
    var dirname = path.dirname;
    var basename = path.basename;
    
    /**
     * Expose the root command.
     */
    
    exports = module.exports = new Command();
    
    /**
     * Expose `Command`.
     */
    
    exports.Command = Command;
    
    /**
     * Expose `Option`.
     */
    
    exports.Option = Option;
    
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {String} flags
     * @param {String} description
     * @api public
     */
    
    function Option(flags, description) {
      this.flags = flags;
      this.required = ~flags.indexOf('<');
      this.optional = ~flags.indexOf('[');
      this.bool = !~flags.indexOf('-no-');
      flags = flags.split(/[ ,|]+/);
      if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
      this.long = flags.shift();
      this.description = description || '';
    }
    
    /**
     * Return option name.
     *
     * @return {String}
     * @api private
     */
    
    Option.prototype.name = function() {
      return this.long
        .replace('--', '')
        .replace('no-', '');
    };
    
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {String} arg
     * @return {Boolean}
     * @api private
     */
    
    Option.prototype.is = function(arg) {
      return arg == this.short || arg == this.long;
    };
    
    /**
     * Initialize a new `Command`.
     *
     * @param {String} name
     * @api public
     */
    
    function Command(name) {
      this.commands = [];
      this.options = [];
      this._execs = [];
      this._args = [];
      this._name = name;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Command.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Add command `name`.
     *
     * The `.action()` callback is invoked when the
     * command `name` is specified via __ARGV__,
     * and the remaining arguments are applied to the
     * function for access.
     *
     * When the `name` is "*" an un-matched command
     * will be passed as the first arg, followed by
     * the rest of __ARGV__ remaining.
     *
     * Examples:
     *
     *      program
     *        .version('0.0.1')
     *        .option('-C, --chdir <path>', 'change the working directory')
     *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
     *        .option('-T, --no-tests', 'ignore test hook')
     *
     *      program
     *        .command('setup')
     *        .description('run remote setup commands')
     *        .action(function() {
     *          console.log('setup');
     *        });
     *
     *      program
     *        .command('exec <cmd>')
     *        .description('run the given remote command')
     *        .action(function(cmd) {
     *          console.log('exec "%s"', cmd);
     *        });
     *
     *      program
     *        .command('teardown <dir> [otherDirs...]')
     *        .description('run teardown commands')
     *        .action(function(dir, otherDirs) {
     *          console.log('dir "%s"', dir);
     *          if (otherDirs) {
     *            otherDirs.forEach(function (oDir) {
     *              console.log('dir "%s"', oDir);
     *            });
     *          }
     *        });
     *
     *      program
     *        .command('*')
     *        .description('deploy the given env')
     *        .action(function(env) {
     *          console.log('deploying "%s"', env);
     *        });
     *
     *      program.parse(process.argv);
      *
     * @param {String} name
     * @param {String} [desc]
     * @return {Command} the new command
     * @api public
     */
    
    Command.prototype.command = function(name, desc) {
      var args = name.split(/ +/);
      var cmd = new Command(args.shift());
      if (desc) cmd.description(desc);
      if (desc) this.executables = true;
      if (desc) this._execs[cmd._name] = true;
      this.commands.push(cmd);
      cmd.parseExpectedArgs(args);
      cmd.parent = this;
      if (desc) return this;
      return cmd;
    };
    
    /**
     * Add an implicit `help [cmd]` subcommand
     * which invokes `--help` for the given command.
     *
     * @api private
     */
    
    Command.prototype.addImplicitHelpCommand = function() {
      this.command('help [cmd]', 'display help for [cmd]');
    };
    
    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parseExpectedArgs = function(args) {
      if (!args.length) return;
      var self = this;
      args.forEach(function(arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };
    
        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;
          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }
    
        if (argDetails.name.indexOf('...') === argDetails.name.length - 3) {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }
    
        if (argDetails.name) {
          self._args.push(argDetails);
        }
      });
      return this;
    };
    
    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.action = function(fn) {
      var self = this;
      var listener = function(args, unknown) {
        // Parse any so-far unknown options
        args = args || [];
        unknown = unknown || [];
    
        var parsed = self.parseOptions(unknown);
    
        // Output help if necessary
        outputHelpIfNecessary(self, parsed.unknown);
    
        // If there are still any unknown options, then we simply
        // die, unless someone asked for help, in which case we give it
        // to them, and then we die.
        if (parsed.unknown.length > 0) {
          self.unknownOption(parsed.unknown[0]);
        }
    
        // Leftover arguments need to be pushed back. Fixes issue #56
        if (parsed.args.length) args = parsed.args.concat(args);
    
        self._args.forEach(function(arg, i) {
          if (arg.required && null == args[i]) {
            self.missingArgument(arg.name);
          } else if (arg.variadic) {
            if (i !== self._args.length - 1) {
              self.variadicArgNotLast(arg.name);
            }
    
            args[i] = args.slice(i);
          }
        });
    
        // Always append ourselves to the end of the arguments,
        // to make sure we match the number of arguments the user
        // expects
        if (self._args.length) {
          args[self._args.length] = self;
        } else {
          args.push(self);
        }
    
        fn.apply(self, args);
      };
      this.parent.on(this._name, listener);
      if (this._alias) this.parent.on(this._alias, listener);
      return this;
    };
    
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to false
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     --pepper
     *     program.pepper
     *     // => Boolean
     *
     *     // simple boolean defaulting to true
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {String} flags
     * @param {String} description
     * @param {Function|Mixed} fn or default
     * @param {Mixed} defaultValue
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this
        , option = new Option(flags, description)
        , oname = option.name()
        , name = camelcase(oname);
    
      // default as 3rd arg
      if (typeof fn != 'function') {
        defaultValue = fn;
        fn = null;
      }
    
      // preassign default value only for --no-*, [optional], or <required>
      if (false == option.bool || option.optional || option.required) {
        // when --no-* we make sure default is true
        if (false == option.bool) defaultValue = true;
        // preassign only if we have a default
        if (undefined !== defaultValue) self[name] = defaultValue;
      }
    
      // register the option
      this.options.push(option);
    
      // when it's passed assign the value
      // and conditionally invoke the callback
      this.on(oname, function(val) {
        // coercion
        if (null !== val && fn) val = fn(val, undefined === self[name]
          ? defaultValue
          : self[name]);
    
        // unassigned or bool
        if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
          // if no value, bool true, and we have a default, then use it!
          if (null == val) {
            self[name] = option.bool
              ? defaultValue || true
              : false;
          } else {
            self[name] = val;
          }
        } else if (null !== val) {
          // reassign
          self[name] = val;
        }
      });
    
      return this;
    };
    
    /**
     * Parse `argv`, settings options and invoking commands when defined.
     *
     * @param {Array} argv
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parse = function(argv) {
      // implicit help
      if (this.executables) this.addImplicitHelpCommand();
    
      // store raw args
      this.rawArgs = argv;
    
      // guess name
      this._name = this._name || basename(argv[1], '.js');
    
      // process argv
      var parsed = this.parseOptions(this.normalize(argv.slice(2)));
      var args = this.args = parsed.args;
    
      var result = this.parseArgs(this.args, parsed.unknown);
    
      // executable sub-commands
      var name = result.args[0];
      if (this._execs[name] && typeof this._execs[name] != "function") {
        return this.executeSubCommand(argv, args, parsed.unknown);
      }
    
      return result;
    };
    
    /**
     * Execute a sub-command executable.
     *
     * @param {Array} argv
     * @param {Array} args
     * @param {Array} unknown
     * @api private
     */
    
    Command.prototype.executeSubCommand = function(argv, args, unknown) {
      args = args.concat(unknown);
    
      if (!args.length) this.help();
      if ('help' == args[0] && 1 == args.length) this.help();
    
      // <cmd> --help
      if ('help' == args[0]) {
        args[0] = args[1];
        args[1] = '--help';
      }
    
      // executable
      var dir = dirname(argv[1]);
      var bin = basename(argv[1], '.js') + '-' + args[0];
    
      // check for ./<bin> first
      var local = path.join(dir, bin);
    
      // run it
      args = args.slice(1);
      args.unshift(local);
      var proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
      proc.on('error', function(err) {
        if (err.code == "ENOENT") {
          console.error('\n  %s(1) does not exist, try --help\n', bin);
        } else if (err.code == "EACCES") {
          console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
        }
      });
    
      this.runningCommand = proc;
    };
    
    /**
     * Normalize `args`, splitting joined short flags. For example
     * the arg "-abc" is equivalent to "-a -b -c".
     * This also normalizes equal sign and splits "--abc=def" into "--abc def".
     *
     * @param {Array} args
     * @return {Array}
     * @api private
     */
    
    Command.prototype.normalize = function(args) {
      var ret = []
        , arg
        , lastOpt
        , index;
    
      for (var i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        if (i > 0) {
          lastOpt = this.optionFor(args[i-1]);
        }
    
        if (arg === '--') {
          // Honor option terminator
          ret = ret.concat(args.slice(i));
          break;
        } else if (lastOpt && lastOpt.required) {
          ret.push(arg);
        } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
          arg.slice(1).split('').forEach(function(c) {
            ret.push('-' + c);
          });
        } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
          ret.push(arg.slice(0, index), arg.slice(index + 1));
        } else {
          ret.push(arg);
        }
      }
    
      return ret;
    };
    
    /**
     * Parse command `args`.
     *
     * When listener(s) are available those
     * callbacks are invoked, otherwise the "*"
     * event is emitted and those actions are invoked.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api private
     */
    
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
    
      if (args.length) {
        name = args[0];
        if (this.listeners(name).length) {
          this.emit(args.shift(), args, unknown);
        } else {
          this.emit('*', args);
        }
      } else {
        outputHelpIfNecessary(this, unknown);
    
        // If there were no args and we have unknown options,
        // then they are extraneous and we need to error.
        if (unknown.length > 0) {
          this.unknownOption(unknown[0]);
        }
      }
    
      return this;
    };
    
    /**
     * Return an option matching `arg` if any.
     *
     * @param {String} arg
     * @return {Option}
     * @api private
     */
    
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i) {
        if (this.options[i].is(arg)) {
          return this.options[i];
        }
      }
    };
    
    /**
     * Parse options from `argv` returning `argv`
     * void of these options.
     *
     * @param {Array} argv
     * @return {Array}
     * @api public
     */
    
    Command.prototype.parseOptions = function(argv) {
      var args = []
        , len = argv.length
        , literal
        , option
        , arg;
    
      var unknownOptions = [];
    
      // parse options
      for (var i = 0; i < len; ++i) {
        arg = argv[i];
    
        // literal args after --
        if ('--' == arg) {
          literal = true;
          continue;
        }
    
        if (literal) {
          args.push(arg);
          continue;
        }
    
        // find matching Option
        option = this.optionFor(arg);
    
        // option is defined
        if (option) {
          // requires arg
          if (option.required) {
            arg = argv[++i];
            if (null == arg) return this.optionMissingArgument(option);
            this.emit(option.name(), arg);
          // optional arg
          } else if (option.optional) {
            arg = argv[i+1];
            if (null == arg || ('-' == arg[0] && '-' != arg)) {
              arg = null;
            } else {
              ++i;
            }
            this.emit(option.name(), arg);
          // bool
          } else {
            this.emit(option.name());
          }
          continue;
        }
    
        // looks like an option
        if (arg.length > 1 && '-' == arg[0]) {
          unknownOptions.push(arg);
    
          // If the next argument looks like it might be
          // an argument for this option, we pass it on.
          // If it isn't, then it'll simply be ignored
          if (argv[i+1] && '-' != argv[i+1][0]) {
            unknownOptions.push(argv[++i]);
          }
          continue;
        }
    
        // arg
        args.push(arg);
      }
    
      return { args: args, unknown: unknownOptions };
    };
    
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    Command.prototype.opts = function() {
      var result = {}
        , len = this.options.length;
    
      for (var i = 0 ; i < len; i++) {
        var key = this.options[i].name();
        result[key] = key === 'version' ? this._version : this[key];
      }
      return result;
    };
    
    /**
     * Argument `name` is missing.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.missingArgument = function(name) {
      console.error();
      console.error("  error: missing required argument `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {String} option
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.optionMissingArgument = function(option, flag) {
      console.error();
      if (flag) {
        console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
      } else {
        console.error("  error: option `%s' argument missing", option.flags);
      }
      console.error();
      process.exit(1);
    };
    
    /**
     * Unknown option `flag`.
     *
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.unknownOption = function(flag) {
      console.error();
      console.error("  error: unknown option `%s'", flag);
      console.error();
      process.exit(1);
    };
    
    /**
     * Variadic argument with `name` is not the last argument as required.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.variadicArgNotLast = function(name) {
      console.error();
      console.error("  error: variadic arguments must be last `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * @param {String} str
     * @param {String} flags
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.version = function(str, flags) {
      if (0 == arguments.length) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      this.option(flags, 'output the version number');
      this.on('version', function() {
        process.stdout.write(str + '\n');
        process.exit(0);
      });
      return this;
    };
    
    /**
     * Set the description to `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.description = function(str) {
      if (0 == arguments.length) return this._description;
      this._description = str;
      return this;
    };
    
    /**
     * Set an alias for the command
     *
     * @param {String} alias
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.alias = function(alias) {
      if (0 == arguments.length) return this._alias;
      this._alias = alias;
      return this;
    };
    
    /**
     * Set / get the command usage `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      });
    
      var usage = '[options]'
        + (this.commands.length ? ' [command]' : '')
        + (this._args.length ? ' ' + args.join(' ') : '');
    
      if (0 == arguments.length) return this._usage || usage;
      this._usage = str;
    
      return this;
    };
    
    /**
     * Get the name of the command
     *
     * @param {String} name
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.name = function(name) {
      return this._name;
    };
    
    /**
     * Return the largest option length.
     *
     * @return {Number}
     * @api private
     */
    
    Command.prototype.largestOptionLength = function() {
      return this.options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    
    /**
     * Return help for options.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.optionHelp = function() {
      var width = this.largestOptionLength();
    
      // Prepend the help information
      return [pad('-h, --help', width) + '  ' + 'output usage information']
        .concat(this.options.map(function(option) {
          return pad(option.flags, width) + '  ' + option.description;
          }))
        .join('\n');
    };
    
    /**
     * Return command help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.commandHelp = function() {
      if (!this.commands.length) return '';
    
      var commands = this.commands.map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(' ');
    
        return [
          cmd._name
            + (cmd._alias
              ? '|' + cmd._alias
              : '')
            + (cmd.options.length
              ? ' [options]'
              : '')
            + ' ' + args
        , cmd.description()
        ];
      });
    
      var width = commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    
      return [
          ''
        , '  Commands:'
        , ''
        , commands.map(function(cmd) {
          return pad(cmd[0], width) + '  ' + cmd[1];
        }).join('\n').replace(/^/gm, '    ')
        , ''
      ].join('\n');
    };
    
    /**
     * Return program help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.helpInformation = function() {
      return [
          ''
        , '  Usage: ' + this._name
            + (this._alias
              ? '|' + this._alias
              : '')
            + ' ' + this.usage()
        , '' + this.commandHelp()
        , '  Options:'
        , ''
        , '' + this.optionHelp().replace(/^/gm, '    ')
        , ''
        , ''
      ].join('\n');
    };
    
    /**
     * Output help information for this command
     *
     * @api public
     */
    
    Command.prototype.outputHelp = function() {
      process.stdout.write(this.helpInformation());
      this.emit('--help');
    };
    
    /**
     * Output help information and exit.
     *
     * @api public
     */
    
    Command.prototype.help = function() {
      this.outputHelp();
      process.exit();
    };
    
    /**
     * Camel-case the given `flag`
     *
     * @param {String} flag
     * @return {String}
     * @api private
     */
    
    function camelcase(flag) {
      return flag.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    
    /**
     * Pad `str` to `width`.
     *
     * @param {String} str
     * @param {Number} width
     * @return {String}
     * @api private
     */
    
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(' ');
    }
    
    /**
     * Output help information if necessary
     *
     * @param {Command} command to output help for
     * @param {Array} array of options to search for -h or --help
     * @api private
     */
    
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++) {
        if (options[i] == '--help' || options[i] == '-h') {
          cmd.outputHelp();
          process.exit(0);
        }
      }
    }
    
    /**
     * Takes an argument an returns its human readable equivalent for help usage.
     *
     * @param {Object} arg
     * @return {String}
     * @api private
     */
    
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
    
      return arg.required
        ? '<' + nameOutput + '>'
        : '[' + nameOutput + ']'
    }
    
  provide("commander", module.exports);
}(global));

// pakmanager:constantinople
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var detect = require('acorn-globals');
    
    var lastSRC = '(null)';
    var lastRes = true;
    var lastConstants = undefined;
    
    module.exports = isConstant;
    function isConstant(src, constants) {
      src = '(' + src + ')';
      if (lastSRC === src && lastConstants === constants) return lastRes;
      lastSRC = src;
      lastConstants = constants;
      try {
        isExpression(src);
        return lastRes = (detect(src).filter(function (key) {
          return !constants || !(key.name in constants);
        }).length === 0);
      } catch (ex) {
        return lastRes = false;
      }
    }
    isConstant.isConstant = isConstant;
    
    isConstant.toConstant = toConstant;
    function toConstant(src, constants) {
      if (!isConstant(src, constants)) throw new Error(JSON.stringify(src) + ' is not constant.');
      return Function(Object.keys(constants || {}).join(','), 'return (' + src + ')').apply(null, Object.keys(constants || {}).map(function (key) {
        return constants[key];
      }));
    }
    
    function isExpression(src) {
      try {
        eval('throw "STOP"; (function () { return (' + src + '); })()');
        return false;
      }
      catch (err) {
        return err === 'STOP';
      }
    }
    
  provide("constantinople", module.exports);
}(global));

// pakmanager:mkdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    
    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    
    function mkdirP (p, mode, f, made) {
        if (typeof mode === 'function' || mode === undefined) {
            f = mode;
            mode = 0777 & (~process.umask());
        }
        if (!made) made = null;
    
        var cb = f || function () {};
        if (typeof mode === 'string') mode = parseInt(mode, 8);
        p = path.resolve(p);
    
        fs.mkdir(p, mode, function (er) {
            if (!er) {
                made = made || p;
                return cb(null, made);
            }
            switch (er.code) {
                case 'ENOENT':
                    mkdirP(path.dirname(p), mode, function (er, made) {
                        if (er) cb(er, made);
                        else mkdirP(p, mode, cb, made);
                    });
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    fs.stat(p, function (er2, stat) {
                        // if the stat fails, then that's super weird.
                        // let the original error be the failure reason.
                        if (er2 || !stat.isDirectory()) cb(er, made)
                        else cb(null, made);
                    });
                    break;
            }
        });
    }
    
    mkdirP.sync = function sync (p, mode, made) {
        if (mode === undefined) {
            mode = 0777 & (~process.umask());
        }
        if (!made) made = null;
    
        if (typeof mode === 'string') mode = parseInt(mode, 8);
        p = path.resolve(p);
    
        try {
            fs.mkdirSync(p, mode);
            made = made || p;
        }
        catch (err0) {
            switch (err0.code) {
                case 'ENOENT' :
                    made = sync(path.dirname(p), mode, made);
                    sync(p, mode, made);
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    var stat;
                    try {
                        stat = fs.statSync(p);
                    }
                    catch (err1) {
                        throw err0;
                    }
                    if (!stat.isDirectory()) throw err0;
                    break;
            }
        }
    
        return made;
    };
    
  provide("mkdirp", module.exports);
}(global));

// pakmanager:monocle
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path        = require('path');
    var fs          = require('fs');
    var readdirp    = require('readdirp');
    var use_fs_watch  = process.platform === 'win32' || process.env.USE_FS_WATCH;
    
    module.exports = function() {
      var watched_files       = {};
      var watched_directories = {};
      var check_dir_pause     = 1000;
      var checkInterval       = undefined;
    
      // @api public
      // Watches the directory passed and its contained files
      // accepts args as an object.
    
      // @param root(string): the root directory to watch
      // @param fileFilter(array): ignore these files
      // @param directoryFilter(array): ignore these files
      // @param listener(fn(file)): on file change event this will be called
      // @param complete(fn): on complete of file watching setup
      function watchDirectory(args) {
        readdirp({ root: args.root, fileFilter: args.fileFilter, directoryFilter: args.directoryFilter }, function(err, res) {
          res.files.forEach(function(file) {
            watchFile(file, args.listener, args.partial);
          });
          typeof args.complete == "function" && args.complete();
        });
    
        !args.partial && (checkInterval = setInterval(function() {checkDirectory(args)}, check_dir_pause));
      }
    
      // @api public
      // Watches the files passed
      // accepts args as an object.
      // @param files(array): a list of files to watch
      // @param listener(fn(file)): on file change event this will be called
      // @param complete(fn): on complete of file watching setup
      function watchFiles(args) {
        args.files.forEach(function(file) {
          var o = {
                fullPath: fs.realpathSync(file),
                name: fs.realpathSync(file).split('/').pop()
              };
          o.fullParentDir = o.fullPath.split('/').slice(0, o.fullPath.split('/').length - 1).join('/')
    
          watchFile(o, args.listener);
        });
    
        typeof args.complete == "function" && args.complete();
      }
    
      function unwatchAll() {
        if (use_fs_watch) {
          Object.keys(watched_files).forEach(function(key) {
            watched_files[key].close();
          });
        } else {
          Object.keys(watched_files).forEach(function(key) {
            fs.unwatchFile(key);
          });
        }
    
        clearInterval(checkInterval);
        watched_files       = {};
        watched_directories = {};
      }
    
      // Checks to see if something in the directory has changed
      function checkDirectory(args) {
        Object.keys(watched_directories).forEach(function(path) {
          var lastModified = watched_directories[path];
          fs.stat(path, function(err, stats) {
            var stats_stamp = lastModified;
            if (!err) {
              stats_stamp = (new Date(stats.mtime)).getTime();
            }
            if (stats_stamp != lastModified) {
              watched_directories[path] = stats_stamp;
              watchDirectory({
                root: path,
                listener: args.listener,
                fileFilter: args.fileFilter,
                directoryFilter: args.directoryFilter,
                partial: true
              });
            }
          });
        });
      }
    
      // sets the absolute path to the file from the current working dir
      function setAbsolutePath(file) {
        file.absolutePath = path.resolve(process.cwd(), file.fullPath);
        return file.absolutePath;
      }
    
      // Watches the file passed and its containing directory
      // on change calls given listener with file object
      function watchFile(file, cb, partial) {
        setAbsolutePath(file);
        storeDirectory(file);
        if (!watched_files[file.fullPath]) {
          if (use_fs_watch) {
            (function() {
              watched_files[file.fullPath] = fs.watch(file.fullPath, function() {
                typeof cb === "function" && cb(file);
              });
              partial && cb(file);
            })(file, cb);
          } else {
            (function(file, cb) {
              watched_files[file.fullPath] = true;
              fs.watchFile(file.fullPath, {interval: 150}, function() {
                typeof cb === "function" && cb(file);
              });
              partial && cb(file);
            })(file, cb);
          }
        }
      }
    
      // Sets up a store of the folders being watched
      // and saves the last modification timestamp for it
      function storeDirectory(file) {
        var directory = file.fullParentDir;
        if (!watched_directories[directory]) {
          fs.stat(directory, function(err, stats) {
            if (err) {
              watched_directories[directory] = (new Date).getTime();
            } else {
              watched_directories[directory] = (new Date(stats.mtime)).getTime();
            }
          });
        }
      }
    
      // distinguish between files and directories
      // @returns {Object} contains directories and files array
    
      function distinguishPaths(paths) {
        paths = Array.isArray(paths) ? paths : [paths];
        var result = {
          directories: [],
          files: []
        };
        paths.forEach(function(name) {
          if (fs.statSync(name).isDirectory()) {
            result.directories.push(name);
          } else {
            result.files.push(name);
          }
        });
        return result;
      };
    
      // for functions accepts an object as paramter
      // copy the object and modify with attributes
      function extend(prototype, attributes) {
        var object = {};
        Object.keys(prototype).forEach(function(key) {
          object[key] = prototype[key];
        });
        Object.keys(attributes).forEach(function(key) {
          object[key] = attributes[key];
        });
        return object;
      };
    
      // watch files if the paths refer to files, or directories
      function watchPaths(args) {
        var result = distinguishPaths(args.path)
        if (result.directories.length) {
          result.directories.forEach(function(directory) {
            watchDirectory(extend(args, {root: directory}));
          });
        }
        if (result.files.length)
          watchFiles(extend(args, {files: result.files}));
      }
    
      return {
        watchDirectory: watchDirectory,
        watchFiles: watchFiles,
        watchPaths: watchPaths,
        unwatchAll: unwatchAll
      };
    }
    
  provide("monocle", module.exports);
}(global));

// pakmanager:transformers/lib/shared
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs = require('fs');
    var path = require('path');
    var normalize = path.normalize;
    var Promise = require('promise');
    var clone = require('clone');
    
    var minifiers = {};
    
    module.exports = Transformer;
    function Transformer(obj) {
      this.name = obj.name;
      this.engines = obj.engines;
      this.isBinary = obj.isBinary || false;
      this.isMinifier = obj.isMinifier || false;
      this.outputFormat = obj.outputFormat;
      this._cache = {};
      if (typeof obj.async === 'function') {
        this._renderAsync = obj.async;
        this.sudoSync = obj.sudoSync || false;
      }
      if (typeof obj.sync === 'function') {
        this._renderSync = obj.sync;
        this.sync = true;
      } else {
        this.sync = obj.sudoSync || false;
      }
    
      if (this.isMinifier)
        minifiers[this.outputFormat] = this;
      else {
        var minifier = minifiers[this.outputFormat];
        if (minifier) {
          this.minify = function(str, options) {
            if (options && options.minify)
              return minifier.renderSync(str, typeof options.minify === 'object' && options.minify || {});
            return str;
          };
        }
      }
    }
    
    Transformer.prototype.cache = function (options, data) {
      if (options.cache && options.filename) {
        if (data) return this.cache[options.filename] = data;
        else return this.cache[options.filename];
      } else {
        return data;
      }
    };
    Transformer.prototype.loadModule = function () {
      if (this.engine) return this.engine;
      for (var i = 0; i < this.engines.length; i++) {
        try {
          var res = this.engines[i] === '.' ? null : (this.engine = require(this.engines[i]));
          this.engineName = this.engines[i];
          return res;
        } catch (ex) {
          if (this.engines.length === 1) {
            throw ex;
          }
        }
      }
      throw new Error('In order to apply the transform ' + this.name + ' you must install one of ' + this.engines.map(function (e) { return '"' + e + '"'; }).join());
    };
    Transformer.prototype.minify = function(str, options) {
      return str;
    };
    Transformer.prototype.renderSync = function (str, options) {
      options = options || {};
      options = clone(options);
      this.loadModule();
      if (this._renderSync) {
        return this.minify(this._renderSync((this.isBinary ? str : fixString(str)), options), options);
      } else if (this.sudoSync) {
        options.sudoSync = true;
        var res, err;
        this._renderAsync((this.isBinary ? str : fixString(str)), options, function (e, val) {
          if (e) err = e;
          else res = val;
        });
        if (err) throw err;
        else if (res !== undefined) return this.minify(res, options);
        else if (typeof this.sudoSync === 'string') throw new Error(this.sudoSync.replace(/FILENAME/g, options.filename || ''));
        else throw new Error('There was a problem transforming ' + (options.filename || '') + ' synchronously using ' + this.name);
      } else {
        throw new Error(this.name + ' does not support transforming synchronously.');
      }
    };
    Transformer.prototype.render = function (str, options, cb) {
      options = options || {};
      var self = this;
      return new Promise(function (resolve, reject) {
        self.loadModule();
        if (self._renderAsync) {
          self._renderAsync((self.isBinary ? str : fixString(str)), clone(options), function (err, val) {
            if (err) reject(err);
            else resolve(self.minify(val, options));
          });
        } else {
          resolve(self.renderSync(str, options));
        }
      })
      .nodeify(cb);
    };
    Transformer.prototype.renderFile = function (path, options, cb) {
      options = options || {};
      var self = this;
      return new Promise(function (resolve, reject) {
        options.filename = (path = normalize(path));
        if (self._cache[path])
          resolve(null);
        else
          fs.readFile(path, function (err, data) {
            if (err) reject(err);
            else resolve(data);
          });
      })
      .then(function (str) {
        return self.render(str, options);
      })
      .nodeify(cb);
    };
    Transformer.prototype.renderFileSync = function (path, options) {
      options = options || {};
      options.filename = (path = normalize(path));
      return this.renderSync((this._cache[path] ? null : fs.readFileSync(path)), options);
    };
    function fixString(str) {
      if (str === null) return str;
      //convert buffer to string
      str = str.toString();
      // Strip UTF-8 BOM if it exists
      str = (0xFEFF === str.charCodeAt(0) ? str.substring(1) : str);
      //remove `\r` added by windows
      return str.replace(/\r/g, '');
    }
    
  provide("transformers/lib/shared", module.exports);
}(global));

// pakmanager:transformers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var dirname = require('path').dirname;
    var clone = require('clone');
    var Transformer =  require('transformers/lib/shared');
    
    /**
     * minifiers must be first in order to be incorporated inside instances of
     * respective output formats
     */
    
    var uglifyJS = require('uglify-js');
    exports.uglify = exports.uglifyJS = exports['uglify-js'] = new Transformer({
      name: 'uglify-js',
      engines: ['.'],
      outputFormat: 'js',
      isMinifier: true,
      sync: function (str, options) {
        options.fromString = true;
        return this.cache(options) || this.cache(options, uglifyJS.minify(str, options).code);
      }
    });
    
    var uglifyCSS = require('css');
    exports.uglifyCSS = exports['uglify-css'] = new Transformer({
      name: 'uglify-css',
      engines: ['.'],
      outputFormat: 'css',
      isMinifier: true,
      sync: function (str, options) {
        options.compress = options.compress !== false && options.beautify !== true;
        return this.cache(options) || this.cache(options, uglifyCSS.stringify(uglifyCSS.parse(str), options));
      }
    });
    
    exports.uglifyJSON = exports['uglify-json'] = new Transformer({
      name: 'uglify-json',
      engines: ['.'],
      outputFormat: 'json',
      isMinifier: true,
      sync: function (str, options) {
        return JSON.stringify(JSON.parse(str), null, options.beautify);
      }
    });
    
    /**
     * Synchronous Templating Languages
     */
    
    function sync(str, options) {
      var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
      return tmpl(options);
    }
    
    exports.live = exports.LiveScript = exports.ls = exports.livescript = new Transformer({
      name: 'LiveScript',
      engines: ['LiveScript'],
      outputFormat: 'js',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, this.engine.compile(str, options));
      }
    });
    
    exports.swig = new Transformer({
      name: 'swig',
      engines: ['swig'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.atpl = new Transformer({
      name: 'atpl',
      engines: ['atpl'],
      outputFormat: 'xml',
      sync: function sync(str, options) {
        var tmpl = this.cache(options);
        if (!tmpl) {
          var cInfo = {cache: options.cache, filename: options.filename};
          if (options.filename) {
            delete options.filename; //atpl can't handle absolute windows file paths properly
          }
          tmpl = this.cache(cInfo, this.engine.compile(str, options));
        }
        return tmpl(options);
      }
    });
    
    exports.dot = new Transformer({
      name: 'dot',
      engines: ['dot'],
      outputFormat: 'xml',
      sync: function sync(str, options) {
        var tmpl = this.cache(options) || this.cache(options, this.engine.template(str));
        return tmpl(options);
      }
    });
    
    exports.liquor = new Transformer({
      name: 'liquor',
      engines: ['liquor'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.ejs = new Transformer({
      name: 'ejs',
      engines: ['ejs'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.eco = new Transformer({
      name: 'eco',
      engines: ['eco'],
      outputFormat: 'xml',
      sync: sync//N.B. eco's internal this.cache isn't quite right but this bypasses it
    });
    
    exports.jqtpl = new Transformer({
      name: 'jqtpl',
      engines: ['jqtpl'],
      outputFormat: 'xml',
      sync: function (str, options) {
        var engine = this.engine;
        var key = (options.cache && options.filename) ? options.filename : '@';
        engine.compile(str, key);
        var res = this.engine.render(key, options);
        if (!(options.cache && options.filename)) {
          delete engine.cache[key];
        }
        this.cache(options, true); // caching handled internally
        return res;
      }
    });
    
    exports.haml = new Transformer({
      name: 'haml',
      engines: ['hamljs'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports['haml-coffee'] = new Transformer({
      name: 'haml-coffee',
      engines: ['haml-coffee'],
      outputFormat: 'xml',
      sync: function (str, options) {
        // https://github.com/netzpirat/haml-coffee/issues/91
        if (global.CoffeeScript) delete global.CoffeeScript; //prevent global leak
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return tmpl(options);
      }
    });
    
    exports.whiskers = new Transformer({
      name: 'whiskers',
      engines: ['whiskers'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.hogan = new Transformer({
      name: 'hogan',
      engines: ['hogan.js'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return tmpl.render(options, options.partials);
      }
    });
    
    exports.handlebars = new Transformer({
      name: 'handlebars',
      engines: ['handlebars'],
      outputFormat: 'xml',
      sync: function(str, options){
        for (var partial in options.partials) {
          this.engine.registerPartial(partial, options.partials[partial]);
        }
        for (var helper in options.helpers) {
          this.engine.registerHelper(helper, options.helpers[helper]);
        }
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return tmpl(options);
      }
    });
    
    exports.underscore = new Transformer({
      name: 'underscore',
      engines: ['underscore'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine.template(str));
        return tmpl(options);
      }
    });
    
    exports.walrus = new Transformer({
      name: 'walrus',
      engines: ['walrus'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine.parse(str));
        return tmpl.compile(options);
      }
    });
    
    exports.mustache = new Transformer({
      name: 'mustache',
      engines: ['mustache'],
      outputFormat: 'xml',
      sync: function(str, options){
        str = this.cache(options) || this.cache(options, str);
        return this.engine.to_html(str, options, options.partials);
      }
    });
    
    exports.templayed = new Transformer({
      name: 'templayed',
      engines: ['templayed'],
      outputFormat: 'xml',
      sync: function(str, options){
        var tmpl = this.cache(options) || this.cache(options, this.engine(str));
        return tmpl(options);
      }
    });
    
    exports.plates = new Transformer({
      name: 'plates',
      engines: ['plates'],
      outputFormat: 'xml',
      sync: function(str, options){
        str = this.cache(options) || this.cache(options, str);
        return this.engine.bind(str, options, options.map);
      }
    });
    
    exports.mote = new Transformer({
      name: 'mote',
      engines: ['mote'],
      outputFormat: 'xml',
      sync: sync
    });
    
    exports.toffee = new Transformer({
      name: 'toffee',
      engines: ['toffee'],
      outputFormat: 'xml',
      sync: function (str, options) {
        var View = this.engine.view;
        var v = this.cache(options) || this.cache(options, new View(str, options));
        var res = v.run(options, require('vm').createContext({}));
        if (res[0]) throw res[0];
        else return res[1];
      }
    });
    
    exports.coffeekup = exports.coffeecup = new Transformer({
      name: 'coffeecup',
      engines: ['coffeecup', 'coffeekup'],
      outputFormat: 'xml',
      sync: function (str, options) {
        var compiled = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        return compiled(options);
      }
    });
    
    /**
     * Asynchronous Templating Languages
     */
    
    exports.just = new Transformer({
      name: 'just',
      engines: ['just'],
      outputFormat: 'xml',
      sudoSync: true,
      async: function (str, options, cb) {
        var JUST = this.engine;
        var tmpl = this.cache(options) || this.cache(options, new JUST({ root: { page: str }}));
        tmpl.render('page', options, cb);
      }
    });
    
    exports.ect = new Transformer({
      name: 'ect',
      engines: ['ect'],
      outputFormat: 'xml',
      sudoSync: true, // Always runs synchronously
      async: function (str, options, cb) {
        var ECT = this.engine;
        var tmpl = this.cache(options) || this.cache(options, new ECT({ root: { page: str }}));
        tmpl.render('page', options, cb);
      }
    });
    
    exports.jade = new Transformer({
      name: 'jade',
      engines: ['jade', 'then-jade'],
      outputFormat: 'xml',
      sudoSync: 'The jade file FILENAME could not be rendered synchronously.  N.B. then-jade does not support synchronous rendering.',
      async: function (str, options, cb) {
        this.cache(options, true);//jade handles this.cache internally
        this.engine.render(str, options, cb);
      }
    });
    
    exports.dust = new Transformer({
      name: 'dust',
      engines: ['dust', 'dustjs-linkedin'],
      outputFormat: 'xml',
      sudoSync: false,
      async: function (str, options, cb) {
        var ext = 'dust',
            views = '.';
    
        if (options) {
          if (options.ext) ext = options.ext;
          if (options.views) views = options.views;
          if (options.settings && options.settings.views) views = options.settings.views;
        }
    
        this.engine.onLoad = function(path, callback){
          if ('' === extname(path)) path += '.' + ext;
          if ('/' !== path[0]) path = views + '/' + path;
          read(path, options, callback);
        };
    
        var tmpl = this.cache(options) || this.cache(options, this.engine.compileFn(str));
        if (options && !options.cache) this.engine.cache = {};//invalidate dust's internal cache
        tmpl(options, cb);
      }
    });
    
    exports.jazz = new Transformer({
      name: 'jazz',
      engines: ['jazz'],
      outputFormat: 'xml',
      sudoSync: true, // except when an async function is passed to locals
      async: function (str, options, cb) {
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        tmpl.eval(options, function(str){
          cb(null, str);
        });
      }
    });
    
    exports.qejs = new Transformer({
      name: 'qejs',
      engines: ['qejs'],
      outputFormat: 'xml',
      sudoSync: false,
      async: function (str, options, cb) {
        var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
        tmpl(options).done(function (result) {
            cb(null, result);
        }, function (err) {
            cb(err);
        });
      }
    });
    
    /**
     * Stylesheet Languages
     */
    
    exports.less = new Transformer({
      name: 'less',
      engines: ['less'],
      outputFormat: 'css',
      sudoSync: 'The less file FILENAME could not be rendered synchronously.  This is usually because the file contains `@import url` statements.',
      async: function (str, options, cb) {
        var self = this;
        if (self.cache(options)) return cb(null, self.cache(options));
        if (options.filename) {
          options.paths = options.paths || [dirname(options.filename)];
        }
        //If this.cache is enabled, compress by default
        if (options.compress !== true && options.compress !== false) {
          options.compress = options.cache || false;
        }
        if (options.sudoSync) {
          options.syncImport = true;
        }
        var parser = new(this.engine.Parser)(options);
        parser.parse(str, function (err, tree) {
          try {
            if (err) throw err;
            var res = tree.toCSS(options);
            self.cache(options, res);
            cb(null, res);
          } catch (ex) {
            if (ex.constructor.name === 'LessError' && typeof ex === 'object') {
              ex.filename = ex.filename || '"Unkown Source"';
              var err = new Error(self.engine.formatError(ex, options).replace(/^[^:]+:/, ''), ex.filename, ex.line);
              err.name = ex.type;
              ex = err;
            }
            return cb(ex);
          }
        });
      }
    });
    
    exports.styl = exports.stylus = new Transformer({
      name: 'stylus',
      engines: ['stylus'],
      outputFormat: 'css',
      sudoSync: true,// always runs synchronously
      async: function (str, options, cb) {
        var self = this;
        if (self.cache(options)) return cb(null, self.cache(options));
        if (options.filename) {
          options.paths = options.paths || [dirname(options.filename)];
        }
    
        // If this.cache is enabled, compress by default
        if (options.compress !== true && options.compress !== false) {
          options.compress = options.cache || false;
        }
    
        var initial = this.engine(str);
    
        // Special handling for stylus js api functions
        // given { define: { foo: 'bar', baz: 'quux' } }
        // runs initial.define('foo', 'bar').define('baz', 'quux')
    
        var allowed = ['set', 'include', 'import', 'define', 'use'];
        var special = {}
        var normal = clone(options);
        for (var v in options) {
          if (allowed.indexOf(v) > -1) { special[v] = options[v]; delete normal[v]; }
        }
    
        // special options through their function names
        for (var k in special) {
          for (var v in special[k]) { initial[k](v, special[k][v]); }
        }
    
        // normal options through set()
        for (var k in normal) {
          for (var v in normal[k]) { initial['set'](v, normal[k][v]); }
        }
    
        initial.render(function (err, res) {
          if (err) return cb(err);
          self.cache(options, res);
          cb(null, res);
        });
      }
    });
    
    exports.sass = new Transformer({
      name: 'sass',
      engines: ['sass'],
      outputFormat: 'css',
      sync: function (str, options) {
        try {
          return this.cache(options) || this.cache(options, this.engine.render(str));
        } catch (ex) {
          if (options.filename) ex.message += ' in ' + options.filename;
          throw ex;
        }
      }
    });
    
    /**
     * Miscellaneous
     */
    
    exports.md = exports.markdown = new Transformer({
      name: 'markdown',
      engines: ['marked', 'supermarked', 'markdown-js', 'markdown'],
      outputFormat: 'html',
      sync: function (str, options) {
        var arg = options;
        if (this.engineName === 'markdown') arg = options.dialect; //even if undefined
        return this.cache(options) || this.cache(options, this.engine.parse(str, arg));
      }
    });
    
    exports.coffee = exports['coffee-script'] = exports.coffeescript = exports.coffeeScript = new Transformer({
      name: 'coffee-script',
      engines: ['coffee-script'],
      outputFormat: 'js',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, this.engine.compile(str, options));
      }
    });
    
    exports.cson = new Transformer({
      name: 'cson',
      engines: ['cson'],
      outputFormat: 'json',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, JSON.stringify(this.engine.parseSync(str)));
      }
    });
    
    exports.cdata = new Transformer({
      name: 'cdata',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/\]\]>/g, "]]]]><![CDATA[>");
        return this.cache(options) || this.cache(options, '<![CDATA[' + escaped + ']]>');
      }
    });
    
    exports["cdata-js"] = new Transformer({
      name: 'cdata-js',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/\]\]>/g, "]]]]><![CDATA[>");
        return this.cache(options) || this.cache(options, '//<![CDATA[\n' + escaped + '\n//]]>');
      }
    });
    
    exports["cdata-css"] = new Transformer({
      name: 'cdata-css',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/\]\]>/g, "]]]]><![CDATA[>");
        return this.cache(options) || this.cache(options, '/*<![CDATA[*/\n' + escaped + '\n/*]]>*/');
      }
    });
    
    exports.verbatim = new Transformer({
      name: 'verbatim',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, str);
      }
    });
    
    exports["escape-html"] = new Transformer({
      name: 'escape-html',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'xml',
      sync: function (str, options) {
        var escaped = str.replace(/&/g, '&amp;')
                         .replace(/</g, '&lt;')
                         .replace(/>/g, '&gt;')
                         .replace(/"/g, '&quot;')
                         .replace(/'/g, '&#x27;');
    
        return this.cache(options) || this.cache(options, escaped);
      }
    });
    
    exports['highlight'] = new Transformer({
      name: 'highlight',
      engines: ['highlight.js'],
      outputFormat: 'xml',
      sync: function (str, options, cb) {
        if (this.cache(options)) return this.cache(options);
        if (options.lang) {
          try {
            return this.cache(options, this.engine.highlight(options.lang, str).value);
          } catch (ex) {}
        }
        if (options.auto || !options.lang) {
          try {
            return this.cache(options, this.engine.highlightAuto(str).value);
          } catch (ex) {}
        }
        return this.cache(options, str);
      }
    });
    
    /**
     * Marker transformers (they don't actually apply a transformation, but let you declare the 'outputFormat')
     */
    
    exports.css = new Transformer({
      name: 'css',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'css',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, str);
      }
    });
    
    exports.js = new Transformer({
      name: 'js',
      engines: ['.'],// `.` means "no dependency"
      outputFormat: 'js',
      sync: function (str, options) {
        return this.cache(options) || this.cache(options, str);
      }
    });
    
  provide("transformers", module.exports);
}(global));

// pakmanager:void-elements
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * This file automatically generated from `build.js`.
     * Do not manually edit.
     */
    
    module.exports = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    
  provide("void-elements", module.exports);
}(global));

// pakmanager:with
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var detect = require('acorn-globals');
    var acorn = require('acorn');
    var walk = require('acorn/util/walk');
    
    module.exports = addWith
    
    /**
     * Mimic `with` as far as possible but at compile time
     *
     * @param {String} obj The object part of a with expression
     * @param {String} src The body of the with expression
     * @param {Array.<String>} exclude A list of variable names to explicitly exclude
     */
    function addWith(obj, src, exclude) {
      obj = obj + ''
      src = src + ''
      exclude = exclude || []
      exclude = exclude.concat(detect(obj).map(function (global) { return global.name; }))
      var vars = detect(src).map(function (global) { return global.name; })
        .filter(function (v) {
          return exclude.indexOf(v) === -1
        })
    
      if (vars.length === 0) return src
    
      var declareLocal = ''
      var local = 'locals_for_with'
      var result = 'result_of_with'
      if (/^[a-zA-Z0-9$_]+$/.test(obj)) {
        local = obj
      } else {
        while (vars.indexOf(local) != -1 || exclude.indexOf(local) != -1) {
          local += '_'
        }
        declareLocal = 'var ' + local + ' = (' + obj + ')'
      }
      while (vars.indexOf(result) != -1 || exclude.indexOf(result) != -1) {
        result += '_'
      }
    
      var inputVars = vars.map(function (v) {
        return JSON.stringify(v) + ' in ' + local + '?' +
          local + '.' + v + ':' +
          'typeof ' + v + '!=="undefined"?' + v + ':undefined'
      })
    
      src = '(function (' + vars.join(', ') + ') {' +
        src +
        '}.call(this' + inputVars.map(function (v) { return ',' + v; }).join('') + '))'
    
      return ';' + declareLocal + ';' + unwrapReturns(src, result) + ';'
    }
    
    /**
     * Take a self calling function, and unwrap it such that return inside the function
     * results in return outside the function
     *
     * @param {String} src    Some JavaScript code representing a self-calling function
     * @param {String} result A temporary variable to store the result in
     */
    function unwrapReturns(src, result) {
      var originalSource = src
      var hasReturn = false
      var ast = acorn.parse(src, {ecmaVersion: 6})
      var ref
      src = src.split('')
    
      // get a reference to the function that was inserted to add an inner context
      if ((ref = ast.body).length !== 1
       || (ref = ref[0]).type !== 'ExpressionStatement'
       || (ref = ref.expression).type !== 'CallExpression'
       || (ref = ref.callee).type !== 'MemberExpression' || ref.computed !== false || ref.property.name !== 'call'
       || (ref = ref.object).type !== 'FunctionExpression')
        throw new Error('AST does not seem to represent a self-calling function')
      var fn = ref
    
      walk.recursive(ast, null, {
        Function: function (node, st, c) {
          if (node === fn) {
            c(node.body, st, "ScopeBody");
          }
        },
        ReturnStatement: function (node) {
          hasReturn = true
          replace(node, 'return {value: ' + source(node.argument) + '};');
        }
      });
      function source(node) {
        return src.slice(node.start, node.end).join('')
      }
      function replace(node, str) {
        for (var i = node.start; i < node.end; i++) {
          src[i] = ''
        }
        src[node.start] = str
      }
      if (!hasReturn) return originalSource
      else return 'var ' + result + '=' + src.join('') + ';if (' + result + ') return ' + result + '.value'
    }
    
  provide("with", module.exports);
}(global));

// pakmanager:once
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    module.exports = wrappy(once)
    
    once.proto = once(function () {
      Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return once(this)
        },
        configurable: true
      })
    })
    
    function once (fn) {
      var f = function () {
        if (f.called) return f.value
        f.called = true
        return f.value = fn.apply(this, arguments)
      }
      f.called = false
      return f
    }
    
  provide("once", module.exports);
}(global));

// pakmanager:sax
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // wrapper for non-node envs
    ;(function (sax) {
    
    sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
    sax.SAXParser = SAXParser
    sax.SAXStream = SAXStream
    sax.createStream = createStream
    
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 64 * 1024
    
    var buffers = [
      "comment", "sgmlDecl", "textNode", "tagName", "doctype",
      "procInstName", "procInstBody", "entity", "attribName",
      "attribValue", "cdata", "script"
    ]
    
    sax.EVENTS = // for discoverability.
      [ "text"
      , "processinginstruction"
      , "sgmldeclaration"
      , "doctype"
      , "comment"
      , "attribute"
      , "opentag"
      , "closetag"
      , "opencdata"
      , "cdata"
      , "closecdata"
      , "error"
      , "end"
      , "ready"
      , "script"
      , "opennamespace"
      , "closenamespace"
      ]
    
    function SAXParser (strict, opt) {
      if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)
    
      var parser = this
      clearBuffers(parser)
      parser.q = parser.c = ""
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
      parser.opt = opt || {}
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
      parser.tags = []
      parser.closed = parser.closedRoot = parser.sawRoot = false
      parser.tag = parser.error = null
      parser.strict = !!strict
      parser.noscript = !!(strict || parser.opt.noscript)
      parser.state = S.BEGIN
      parser.ENTITIES = Object.create(sax.ENTITIES)
      parser.attribList = []
    
      // namespaces form a prototype chain.
      // it always points at the current tag,
      // which protos to its parent tag.
      if (parser.opt.xmlns) parser.ns = Object.create(rootNS)
    
      // mostly just for error reporting
      parser.trackPosition = parser.opt.position !== false
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0
      }
      emit(parser, "onready")
    }
    
    if (!Object.create) Object.create = function (o) {
      function f () { this.__proto__ = o }
      f.prototype = o
      return new f
    }
    
    if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
      return o.__proto__
    }
    
    if (!Object.keys) Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
    
    function checkBufferLength (parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
        , maxActual = 0
      for (var i = 0, l = buffers.length; i < l; i ++) {
        var len = parser[buffers[i]].length
        if (len > maxAllowed) {
          // Text/cdata nodes can get big, and since they're buffered,
          // we can get here under normal conditions.
          // Avoid issues by emitting the text node now,
          // so at least it won't get any bigger.
          switch (buffers[i]) {
            case "textNode":
              closeText(parser)
            break
    
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata)
              parser.cdata = ""
            break
    
            case "script":
              emitNode(parser, "onscript", parser.script)
              parser.script = ""
            break
    
            default:
              error(parser, "Max buffer length exceeded: "+buffers[i])
          }
        }
        maxActual = Math.max(maxActual, len)
      }
      // schedule the next check for the earliest possible buffer overrun.
      parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
                                 + parser.position
    }
    
    function clearBuffers (parser) {
      for (var i = 0, l = buffers.length; i < l; i ++) {
        parser[buffers[i]] = ""
      }
    }
    
    function flushBuffers (parser) {
      closeText(parser)
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata)
        parser.cdata = ""
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script)
        parser.script = ""
      }
    }
    
    SAXParser.prototype =
      { end: function () { end(this) }
      , write: write
      , resume: function () { this.error = null; return this }
      , close: function () { return this.write(null) }
      , flush: function () { flushBuffers(this) }
      }
    
    try {
      var Stream = require("stream").Stream
    } catch (ex) {
      var Stream = function () {}
    }
    
    
    var streamWraps = sax.EVENTS.filter(function (ev) {
      return ev !== "error" && ev !== "end"
    })
    
    function createStream (strict, opt) {
      return new SAXStream(strict, opt)
    }
    
    function SAXStream (strict, opt) {
      if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)
    
      Stream.apply(this)
    
      this._parser = new SAXParser(strict, opt)
      this.writable = true
      this.readable = true
    
    
      var me = this
    
      this._parser.onend = function () {
        me.emit("end")
      }
    
      this._parser.onerror = function (er) {
        me.emit("error", er)
    
        // if didn't throw, then means error was handled.
        // go ahead and clear error, so we can write again.
        me._parser.error = null
      }
    
      this._decoder = null;
    
      streamWraps.forEach(function (ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function () { return me._parser["on" + ev] },
          set: function (h) {
            if (!h) {
              me.removeAllListeners(ev)
              return me._parser["on"+ev] = h
            }
            me.on(ev, h)
          },
          enumerable: true,
          configurable: false
        })
      })
    }
    
    SAXStream.prototype = Object.create(Stream.prototype,
      { constructor: { value: SAXStream } })
    
    SAXStream.prototype.write = function (data) {
      if (typeof Buffer === 'function' &&
          typeof Buffer.isBuffer === 'function' &&
          Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require('string_decoder').StringDecoder
          this._decoder = new SD('utf8')
        }
        data = this._decoder.write(data);
      }
    
      this._parser.write(data.toString())
      this.emit("data", data)
      return true
    }
    
    SAXStream.prototype.end = function (chunk) {
      if (chunk && chunk.length) this.write(chunk)
      this._parser.end()
      return true
    }
    
    SAXStream.prototype.on = function (ev, handler) {
      var me = this
      if (!me._parser["on"+ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on"+ev] = function () {
          var args = arguments.length === 1 ? [arguments[0]]
                   : Array.apply(null, arguments)
          args.splice(0, 0, ev)
          me.emit.apply(me, args)
        }
      }
    
      return Stream.prototype.on.call(me, ev, handler)
    }
    
    
    
    // character classes and tokens
    var whitespace = "\r\n\t "
      // this really needs to be replaced with character classes.
      // XML allows all manner of ridiculous numbers and digits.
      , number = "0124356789"
      , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
      // (Letter | "_" | ":")
      , quote = "'\""
      , entity = number+letter+"#"
      , attribEnd = whitespace + ">"
      , CDATA = "[CDATA["
      , DOCTYPE = "DOCTYPE"
      , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
      , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
      , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }
    
    // turn all the string character sets into character class objects.
    whitespace = charClass(whitespace)
    number = charClass(number)
    letter = charClass(letter)
    
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
    
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/
    
    quote = charClass(quote)
    entity = charClass(entity)
    attribEnd = charClass(attribEnd)
    
    function charClass (str) {
      return str.split("").reduce(function (s, c) {
        s[c] = true
        return s
      }, {})
    }
    
    function isRegExp (c) {
      return Object.prototype.toString.call(c) === '[object RegExp]'
    }
    
    function is (charclass, c) {
      return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
    }
    
    function not (charclass, c) {
      return !is(charclass, c)
    }
    
    var S = 0
    sax.STATE =
    { BEGIN                     : S++
    , TEXT                      : S++ // general stuff
    , TEXT_ENTITY               : S++ // &amp and such.
    , OPEN_WAKA                 : S++ // <
    , SGML_DECL                 : S++ // <!BLARG
    , SGML_DECL_QUOTED          : S++ // <!BLARG foo "bar
    , DOCTYPE                   : S++ // <!DOCTYPE
    , DOCTYPE_QUOTED            : S++ // <!DOCTYPE "//blah
    , DOCTYPE_DTD               : S++ // <!DOCTYPE "//blah" [ ...
    , DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE "//blah" [ "foo
    , COMMENT_STARTING          : S++ // <!-
    , COMMENT                   : S++ // <!--
    , COMMENT_ENDING            : S++ // <!-- blah -
    , COMMENT_ENDED             : S++ // <!-- blah --
    , CDATA                     : S++ // <![CDATA[ something
    , CDATA_ENDING              : S++ // ]
    , CDATA_ENDING_2            : S++ // ]]
    , PROC_INST                 : S++ // <?hi
    , PROC_INST_BODY            : S++ // <?hi there
    , PROC_INST_ENDING          : S++ // <?hi "there" ?
    , OPEN_TAG                  : S++ // <strong
    , OPEN_TAG_SLASH            : S++ // <strong /
    , ATTRIB                    : S++ // <a
    , ATTRIB_NAME               : S++ // <a foo
    , ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _
    , ATTRIB_VALUE              : S++ // <a foo=
    , ATTRIB_VALUE_QUOTED       : S++ // <a foo="bar
    , ATTRIB_VALUE_CLOSED       : S++ // <a foo="bar"
    , ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar
    , ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar="&quot;"
    , ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;
    , CLOSE_TAG                 : S++ // </a
    , CLOSE_TAG_SAW_WHITE       : S++ // </a   >
    , SCRIPT                    : S++ // <script> ...
    , SCRIPT_ENDING             : S++ // <script> ... <
    }
    
    sax.ENTITIES =
    { "amp" : "&"
    , "gt" : ">"
    , "lt" : "<"
    , "quot" : "\""
    , "apos" : "'"
    , "AElig" : 198
    , "Aacute" : 193
    , "Acirc" : 194
    , "Agrave" : 192
    , "Aring" : 197
    , "Atilde" : 195
    , "Auml" : 196
    , "Ccedil" : 199
    , "ETH" : 208
    , "Eacute" : 201
    , "Ecirc" : 202
    , "Egrave" : 200
    , "Euml" : 203
    , "Iacute" : 205
    , "Icirc" : 206
    , "Igrave" : 204
    , "Iuml" : 207
    , "Ntilde" : 209
    , "Oacute" : 211
    , "Ocirc" : 212
    , "Ograve" : 210
    , "Oslash" : 216
    , "Otilde" : 213
    , "Ouml" : 214
    , "THORN" : 222
    , "Uacute" : 218
    , "Ucirc" : 219
    , "Ugrave" : 217
    , "Uuml" : 220
    , "Yacute" : 221
    , "aacute" : 225
    , "acirc" : 226
    , "aelig" : 230
    , "agrave" : 224
    , "aring" : 229
    , "atilde" : 227
    , "auml" : 228
    , "ccedil" : 231
    , "eacute" : 233
    , "ecirc" : 234
    , "egrave" : 232
    , "eth" : 240
    , "euml" : 235
    , "iacute" : 237
    , "icirc" : 238
    , "igrave" : 236
    , "iuml" : 239
    , "ntilde" : 241
    , "oacute" : 243
    , "ocirc" : 244
    , "ograve" : 242
    , "oslash" : 248
    , "otilde" : 245
    , "ouml" : 246
    , "szlig" : 223
    , "thorn" : 254
    , "uacute" : 250
    , "ucirc" : 251
    , "ugrave" : 249
    , "uuml" : 252
    , "yacute" : 253
    , "yuml" : 255
    , "copy" : 169
    , "reg" : 174
    , "nbsp" : 160
    , "iexcl" : 161
    , "cent" : 162
    , "pound" : 163
    , "curren" : 164
    , "yen" : 165
    , "brvbar" : 166
    , "sect" : 167
    , "uml" : 168
    , "ordf" : 170
    , "laquo" : 171
    , "not" : 172
    , "shy" : 173
    , "macr" : 175
    , "deg" : 176
    , "plusmn" : 177
    , "sup1" : 185
    , "sup2" : 178
    , "sup3" : 179
    , "acute" : 180
    , "micro" : 181
    , "para" : 182
    , "middot" : 183
    , "cedil" : 184
    , "ordm" : 186
    , "raquo" : 187
    , "frac14" : 188
    , "frac12" : 189
    , "frac34" : 190
    , "iquest" : 191
    , "times" : 215
    , "divide" : 247
    , "OElig" : 338
    , "oelig" : 339
    , "Scaron" : 352
    , "scaron" : 353
    , "Yuml" : 376
    , "fnof" : 402
    , "circ" : 710
    , "tilde" : 732
    , "Alpha" : 913
    , "Beta" : 914
    , "Gamma" : 915
    , "Delta" : 916
    , "Epsilon" : 917
    , "Zeta" : 918
    , "Eta" : 919
    , "Theta" : 920
    , "Iota" : 921
    , "Kappa" : 922
    , "Lambda" : 923
    , "Mu" : 924
    , "Nu" : 925
    , "Xi" : 926
    , "Omicron" : 927
    , "Pi" : 928
    , "Rho" : 929
    , "Sigma" : 931
    , "Tau" : 932
    , "Upsilon" : 933
    , "Phi" : 934
    , "Chi" : 935
    , "Psi" : 936
    , "Omega" : 937
    , "alpha" : 945
    , "beta" : 946
    , "gamma" : 947
    , "delta" : 948
    , "epsilon" : 949
    , "zeta" : 950
    , "eta" : 951
    , "theta" : 952
    , "iota" : 953
    , "kappa" : 954
    , "lambda" : 955
    , "mu" : 956
    , "nu" : 957
    , "xi" : 958
    , "omicron" : 959
    , "pi" : 960
    , "rho" : 961
    , "sigmaf" : 962
    , "sigma" : 963
    , "tau" : 964
    , "upsilon" : 965
    , "phi" : 966
    , "chi" : 967
    , "psi" : 968
    , "omega" : 969
    , "thetasym" : 977
    , "upsih" : 978
    , "piv" : 982
    , "ensp" : 8194
    , "emsp" : 8195
    , "thinsp" : 8201
    , "zwnj" : 8204
    , "zwj" : 8205
    , "lrm" : 8206
    , "rlm" : 8207
    , "ndash" : 8211
    , "mdash" : 8212
    , "lsquo" : 8216
    , "rsquo" : 8217
    , "sbquo" : 8218
    , "ldquo" : 8220
    , "rdquo" : 8221
    , "bdquo" : 8222
    , "dagger" : 8224
    , "Dagger" : 8225
    , "bull" : 8226
    , "hellip" : 8230
    , "permil" : 8240
    , "prime" : 8242
    , "Prime" : 8243
    , "lsaquo" : 8249
    , "rsaquo" : 8250
    , "oline" : 8254
    , "frasl" : 8260
    , "euro" : 8364
    , "image" : 8465
    , "weierp" : 8472
    , "real" : 8476
    , "trade" : 8482
    , "alefsym" : 8501
    , "larr" : 8592
    , "uarr" : 8593
    , "rarr" : 8594
    , "darr" : 8595
    , "harr" : 8596
    , "crarr" : 8629
    , "lArr" : 8656
    , "uArr" : 8657
    , "rArr" : 8658
    , "dArr" : 8659
    , "hArr" : 8660
    , "forall" : 8704
    , "part" : 8706
    , "exist" : 8707
    , "empty" : 8709
    , "nabla" : 8711
    , "isin" : 8712
    , "notin" : 8713
    , "ni" : 8715
    , "prod" : 8719
    , "sum" : 8721
    , "minus" : 8722
    , "lowast" : 8727
    , "radic" : 8730
    , "prop" : 8733
    , "infin" : 8734
    , "ang" : 8736
    , "and" : 8743
    , "or" : 8744
    , "cap" : 8745
    , "cup" : 8746
    , "int" : 8747
    , "there4" : 8756
    , "sim" : 8764
    , "cong" : 8773
    , "asymp" : 8776
    , "ne" : 8800
    , "equiv" : 8801
    , "le" : 8804
    , "ge" : 8805
    , "sub" : 8834
    , "sup" : 8835
    , "nsub" : 8836
    , "sube" : 8838
    , "supe" : 8839
    , "oplus" : 8853
    , "otimes" : 8855
    , "perp" : 8869
    , "sdot" : 8901
    , "lceil" : 8968
    , "rceil" : 8969
    , "lfloor" : 8970
    , "rfloor" : 8971
    , "lang" : 9001
    , "rang" : 9002
    , "loz" : 9674
    , "spades" : 9824
    , "clubs" : 9827
    , "hearts" : 9829
    , "diams" : 9830
    }
    
    Object.keys(sax.ENTITIES).forEach(function (key) {
        var e = sax.ENTITIES[key]
        var s = typeof e === 'number' ? String.fromCharCode(e) : e
        sax.ENTITIES[key] = s
    })
    
    for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S
    
    // shorthand
    S = sax.STATE
    
    function emit (parser, event, data) {
      parser[event] && parser[event](data)
    }
    
    function emitNode (parser, nodeType, data) {
      if (parser.textNode) closeText(parser)
      emit(parser, nodeType, data)
    }
    
    function closeText (parser) {
      parser.textNode = textopts(parser.opt, parser.textNode)
      if (parser.textNode) emit(parser, "ontext", parser.textNode)
      parser.textNode = ""
    }
    
    function textopts (opt, text) {
      if (opt.trim) text = text.trim()
      if (opt.normalize) text = text.replace(/\s+/g, " ")
      return text
    }
    
    function error (parser, er) {
      closeText(parser)
      if (parser.trackPosition) {
        er += "\nLine: "+parser.line+
              "\nColumn: "+parser.column+
              "\nChar: "+parser.c
      }
      er = new Error(er)
      parser.error = er
      emit(parser, "onerror", er)
      return parser
    }
    
    function end (parser) {
      if (!parser.closedRoot) strictFail(parser, "Unclosed root tag")
      if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, "Unexpected end")
      closeText(parser)
      parser.c = ""
      parser.closed = true
      emit(parser, "onend")
      SAXParser.call(parser, parser.strict, parser.opt)
      return parser
    }
    
    function strictFail (parser, message) {
      if (typeof parser !== 'object' || !(parser instanceof SAXParser))
        throw new Error('bad call to strictFail');
      if (parser.strict) error(parser, message)
    }
    
    function newTag (parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
      var parent = parser.tags[parser.tags.length - 1] || parser
        , tag = parser.tag = { name : parser.tagName, attributes : {} }
    
      // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
      if (parser.opt.xmlns) tag.ns = parent.ns
      parser.attribList.length = 0
    }
    
    function qname (name, attribute) {
      var i = name.indexOf(":")
        , qualName = i < 0 ? [ "", name ] : name.split(":")
        , prefix = qualName[0]
        , local = qualName[1]
    
      // <x "xmlns"="http://foo">
      if (attribute && name === "xmlns") {
        prefix = "xmlns"
        local = ""
      }
    
      return { prefix: prefix, local: local }
    }
    
    function attrib (parser) {
      if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()
    
      if (parser.attribList.indexOf(parser.attribName) !== -1 ||
          parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        return parser.attribName = parser.attribValue = ""
      }
    
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true)
          , prefix = qn.prefix
          , local = qn.local
    
        if (prefix === "xmlns") {
          // namespace binding attribute; push the binding into scope
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail( parser
                      , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
                      + "Actual: " + parser.attribValue )
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail( parser
                      , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
                      + "Actual: " + parser.attribValue )
          } else {
            var tag = parser.tag
              , parent = parser.tags[parser.tags.length - 1] || parser
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns)
            }
            tag.ns[local] = parser.attribValue
          }
        }
    
        // defer onattribute events until all attributes have been seen
        // so any new bindings can take effect; preserve attribute order
        // so deferred events can be emitted in document order
        parser.attribList.push([parser.attribName, parser.attribValue])
      } else {
        // in non-xmlns mode, we can emit the event right away
        parser.tag.attributes[parser.attribName] = parser.attribValue
        emitNode( parser
                , "onattribute"
                , { name: parser.attribName
                  , value: parser.attribValue } )
      }
    
      parser.attribName = parser.attribValue = ""
    }
    
    function openTag (parser, selfClosing) {
      if (parser.opt.xmlns) {
        // emit namespace binding events
        var tag = parser.tag
    
        // add namespace info to tag
        var qn = qname(parser.tagName)
        tag.prefix = qn.prefix
        tag.local = qn.local
        tag.uri = tag.ns[qn.prefix] || ""
    
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: "
                           + JSON.stringify(parser.tagName))
          tag.uri = qn.prefix
        }
    
        var parent = parser.tags[parser.tags.length - 1] || parser
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function (p) {
            emitNode( parser
                    , "onopennamespace"
                    , { prefix: p , uri: tag.ns[p] } )
          })
        }
    
        // handle deferred onattribute events
        // Note: do not apply default ns to attributes:
        //   http://www.w3.org/TR/REC-xml-names/#defaulting
        for (var i = 0, l = parser.attribList.length; i < l; i ++) {
          var nv = parser.attribList[i]
          var name = nv[0]
            , value = nv[1]
            , qualName = qname(name, true)
            , prefix = qualName.prefix
            , local = qualName.local
            , uri = prefix == "" ? "" : (tag.ns[prefix] || "")
            , a = { name: name
                  , value: value
                  , prefix: prefix
                  , local: local
                  , uri: uri
                  }
    
          // if there's any attributes with an undefined namespace,
          // then fail on them now.
          if (prefix && prefix != "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: "
                             + JSON.stringify(prefix))
            a.uri = prefix
          }
          parser.tag.attributes[name] = a
          emitNode(parser, "onattribute", a)
        }
        parser.attribList.length = 0
      }
    
      parser.tag.isSelfClosing = !!selfClosing
    
      // process the tag
      parser.sawRoot = true
      parser.tags.push(parser.tag)
      emitNode(parser, "onopentag", parser.tag)
      if (!selfClosing) {
        // special case for <script> in non-strict mode.
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT
        } else {
          parser.state = S.TEXT
        }
        parser.tag = null
        parser.tagName = ""
      }
      parser.attribName = parser.attribValue = ""
      parser.attribList.length = 0
    }
    
    function closeTag (parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.")
        parser.textNode += "</>"
        parser.state = S.TEXT
        return
      }
    
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">"
          parser.tagName = ""
          parser.state = S.SCRIPT
          return
        }
        emitNode(parser, "onscript", parser.script)
        parser.script = ""
      }
    
      // first make sure that the closing tag actually exists.
      // <a><b></c></b></a> will close everything, otherwise.
      var t = parser.tags.length
      var tagName = parser.tagName
      if (!parser.strict) tagName = tagName[parser.looseCase]()
      var closeTo = tagName
      while (t --) {
        var close = parser.tags[t]
        if (close.name !== closeTo) {
          // fail the first time in strict mode
          strictFail(parser, "Unexpected close tag")
        } else break
      }
    
      // didn't find it.  we already failed for strict, so just abort.
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: "+parser.tagName)
        parser.textNode += "</" + parser.tagName + ">"
        parser.state = S.TEXT
        return
      }
      parser.tagName = tagName
      var s = parser.tags.length
      while (s --> t) {
        var tag = parser.tag = parser.tags.pop()
        parser.tagName = parser.tag.name
        emitNode(parser, "onclosetag", parser.tagName)
    
        var x = {}
        for (var i in tag.ns) x[i] = tag.ns[i]
    
        var parent = parser.tags[parser.tags.length - 1] || parser
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          // remove namespace bindings introduced by tag
          Object.keys(tag.ns).forEach(function (p) {
            var n = tag.ns[p]
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n })
          })
        }
      }
      if (t === 0) parser.closedRoot = true
      parser.tagName = parser.attribValue = parser.attribName = ""
      parser.attribList.length = 0
      parser.state = S.TEXT
    }
    
    function parseEntity (parser) {
      var entity = parser.entity
        , entityLC = entity.toLowerCase()
        , num
        , numStr = ""
      if (parser.ENTITIES[entity])
        return parser.ENTITIES[entity]
      if (parser.ENTITIES[entityLC])
        return parser.ENTITIES[entityLC]
      entity = entityLC
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2)
          num = parseInt(entity, 16)
          numStr = num.toString(16)
        } else {
          entity = entity.slice(1)
          num = parseInt(entity, 10)
          numStr = num.toString(10)
        }
      }
      entity = entity.replace(/^0+/, "")
      if (numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity")
        return "&"+parser.entity + ";"
      }
    
      return String.fromCodePoint(num)
    }
    
    function write (chunk) {
      var parser = this
      if (this.error) throw this.error
      if (parser.closed) return error(parser,
        "Cannot write after close. Assign an onready handler.")
      if (chunk === null) return end(parser)
      var i = 0, c = ""
      while (parser.c = c = chunk.charAt(i++)) {
        if (parser.trackPosition) {
          parser.position ++
          if (c === "\n") {
            parser.line ++
            parser.column = 0
          } else parser.column ++
        }
        switch (parser.state) {
    
          case S.BEGIN:
            if (c === "<") {
              parser.state = S.OPEN_WAKA
              parser.startTagPosition = parser.position
            } else if (not(whitespace,c)) {
              // have to process this as a text node.
              // weird, but happens.
              strictFail(parser, "Non-whitespace before first tag.")
              parser.textNode = c
              parser.state = S.TEXT
            }
          continue
    
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i-1
              while (c && c!=="<" && c!=="&") {
                c = chunk.charAt(i++)
                if (c && parser.trackPosition) {
                  parser.position ++
                  if (c === "\n") {
                    parser.line ++
                    parser.column = 0
                  } else parser.column ++
                }
              }
              parser.textNode += chunk.substring(starti, i-1)
            }
            if (c === "<") {
              parser.state = S.OPEN_WAKA
              parser.startTagPosition = parser.position
            } else {
              if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
                strictFail(parser, "Text data outside of root node.")
              if (c === "&") parser.state = S.TEXT_ENTITY
              else parser.textNode += c
            }
          continue
    
          case S.SCRIPT:
            // only non-strict
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING
            } else parser.script += c
          continue
    
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG
            } else {
              parser.script += "<" + c
              parser.state = S.SCRIPT
            }
          continue
    
          case S.OPEN_WAKA:
            // either a /, ?, !, or text is coming next.
            if (c === "!") {
              parser.state = S.SGML_DECL
              parser.sgmlDecl = ""
            } else if (is(whitespace, c)) {
              // wait for it...
            } else if (is(nameStart,c)) {
              parser.state = S.OPEN_TAG
              parser.tagName = c
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG
              parser.tagName = ""
            } else if (c === "?") {
              parser.state = S.PROC_INST
              parser.procInstName = parser.procInstBody = ""
            } else {
              strictFail(parser, "Unencoded <")
              // if there was some whitespace, then add that in.
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition
                c = new Array(pad).join(" ") + c
              }
              parser.textNode += "<" + c
              parser.state = S.TEXT
            }
          continue
    
          case S.SGML_DECL:
            if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata")
              parser.state = S.CDATA
              parser.sgmlDecl = ""
              parser.cdata = ""
            } else if (parser.sgmlDecl+c === "--") {
              parser.state = S.COMMENT
              parser.comment = ""
              parser.sgmlDecl = ""
            } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE
              if (parser.doctype || parser.sawRoot) strictFail(parser,
                "Inappropriately located doctype declaration")
              parser.doctype = ""
              parser.sgmlDecl = ""
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl)
              parser.sgmlDecl = ""
              parser.state = S.TEXT
            } else if (is(quote, c)) {
              parser.state = S.SGML_DECL_QUOTED
              parser.sgmlDecl += c
            } else parser.sgmlDecl += c
          continue
    
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL
              parser.q = ""
            }
            parser.sgmlDecl += c
          continue
    
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT
              emitNode(parser, "ondoctype", parser.doctype)
              parser.doctype = true // just remember that we saw it.
            } else {
              parser.doctype += c
              if (c === "[") parser.state = S.DOCTYPE_DTD
              else if (is(quote, c)) {
                parser.state = S.DOCTYPE_QUOTED
                parser.q = c
              }
            }
          continue
    
          case S.DOCTYPE_QUOTED:
            parser.doctype += c
            if (c === parser.q) {
              parser.q = ""
              parser.state = S.DOCTYPE
            }
          continue
    
          case S.DOCTYPE_DTD:
            parser.doctype += c
            if (c === "]") parser.state = S.DOCTYPE
            else if (is(quote,c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED
              parser.q = c
            }
          continue
    
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD
              parser.q = ""
            }
          continue
    
          case S.COMMENT:
            if (c === "-") parser.state = S.COMMENT_ENDING
            else parser.comment += c
          continue
    
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED
              parser.comment = textopts(parser.opt, parser.comment)
              if (parser.comment) emitNode(parser, "oncomment", parser.comment)
              parser.comment = ""
            } else {
              parser.comment += "-" + c
              parser.state = S.COMMENT
            }
          continue
    
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment")
              // allow <!-- blah -- bloo --> in non-strict mode,
              // which is a comment of " blah -- bloo "
              parser.comment += "--" + c
              parser.state = S.COMMENT
            } else parser.state = S.TEXT
          continue
    
          case S.CDATA:
            if (c === "]") parser.state = S.CDATA_ENDING
            else parser.cdata += c
          continue
    
          case S.CDATA_ENDING:
            if (c === "]") parser.state = S.CDATA_ENDING_2
            else {
              parser.cdata += "]" + c
              parser.state = S.CDATA
            }
          continue
    
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) emitNode(parser, "oncdata", parser.cdata)
              emitNode(parser, "onclosecdata")
              parser.cdata = ""
              parser.state = S.TEXT
            } else if (c === "]") {
              parser.cdata += "]"
            } else {
              parser.cdata += "]]" + c
              parser.state = S.CDATA
            }
          continue
    
          case S.PROC_INST:
            if (c === "?") parser.state = S.PROC_INST_ENDING
            else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
            else parser.procInstName += c
          continue
    
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && is(whitespace, c)) continue
            else if (c === "?") parser.state = S.PROC_INST_ENDING
            else parser.procInstBody += c
          continue
    
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name : parser.procInstName,
                body : parser.procInstBody
              })
              parser.procInstName = parser.procInstBody = ""
              parser.state = S.TEXT
            } else {
              parser.procInstBody += "?" + c
              parser.state = S.PROC_INST_BODY
            }
          continue
    
          case S.OPEN_TAG:
            if (is(nameBody, c)) parser.tagName += c
            else {
              newTag(parser)
              if (c === ">") openTag(parser)
              else if (c === "/") parser.state = S.OPEN_TAG_SLASH
              else {
                if (not(whitespace, c)) strictFail(
                  parser, "Invalid character in tag name")
                parser.state = S.ATTRIB
              }
            }
          continue
    
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true)
              closeTag(parser)
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >")
              parser.state = S.ATTRIB
            }
          continue
    
          case S.ATTRIB:
            // haven't read the attribute name yet.
            if (is(whitespace, c)) continue
            else if (c === ">") openTag(parser)
            else if (c === "/") parser.state = S.OPEN_TAG_SLASH
            else if (is(nameStart, c)) {
              parser.attribName = c
              parser.attribValue = ""
              parser.state = S.ATTRIB_NAME
            } else strictFail(parser, "Invalid attribute name")
          continue
    
          case S.ATTRIB_NAME:
            if (c === "=") parser.state = S.ATTRIB_VALUE
            else if (c === ">") {
              strictFail(parser, "Attribute without value")
              parser.attribValue = parser.attribName
              attrib(parser)
              openTag(parser)
            }
            else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
            else if (is(nameBody, c)) parser.attribName += c
            else strictFail(parser, "Invalid attribute name")
          continue
    
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") parser.state = S.ATTRIB_VALUE
            else if (is(whitespace, c)) continue
            else {
              strictFail(parser, "Attribute without value")
              parser.tag.attributes[parser.attribName] = ""
              parser.attribValue = ""
              emitNode(parser, "onattribute",
                       { name : parser.attribName, value : "" })
              parser.attribName = ""
              if (c === ">") openTag(parser)
              else if (is(nameStart, c)) {
                parser.attribName = c
                parser.state = S.ATTRIB_NAME
              } else {
                strictFail(parser, "Invalid attribute name")
                parser.state = S.ATTRIB
              }
            }
          continue
    
          case S.ATTRIB_VALUE:
            if (is(whitespace, c)) continue
            else if (is(quote, c)) {
              parser.q = c
              parser.state = S.ATTRIB_VALUE_QUOTED
            } else {
              strictFail(parser, "Unquoted attribute value")
              parser.state = S.ATTRIB_VALUE_UNQUOTED
              parser.attribValue = c
            }
          continue
    
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q
              else parser.attribValue += c
              continue
            }
            attrib(parser)
            parser.q = ""
            parser.state = S.ATTRIB_VALUE_CLOSED
          continue
    
          case S.ATTRIB_VALUE_CLOSED:
            if (is(whitespace, c)) {
              parser.state = S.ATTRIB
            } else if (c === ">") openTag(parser)
            else if (c === "/") parser.state = S.OPEN_TAG_SLASH
            else if (is(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes")
              parser.attribName = c
              parser.attribValue = ""
              parser.state = S.ATTRIB_NAME
            } else strictFail(parser, "Invalid attribute name")
          continue
    
          case S.ATTRIB_VALUE_UNQUOTED:
            if (not(attribEnd,c)) {
              if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U
              else parser.attribValue += c
              continue
            }
            attrib(parser)
            if (c === ">") openTag(parser)
            else parser.state = S.ATTRIB
          continue
    
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (is(whitespace, c)) continue
              else if (not(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c
                  parser.state = S.SCRIPT
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.")
                }
              } else parser.tagName = c
            }
            else if (c === ">") closeTag(parser)
            else if (is(nameBody, c)) parser.tagName += c
            else if (parser.script) {
              parser.script += "</" + parser.tagName
              parser.tagName = ""
              parser.state = S.SCRIPT
            } else {
              if (not(whitespace, c)) strictFail(parser,
                "Invalid tagname in closing tag")
              parser.state = S.CLOSE_TAG_SAW_WHITE
            }
          continue
    
          case S.CLOSE_TAG_SAW_WHITE:
            if (is(whitespace, c)) continue
            if (c === ">") closeTag(parser)
            else strictFail(parser, "Invalid characters in closing tag")
          continue
    
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            switch(parser.state) {
              case S.TEXT_ENTITY:
                var returnState = S.TEXT, buffer = "textNode"
              break
    
              case S.ATTRIB_VALUE_ENTITY_Q:
                var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
              break
    
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
              break
            }
            if (c === ";") {
              parser[buffer] += parseEntity(parser)
              parser.entity = ""
              parser.state = returnState
            }
            else if (is(entity, c)) parser.entity += c
            else {
              strictFail(parser, "Invalid character entity")
              parser[buffer] += "&" + parser.entity + c
              parser.entity = ""
              parser.state = returnState
            }
          continue
    
          default:
            throw new Error(parser, "Unknown state: " + parser.state)
        }
      } // while
      // cdata blocks can get very big under normal conditions. emit and move on.
      // if (parser.state === S.CDATA && parser.cdata) {
      //   emitNode(parser, "oncdata", parser.cdata)
      //   parser.cdata = ""
      // }
      if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)
      return parser
    }
    
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
            (function() {
                    var stringFromCharCode = String.fromCharCode;
                    var floor = Math.floor;
                    var fromCodePoint = function() {
                            var MAX_SIZE = 0x4000;
                            var codeUnits = [];
                            var highSurrogate;
                            var lowSurrogate;
                            var index = -1;
                            var length = arguments.length;
                            if (!length) {
                                    return '';
                            }
                            var result = '';
                            while (++index < length) {
                                    var codePoint = Number(arguments[index]);
                                    if (
                                            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                            codePoint < 0 || // not a valid Unicode code point
                                            codePoint > 0x10FFFF || // not a valid Unicode code point
                                            floor(codePoint) != codePoint // not an integer
                                    ) {
                                            throw RangeError('Invalid code point: ' + codePoint);
                                    }
                                    if (codePoint <= 0xFFFF) { // BMP code point
                                            codeUnits.push(codePoint);
                                    } else { // Astral code point; split in surrogate halves
                                            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                            codePoint -= 0x10000;
                                            highSurrogate = (codePoint >> 10) + 0xD800;
                                            lowSurrogate = (codePoint % 0x400) + 0xDC00;
                                            codeUnits.push(highSurrogate, lowSurrogate);
                                    }
                                    if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                                            result += stringFromCharCode.apply(null, codeUnits);
                                            codeUnits.length = 0;
                                    }
                            }
                            return result;
                    };
                    if (Object.defineProperty) {
                            Object.defineProperty(String, 'fromCodePoint', {
                                    'value': fromCodePoint,
                                    'configurable': true,
                                    'writable': true
                            });
                    } else {
                            String.fromCodePoint = fromCodePoint;
                    }
            }());
    }
    
    })(typeof exports === "undefined" ? sax = {} : exports);
    
  provide("sax", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLAttribute
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLAttribute, create;
    
      create = require('lodash-node/modern/objects/create');
    
      module.exports = XMLAttribute = (function() {
        function XMLAttribute(parent, name, value) {
          this.stringify = parent.stringify;
          if (name == null) {
            throw new Error("Missing attribute name");
          }
          if (value == null) {
            throw new Error("Missing attribute value");
          }
          this.name = this.stringify.attName(name);
          this.value = this.stringify.attValue(value);
        }
    
        XMLAttribute.prototype.clone = function() {
          return create(XMLAttribute.prototype, this);
        };
    
        XMLAttribute.prototype.toString = function(options, level) {
          return ' ' + this.name + '="' + this.value + '"';
        };
    
        return XMLAttribute;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLAttribute", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLProcessingInstruction
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLProcessingInstruction, create;
    
      create = require('lodash-node/modern/objects/create');
    
      module.exports = XMLProcessingInstruction = (function() {
        function XMLProcessingInstruction(parent, target, value) {
          this.stringify = parent.stringify;
          if (target == null) {
            throw new Error("Missing instruction target");
          }
          this.target = this.stringify.insTarget(target);
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
    
        XMLProcessingInstruction.prototype.clone = function() {
          return create(XMLProcessingInstruction.prototype, this);
        };
    
        XMLProcessingInstruction.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<?';
          r += this.target;
          if (this.value) {
            r += ' ' + this.value;
          }
          r += '?>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLProcessingInstruction;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLProcessingInstruction", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLDTDElement
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLDTDElement, create, isArray;
    
      create = require('lodash-node/modern/objects/create');
    
      isArray = require('lodash-node/modern/objects/isArray');
    
      module.exports = XMLDTDElement = (function() {
        function XMLDTDElement(parent, name, value) {
          this.stringify = parent.stringify;
          if (name == null) {
            throw new Error("Missing DTD element name");
          }
          if (!value) {
            value = '(#PCDATA)';
          }
          if (isArray(value)) {
            value = '(' + value.join(',') + ')';
          }
          this.name = this.stringify.eleName(name);
          this.value = this.stringify.dtdElementValue(value);
        }
    
        XMLDTDElement.prototype.clone = function() {
          return create(XMLDTDElement.prototype, this);
        };
    
        XMLDTDElement.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLDTDElement;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLDTDElement", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLDTDAttList
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLDTDAttList, create;
    
      create = require('lodash-node/modern/objects/create');
    
      module.exports = XMLDTDAttList = (function() {
        function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          this.stringify = parent.stringify;
          if (elementName == null) {
            throw new Error("Missing DTD element name");
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name");
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type");
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default");
          }
          if (defaultValueType.indexOf('#') !== 0) {
            defaultValueType = '#' + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT");
          }
          this.elementName = this.stringify.eleName(elementName);
          this.attributeName = this.stringify.attName(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          this.defaultValueType = defaultValueType;
        }
    
        XMLDTDAttList.prototype.clone = function() {
          return create(XMLDTDAttList.prototype, this);
        };
    
        XMLDTDAttList.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
          if (this.defaultValueType !== '#DEFAULT') {
            r += ' ' + this.defaultValueType;
          }
          if (this.defaultValue) {
            r += ' "' + this.defaultValue + '"';
          }
          r += '>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLDTDAttList;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLDTDAttList", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLDTDEntity
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLDTDEntity, create, isObject;
    
      create = require('lodash-node/modern/objects/create');
    
      isObject = require('lodash-node/modern/objects/isObject');
    
      module.exports = XMLDTDEntity = (function() {
        function XMLDTDEntity(parent, pe, name, value) {
          this.stringify = parent.stringify;
          if (name == null) {
            throw new Error("Missing entity name");
          }
          if (value == null) {
            throw new Error("Missing entity value");
          }
          this.pe = !!pe;
          this.name = this.stringify.eleName(name);
          if (!isObject(value)) {
            this.value = this.stringify.dtdEntityValue(value);
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity");
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity");
            }
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity");
            }
          }
        }
    
        XMLDTDEntity.prototype.clone = function() {
          return create(XMLDTDEntity.prototype, this);
        };
    
        XMLDTDEntity.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<!ENTITY';
          if (this.pe) {
            r += ' %';
          }
          r += ' ' + this.name;
          if (this.value) {
            r += ' "' + this.value + '"';
          } else {
            if (this.pubID && this.sysID) {
              r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
            } else if (this.sysID) {
              r += ' SYSTEM "' + this.sysID + '"';
            }
            if (this.nData) {
              r += ' NDATA ' + this.nData;
            }
          }
          r += '>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLDTDEntity;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLDTDEntity", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLDTDNotation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLDTDNotation, create;
    
      create = require('lodash-node/modern/objects/create');
    
      module.exports = XMLDTDNotation = (function() {
        function XMLDTDNotation(parent, name, value) {
          this.stringify = parent.stringify;
          if (name == null) {
            throw new Error("Missing notation name");
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity");
          }
          this.name = this.stringify.eleName(name);
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
    
        XMLDTDNotation.prototype.clone = function() {
          return create(XMLDTDNotation.prototype, this);
        };
    
        XMLDTDNotation.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<!NOTATION ' + this.name;
          if (this.pubID && this.sysID) {
            r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
          } else if (this.pubID) {
            r += ' PUBLIC "' + this.pubID + '"';
          } else if (this.sysID) {
            r += ' SYSTEM "' + this.sysID + '"';
          }
          r += '>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLDTDNotation;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLDTDNotation", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLCData
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLCData, XMLNode, create,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
    
      create = require('lodash-node/modern/objects/create');
    
      XMLNode =  require('xmlbuilder/lib/XMLNode');
    
      module.exports = XMLCData = (function(_super) {
        __extends(XMLCData, _super);
    
        function XMLCData(parent, text) {
          XMLCData.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text");
          }
          this.text = this.stringify.cdata(text);
        }
    
        XMLCData.prototype.clone = function() {
          return create(XMLCData.prototype, this);
        };
    
        XMLCData.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<![CDATA[' + this.text + ']]>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLCData;
    
      })(XMLNode);
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLCData", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLComment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLComment, XMLNode, create,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
    
      create = require('lodash-node/modern/objects/create');
    
      XMLNode =  require('xmlbuilder/lib/XMLNode');
    
      module.exports = XMLComment = (function(_super) {
        __extends(XMLComment, _super);
    
        function XMLComment(parent, text) {
          XMLComment.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text");
          }
          this.text = this.stringify.comment(text);
        }
    
        XMLComment.prototype.clone = function() {
          return create(XMLComment.prototype, this);
        };
    
        XMLComment.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<!-- ' + this.text + ' -->';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLComment;
    
      })(XMLNode);
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLComment", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLElement
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, isArray, isFunction, isObject,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
    
      create = require('lodash-node/modern/objects/create');
    
      isObject = require('lodash-node/modern/objects/isObject');
    
      isArray = require('lodash-node/modern/objects/isArray');
    
      isFunction = require('lodash-node/modern/objects/isFunction');
    
      XMLNode =  require('xmlbuilder/lib/XMLNode');
    
      XMLAttribute =  require('xmlbuilder/lib/XMLAttribute');
    
      XMLProcessingInstruction =  require('xmlbuilder/lib/XMLProcessingInstruction');
    
      module.exports = XMLElement = (function(_super) {
        __extends(XMLElement, _super);
    
        function XMLElement(parent, name, attributes) {
          XMLElement.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name");
          }
          this.name = this.stringify.eleName(name);
          this.children = [];
          this.instructions = [];
          this.attributes = {};
          if (attributes != null) {
            this.attribute(attributes);
          }
        }
    
        XMLElement.prototype.clone = function() {
          var att, attName, clonedSelf, pi, _i, _len, _ref, _ref1;
          clonedSelf = create(XMLElement.prototype, this);
          clonedSelf.attributes = {};
          _ref = this.attributes;
          for (attName in _ref) {
            if (!__hasProp.call(_ref, attName)) continue;
            att = _ref[attName];
            clonedSelf.attributes[attName] = att.clone();
          }
          clonedSelf.instructions = [];
          _ref1 = this.instructions;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            pi = _ref1[_i];
            clonedSelf.instructions.push(pi.clone());
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
    
        XMLElement.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = name.valueOf();
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!__hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || (value != null)) {
              this.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
    
        XMLElement.prototype.removeAttribute = function(name) {
          var attName, _i, _len;
          if (name == null) {
            throw new Error("Missing attribute name");
          }
          name = name.valueOf();
          if (isArray(name)) {
            for (_i = 0, _len = name.length; _i < _len; _i++) {
              attName = name[_i];
              delete this.attributes[attName];
            }
          } else {
            delete this.attributes[name];
          }
          return this;
        };
    
        XMLElement.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, _i, _len;
          if (target != null) {
            target = target.valueOf();
          }
          if (value != null) {
            value = value.valueOf();
          }
          if (isArray(target)) {
            for (_i = 0, _len = target.length; _i < _len; _i++) {
              insTarget = target[_i];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!__hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.instructions.push(instruction);
          }
          return this;
        };
    
        XMLElement.prototype.toString = function(options, level) {
          var att, child, indent, instruction, name, newline, offset, pretty, r, space, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          _ref3 = this.instructions;
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            instruction = _ref3[_i];
            r += instruction.toString(options, level + 1);
          }
          if (pretty) {
            r += space;
          }
          r += '<' + this.name;
          _ref4 = this.attributes;
          for (name in _ref4) {
            if (!__hasProp.call(_ref4, name)) continue;
            att = _ref4[name];
            r += att.toString(options);
          }
          if (this.children.length === 0) {
            r += '/>';
            if (pretty) {
              r += newline;
            }
          } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
            r += '>';
            r += this.children[0].value;
            r += '</' + this.name + '>';
            r += newline;
          } else {
            r += '>';
            if (pretty) {
              r += newline;
            }
            _ref5 = this.children;
            for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
              child = _ref5[_j];
              r += child.toString(options, level + 1);
            }
            if (pretty) {
              r += space;
            }
            r += '</' + this.name + '>';
            if (pretty) {
              r += newline;
            }
          }
          return r;
        };
    
        XMLElement.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
    
        XMLElement.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
    
        XMLElement.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
    
        XMLElement.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
    
        return XMLElement;
    
      })(XMLNode);
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLElement", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLText
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLNode, XMLText, create,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
    
      create = require('lodash-node/modern/objects/create');
    
      XMLNode =  require('xmlbuilder/lib/XMLNode');
    
      module.exports = XMLText = (function(_super) {
        __extends(XMLText, _super);
    
        function XMLText(parent, text) {
          this.parent = parent;
          XMLText.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text");
          }
          this.value = this.stringify.eleText(text);
        }
    
        XMLText.prototype.clone = function() {
          return create(XMLText.prototype, this);
        };
    
        XMLText.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += this.value;
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLText;
    
      })(XMLNode);
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLText", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLRaw
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLNode, XMLRaw, create,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
    
      create = require('lodash-node/modern/objects/create');
    
      XMLNode =  require('xmlbuilder/lib/XMLNode');
    
      module.exports = XMLRaw = (function(_super) {
        __extends(XMLRaw, _super);
    
        function XMLRaw(parent, text) {
          XMLRaw.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text");
          }
          this.value = this.stringify.raw(text);
        }
    
        XMLRaw.prototype.clone = function() {
          return create(XMLRaw.prototype, this);
        };
    
        XMLRaw.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += this.value;
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLRaw;
    
      })(XMLNode);
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLRaw", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLDeclaration
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLDeclaration, XMLNode, create, isObject,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
    
      create = require('lodash-node/modern/objects/create');
    
      isObject = require('lodash-node/modern/objects/isObject');
    
      XMLNode =  require('xmlbuilder/lib/XMLNode');
    
      module.exports = XMLDeclaration = (function(_super) {
        __extends(XMLDeclaration, _super);
    
        function XMLDeclaration(parent, version, encoding, standalone) {
          var _ref;
          XMLDeclaration.__super__.constructor.call(this, parent);
          if (isObject(version)) {
            _ref = version, version = _ref.version, encoding = _ref.encoding, standalone = _ref.standalone;
          }
          if (!version) {
            version = '1.0';
          }
          if (version != null) {
            this.version = this.stringify.xmlVersion(version);
          }
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
    
        XMLDeclaration.prototype.clone = function() {
          return create(XMLDeclaration.prototype, this);
        };
    
        XMLDeclaration.prototype.toString = function(options, level) {
          var indent, newline, offset, pretty, r, space, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<?xml';
          if (this.version != null) {
            r += ' version="' + this.version + '"';
          }
          if (this.encoding != null) {
            r += ' encoding="' + this.encoding + '"';
          }
          if (this.standalone != null) {
            r += ' standalone="' + this.standalone + '"';
          }
          r += '?>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        return XMLDeclaration;
    
      })(XMLNode);
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLDeclaration", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLDocType
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLDocType, create, isObject;
    
      create = require('lodash-node/modern/objects/create');
    
      isObject = require('lodash-node/modern/objects/isObject');
    
      module.exports = XMLDocType = (function() {
        function XMLDocType(parent, pubID, sysID) {
          var _ref, _ref1;
          this.documentObject = parent;
          this.stringify = this.documentObject.stringify;
          this.children = [];
          if (isObject(pubID)) {
            _ref = pubID, pubID = _ref.pubID, sysID = _ref.sysID;
          }
          if (sysID == null) {
            _ref1 = [pubID, sysID], sysID = _ref1[0], pubID = _ref1[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
    
        XMLDocType.prototype.clone = function() {
          return create(XMLDocType.prototype, this);
        };
    
        XMLDocType.prototype.element = function(name, value) {
          var XMLDTDElement, child;
          XMLDTDElement =  require('xmlbuilder/lib/XMLDTDElement');
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var XMLDTDAttList, child;
          XMLDTDAttList =  require('xmlbuilder/lib/XMLDTDAttList');
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.entity = function(name, value) {
          var XMLDTDEntity, child;
          XMLDTDEntity =  require('xmlbuilder/lib/XMLDTDEntity');
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.pEntity = function(name, value) {
          var XMLDTDEntity, child;
          XMLDTDEntity =  require('xmlbuilder/lib/XMLDTDEntity');
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.notation = function(name, value) {
          var XMLDTDNotation, child;
          XMLDTDNotation =  require('xmlbuilder/lib/XMLDTDNotation');
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.cdata = function(value) {
          var XMLCData, child;
          XMLCData =  require('xmlbuilder/lib/XMLCData');
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.comment = function(value) {
          var XMLComment, child;
          XMLComment =  require('xmlbuilder/lib/XMLComment');
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.instruction = function(target, value) {
          var XMLProcessingInstruction, child;
          XMLProcessingInstruction =  require('xmlbuilder/lib/XMLProcessingInstruction');
          child = new XMLProcessingInstruction(this, target, value);
          this.children.push(child);
          return this;
        };
    
        XMLDocType.prototype.root = function() {
          return this.documentObject.root();
        };
    
        XMLDocType.prototype.document = function() {
          return this.documentObject;
        };
    
        XMLDocType.prototype.toString = function(options, level) {
          var child, indent, newline, offset, pretty, r, space, _i, _len, _ref, _ref1, _ref2, _ref3;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          level || (level = 0);
          space = new Array(level + offset + 1).join(indent);
          r = '';
          if (pretty) {
            r += space;
          }
          r += '<!DOCTYPE ' + this.root().name;
          if (this.pubID && this.sysID) {
            r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
          } else if (this.sysID) {
            r += ' SYSTEM "' + this.sysID + '"';
          }
          if (this.children.length > 0) {
            r += ' [';
            if (pretty) {
              r += newline;
            }
            _ref3 = this.children;
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              child = _ref3[_i];
              r += child.toString(options, level + 1);
            }
            r += ']';
          }
          r += '>';
          if (pretty) {
            r += newline;
          }
          return r;
        };
    
        XMLDocType.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
    
        XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
    
        XMLDocType.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
    
        XMLDocType.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
    
        XMLDocType.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
    
        XMLDocType.prototype.dat = function(value) {
          return this.cdata(value);
        };
    
        XMLDocType.prototype.com = function(value) {
          return this.comment(value);
        };
    
        XMLDocType.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
    
        XMLDocType.prototype.up = function() {
          return this.root();
        };
    
        XMLDocType.prototype.doc = function() {
          return this.document();
        };
    
        return XMLDocType;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLDocType", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLNode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLNode, isArray, isEmpty, isFunction, isObject,
        __hasProp = {}.hasOwnProperty;
    
      isObject = require('lodash-node/modern/objects/isObject');
    
      isArray = require('lodash-node/modern/objects/isArray');
    
      isFunction = require('lodash-node/modern/objects/isFunction');
    
      isEmpty = require('lodash-node/modern/objects/isEmpty');
    
      module.exports = XMLNode = (function() {
        function XMLNode(parent) {
          this.parent = parent;
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
    
        XMLNode.prototype.clone = function() {
          throw new Error("Cannot clone generic XMLNode");
        };
    
        XMLNode.prototype.element = function(name, attributes, text) {
          var item, key, lastChild, val, _i, _len, _ref;
          lastChild = null;
          if (attributes == null) {
            attributes = {};
          }
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            _ref = [attributes, text], text = _ref[0], attributes = _ref[1];
          }
          if (name != null) {
            name = name.valueOf();
          }
          if (isArray(name)) {
            for (_i = 0, _len = name.length; _i < _len; _i++) {
              item = name[_i];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject(name)) {
            for (key in name) {
              if (!__hasProp.call(name, key)) continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if ((isObject(val)) && (isEmpty(val))) {
                val = null;
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
                lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
              } else if (isObject(val)) {
                if (!this.options.ignoreDecorators && this.stringify.convertListKey && key.indexOf(this.stringify.convertListKey) === 0 && isArray(val)) {
                  lastChild = this.element(val);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val);
                }
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name);
          }
          return lastChild;
        };
    
        XMLNode.prototype.insertBefore = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level");
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
    
        XMLNode.prototype.insertAfter = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level");
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
    
        XMLNode.prototype.remove = function() {
          var i, _ref;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element");
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat(_ref = [])), _ref;
          return this.parent;
        };
    
        XMLNode.prototype.node = function(name, attributes, text) {
          var XMLElement, child, _ref;
          if (name != null) {
            name = name.valueOf();
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = attributes.valueOf();
          if (!isObject(attributes)) {
            _ref = [attributes, text], text = _ref[0], attributes = _ref[1];
          }
          XMLElement =  require('xmlbuilder/lib/XMLElement');
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
    
        XMLNode.prototype.text = function(value) {
          var XMLText, child;
          XMLText =  require('xmlbuilder/lib/XMLText');
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
    
        XMLNode.prototype.cdata = function(value) {
          var XMLCData, child;
          XMLCData =  require('xmlbuilder/lib/XMLCData');
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
    
        XMLNode.prototype.comment = function(value) {
          var XMLComment, child;
          XMLComment =  require('xmlbuilder/lib/XMLComment');
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
    
        XMLNode.prototype.raw = function(value) {
          var XMLRaw, child;
          XMLRaw =  require('xmlbuilder/lib/XMLRaw');
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
    
        XMLNode.prototype.declaration = function(version, encoding, standalone) {
          var XMLDeclaration, doc, xmldec;
          doc = this.document();
          XMLDeclaration =  require('xmlbuilder/lib/XMLDeclaration');
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          doc.xmldec = xmldec;
          return doc.root();
        };
    
        XMLNode.prototype.doctype = function(pubID, sysID) {
          var XMLDocType, doc, doctype;
          doc = this.document();
          XMLDocType =  require('xmlbuilder/lib/XMLDocType');
          doctype = new XMLDocType(doc, pubID, sysID);
          doc.doctype = doctype;
          return doctype;
        };
    
        XMLNode.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
    
        XMLNode.prototype.root = function() {
          var child;
          if (this.isRoot) {
            return this;
          }
          child = this.parent;
          while (!child.isRoot) {
            child = child.parent;
          }
          return child;
        };
    
        XMLNode.prototype.document = function() {
          return this.root().documentObject;
        };
    
        XMLNode.prototype.end = function(options) {
          return this.document().toString(options);
        };
    
        XMLNode.prototype.prev = function() {
          var i;
          if (this.isRoot) {
            throw new Error("Root node has no siblings");
          }
          i = this.parent.children.indexOf(this);
          if (i < 1) {
            throw new Error("Already at the first node");
          }
          return this.parent.children[i - 1];
        };
    
        XMLNode.prototype.next = function() {
          var i;
          if (this.isRoot) {
            throw new Error("Root node has no siblings");
          }
          i = this.parent.children.indexOf(this);
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error("Already at the last node");
          }
          return this.parent.children[i + 1];
        };
    
        XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
          var clonedRoot;
          clonedRoot = xmlbuilder.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
    
        XMLNode.prototype.ele = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
    
        XMLNode.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
    
        XMLNode.prototype.txt = function(value) {
          return this.text(value);
        };
    
        XMLNode.prototype.dat = function(value) {
          return this.cdata(value);
        };
    
        XMLNode.prototype.com = function(value) {
          return this.comment(value);
        };
    
        XMLNode.prototype.doc = function() {
          return this.document();
        };
    
        XMLNode.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
    
        XMLNode.prototype.dtd = function(pubID, sysID) {
          return this.doctype(pubID, sysID);
        };
    
        XMLNode.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
    
        XMLNode.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
    
        XMLNode.prototype.t = function(value) {
          return this.text(value);
        };
    
        XMLNode.prototype.d = function(value) {
          return this.cdata(value);
        };
    
        XMLNode.prototype.c = function(value) {
          return this.comment(value);
        };
    
        XMLNode.prototype.r = function(value) {
          return this.raw(value);
        };
    
        XMLNode.prototype.u = function() {
          return this.up();
        };
    
        return XMLNode;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLNode", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLStringifier
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLStringifier,
        __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
        __hasProp = {}.hasOwnProperty;
    
      module.exports = XMLStringifier = (function() {
        function XMLStringifier(options) {
          this.assertLegalChar = __bind(this.assertLegalChar, this);
          var key, value, _ref;
          this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
          _ref = (options != null ? options.stringify : void 0) || {};
          for (key in _ref) {
            if (!__hasProp.call(_ref, key)) continue;
            value = _ref[key];
            this[key] = value;
          }
        }
    
        XMLStringifier.prototype.eleName = function(val) {
          val = '' + val || '';
          return this.assertLegalChar(val);
        };
    
        XMLStringifier.prototype.eleText = function(val) {
          val = '' + val || '';
          return this.assertLegalChar(this.elEscape(val));
        };
    
        XMLStringifier.prototype.cdata = function(val) {
          val = '' + val || '';
          if (val.match(/]]>/)) {
            throw new Error("Invalid CDATA text: " + val);
          }
          return this.assertLegalChar(val);
        };
    
        XMLStringifier.prototype.comment = function(val) {
          val = '' + val || '';
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
    
        XMLStringifier.prototype.raw = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.attName = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.attValue = function(val) {
          val = '' + val || '';
          return this.attEscape(val);
        };
    
        XMLStringifier.prototype.insTarget = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.insValue = function(val) {
          val = '' + val || '';
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return val;
        };
    
        XMLStringifier.prototype.xmlVersion = function(val) {
          val = '' + val || '';
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
    
        XMLStringifier.prototype.xmlEncoding = function(val) {
          val = '' + val || '';
          if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {
            throw new Error("Invalid encoding: " + options.val);
          }
          return val;
        };
    
        XMLStringifier.prototype.xmlStandalone = function(val) {
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
    
        XMLStringifier.prototype.dtdPubID = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.dtdSysID = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.dtdElementValue = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.dtdAttType = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.dtdAttDefault = function(val) {
          if (val != null) {
            return '' + val || '';
          } else {
            return val;
          }
        };
    
        XMLStringifier.prototype.dtdEntityValue = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.dtdNData = function(val) {
          return '' + val || '';
        };
    
        XMLStringifier.prototype.convertAttKey = '@';
    
        XMLStringifier.prototype.convertPIKey = '?';
    
        XMLStringifier.prototype.convertTextKey = '#text';
    
        XMLStringifier.prototype.convertCDataKey = '#cdata';
    
        XMLStringifier.prototype.convertCommentKey = '#comment';
    
        XMLStringifier.prototype.convertRawKey = '#raw';
    
        XMLStringifier.prototype.convertListKey = '#list';
    
        XMLStringifier.prototype.assertLegalChar = function(str) {
          var chars, chr;
          if (this.allowSurrogateChars) {
            chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
          } else {
            chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
          }
          chr = str.match(chars);
          if (chr) {
            throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
          }
          return str;
        };
    
        XMLStringifier.prototype.elEscape = function(str) {
          return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
        };
    
        XMLStringifier.prototype.attEscape = function(str) {
          return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
        };
    
        return XMLStringifier;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLStringifier", module.exports);
}(global));

// pakmanager:xmlbuilder/lib/XMLBuilder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;
    
      XMLStringifier =  require('xmlbuilder/lib/XMLStringifier');
    
      XMLDeclaration =  require('xmlbuilder/lib/XMLDeclaration');
    
      XMLDocType =  require('xmlbuilder/lib/XMLDocType');
    
      XMLElement =  require('xmlbuilder/lib/XMLElement');
    
      module.exports = XMLBuilder = (function() {
        function XMLBuilder(name, options) {
          var root, temp;
          if (name == null) {
            throw new Error("Root element needs a name");
          }
          if (options == null) {
            options = {};
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
          temp = new XMLElement(this, 'doc');
          root = temp.element(name);
          root.isRoot = true;
          root.documentObject = this;
          this.rootObject = root;
          if (!options.headless) {
            root.declaration(options);
            if ((options.pubID != null) || (options.sysID != null)) {
              root.doctype(options);
            }
          }
        }
    
        XMLBuilder.prototype.root = function() {
          return this.rootObject;
        };
    
        XMLBuilder.prototype.end = function(options) {
          return this.toString(options);
        };
    
        XMLBuilder.prototype.toString = function(options) {
          var indent, newline, offset, pretty, r, _ref, _ref1, _ref2;
          pretty = (options != null ? options.pretty : void 0) || false;
          indent = (_ref = options != null ? options.indent : void 0) != null ? _ref : '  ';
          offset = (_ref1 = options != null ? options.offset : void 0) != null ? _ref1 : 0;
          newline = (_ref2 = options != null ? options.newline : void 0) != null ? _ref2 : '\n';
          r = '';
          if (this.xmldec != null) {
            r += this.xmldec.toString(options);
          }
          if (this.doctype != null) {
            r += this.doctype.toString(options);
          }
          r += this.rootObject.toString(options);
          if (pretty && r.slice(-newline.length) === newline) {
            r = r.slice(0, -newline.length);
          }
          return r;
        };
    
        return XMLBuilder;
    
      })();
    
    }).call(this);
    
  provide("xmlbuilder/lib/XMLBuilder", module.exports);
}(global));

// pakmanager:xmlbuilder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.6.3
    (function() {
      var XMLBuilder, assign;
    
      assign = require('lodash-node/modern/objects/assign');
    
      XMLBuilder =  require('xmlbuilder/lib/XMLBuilder');
    
      module.exports.create = function(name, xmldec, doctype, options) {
        options = assign({}, xmldec, doctype, options);
        return new XMLBuilder(name, options).root();
      };
    
    }).call(this);
    
  provide("xmlbuilder", module.exports);
}(global));

// pakmanager:qs/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    
    // Declare internals
    
    var internals = {};
    
    
    exports.arrayToObject = function (source) {
    
        var obj = {};
        for (var i = 0, il = source.length; i < il; ++i) {
            if (typeof source[i] !== 'undefined') {
    
                obj[i] = source[i];
            }
        }
    
        return obj;
    };
    
    
    exports.merge = function (target, source) {
    
        if (!source) {
            return target;
        }
    
        if (typeof source !== 'object') {
            target.push(source);
            return target;
        }
    
        if (typeof target !== 'object') {
            target = [target].concat(source);
            return target;
        }
    
        if (Array.isArray(target) &&
            !Array.isArray(source)) {
    
            target = exports.arrayToObject(target);
        }
    
        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];
    
            if (!target[key]) {
                target[key] = value;
            }
            else {
                target[key] = exports.merge(target[key], value);
            }
        }
    
        return target;
    };
    
    
    exports.decode = function (str) {
    
        try {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        } catch (e) {
            return str;
        }
    };
    
    
    exports.compact = function (obj, refs) {
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return obj;
        }
    
        refs = refs || [];
        var lookup = refs.indexOf(obj);
        if (lookup !== -1) {
            return refs[lookup];
        }
    
        refs.push(obj);
    
        if (Array.isArray(obj)) {
            var compacted = [];
    
            for (var i = 0, l = obj.length; i < l; ++i) {
                if (typeof obj[i] !== 'undefined') {
                    compacted.push(obj[i]);
                }
            }
    
            return compacted;
        }
    
        var keys = Object.keys(obj);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            obj[key] = exports.compact(obj[key], refs);
        }
    
        return obj;
    };
    
    
    exports.isRegExp = function (obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };
    
    
    exports.isBuffer = function (obj) {
    
        if (obj === null ||
            typeof obj === 'undefined') {
    
            return false;
        }
    
        return !!(obj.constructor &&
            obj.constructor.isBuffer &&
            obj.constructor.isBuffer(obj));
    };
    
  provide("qs/lib/utils", module.exports);
}(global));

// pakmanager:qs/lib/stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        indices: true
    };
    
    
    internals.stringify = function (obj, prefix, options) {
    
        if (Utils.isBuffer(obj)) {
            obj = obj.toString();
        }
        else if (obj instanceof Date) {
            obj = obj.toISOString();
        }
        else if (obj === null) {
            obj = '';
        }
    
        if (typeof obj === 'string' ||
            typeof obj === 'number' ||
            typeof obj === 'boolean') {
    
            return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];
        }
    
        var values = [];
    
        if (typeof obj === 'undefined') {
            return values;
        }
    
        var objKeys = Object.keys(obj);
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
            if (!options.indices &&
                Array.isArray(obj)) {
    
                values = values.concat(internals.stringify(obj[key], prefix, options));
            }
            else {
                values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', options));
            }
        }
    
        return values;
    };
    
    
    module.exports = function (obj, options) {
    
        options = options || {};
        var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
        options.indices = typeof options.indices === 'boolean' ? options.indices : internals.indices;
    
        var keys = [];
    
        if (typeof obj !== 'object' ||
            obj === null) {
    
            return '';
        }
    
        var objKeys = Object.keys(obj);
        for (var i = 0, il = objKeys.length; i < il; ++i) {
            var key = objKeys[i];
            keys = keys.concat(internals.stringify(obj[key], key, options));
        }
    
        return keys.join(delimiter);
    };
    
  provide("qs/lib/stringify", module.exports);
}(global));

// pakmanager:qs/lib/parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Utils =  require('qs/lib/utils');
    
    
    // Declare internals
    
    var internals = {
        delimiter: '&',
        depth: 5,
        arrayLimit: 20,
        parameterLimit: 1000
    };
    
    
    internals.parseValues = function (str, options) {
    
        var obj = {};
        var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
    
        for (var i = 0, il = parts.length; i < il; ++i) {
            var part = parts[i];
            var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
    
            if (pos === -1) {
                obj[Utils.decode(part)] = '';
            }
            else {
                var key = Utils.decode(part.slice(0, pos));
                var val = Utils.decode(part.slice(pos + 1));
    
                if (!obj.hasOwnProperty(key)) {
                    obj[key] = val;
                }
                else {
                    obj[key] = [].concat(obj[key]).concat(val);
                }
            }
        }
    
        return obj;
    };
    
    
    internals.parseObject = function (chain, val, options) {
    
        if (!chain.length) {
            return val;
        }
    
        var root = chain.shift();
    
        var obj = {};
        if (root === '[]') {
            obj = [];
            obj = obj.concat(internals.parseObject(chain, val, options));
        }
        else {
            var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
            var index = parseInt(cleanRoot, 10);
            var indexString = '' + index;
            if (!isNaN(index) &&
                root !== cleanRoot &&
                indexString === cleanRoot &&
                index <= options.arrayLimit) {
    
                obj = [];
                obj[index] = internals.parseObject(chain, val, options);
            }
            else {
                obj[cleanRoot] = internals.parseObject(chain, val, options);
            }
        }
    
        return obj;
    };
    
    
    internals.parseKeys = function (key, val, options) {
    
        if (!key) {
            return;
        }
    
        // The regex chunks
    
        var parent = /^([^\[\]]*)/;
        var child = /(\[[^\[\]]*\])/g;
    
        // Get the parent
    
        var segment = parent.exec(key);
    
        // Don't allow them to overwrite object prototype properties
    
        if (Object.prototype.hasOwnProperty(segment[1])) {
            return;
        }
    
        // Stash the parent if it exists
    
        var keys = [];
        if (segment[1]) {
            keys.push(segment[1]);
        }
    
        // Loop through children appending to the array until we hit depth
    
        var i = 0;
        while ((segment = child.exec(key)) !== null && i < options.depth) {
    
            ++i;
            if (!Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
                keys.push(segment[1]);
            }
        }
    
        // If there's a remainder, just add whatever is left
    
        if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
        }
    
        return internals.parseObject(keys, val, options);
    };
    
    
    module.exports = function (str, options) {
    
        if (str === '' ||
            str === null ||
            typeof str === 'undefined') {
    
            return {};
        }
    
        options = options || {};
        options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
        options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
        options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
        options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
    
        var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
        var obj = {};
    
        // Iterate over the keys and setup the new object
    
        var keys = Object.keys(tempObj);
        for (var i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            var newObj = internals.parseKeys(key, tempObj[key], options);
            obj = Utils.merge(obj, newObj);
        }
    
        return Utils.compact(obj);
    };
    
  provide("qs/lib/parse", module.exports);
}(global));

// pakmanager:qs/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Load modules
    
    var Stringify =  require('qs/lib/stringify');
    var Parse =  require('qs/lib/parse');
    
    
    // Declare internals
    
    var internals = {};
    
    
    module.exports = {
        stringify: Stringify,
        parse: Parse
    };
    
  provide("qs/lib", module.exports);
}(global));

// pakmanager:qs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('qs/lib');
    
  provide("qs", module.exports);
}(global));

// pakmanager:formidable/file
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  if (global.GENTLY) require = GENTLY.hijack(require);
    
    var util = require('util'),
        WriteStream = require('fs').WriteStream,
        EventEmitter = require('events').EventEmitter,
        crypto = require('crypto');
    
    function File(properties) {
      EventEmitter.call(this);
    
      this.size = 0;
      this.path = null;
      this.name = null;
      this.type = null;
      this.hash = null;
      this.lastModifiedDate = null;
    
      this._writeStream = null;
      
      for (var key in properties) {
        this[key] = properties[key];
      }
    
      if(typeof this.hash === 'string') {
        this.hash = crypto.createHash(properties.hash);
      } else {
        this.hash = null;
      }
    }
    module.exports = File;
    util.inherits(File, EventEmitter);
    
    File.prototype.open = function() {
      this._writeStream = new WriteStream(this.path);
    };
    
    File.prototype.toJSON = function() {
      return {
        size: this.size,
        path: this.path,
        name: this.name,
        type: this.type,
        mtime: this.lastModifiedDate,
        length: this.length,
        filename: this.filename,
        mime: this.mime
      };
    };
    
    File.prototype.write = function(buffer, cb) {
      var self = this;
      if (self.hash) {
        self.hash.update(buffer);
      }
      this._writeStream.write(buffer, function() {
        self.lastModifiedDate = new Date();
        self.size += buffer.length;
        self.emit('progress', self.size);
        cb();
      });
    };
    
    File.prototype.end = function(cb) {
      var self = this;
      if (self.hash) {
        self.hash = self.hash.digest('hex');
      }
      this._writeStream.end(function() {
        self.emit('end');
        cb();
      });
    };
    
  provide("formidable/file", module.exports);
}(global));

// pakmanager:formidable/multipart_parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Buffer = require('buffer').Buffer,
        s = 0,
        S =
        { PARSER_UNINITIALIZED: s++,
          START: s++,
          START_BOUNDARY: s++,
          HEADER_FIELD_START: s++,
          HEADER_FIELD: s++,
          HEADER_VALUE_START: s++,
          HEADER_VALUE: s++,
          HEADER_VALUE_ALMOST_DONE: s++,
          HEADERS_ALMOST_DONE: s++,
          PART_DATA_START: s++,
          PART_DATA: s++,
          PART_END: s++,
          END: s++
        },
    
        f = 1,
        F =
        { PART_BOUNDARY: f,
          LAST_BOUNDARY: f *= 2
        },
    
        LF = 10,
        CR = 13,
        SPACE = 32,
        HYPHEN = 45,
        COLON = 58,
        A = 97,
        Z = 122,
    
        lower = function(c) {
          return c | 0x20;
        };
    
    for (s in S) {
      exports[s] = S[s];
    }
    
    function MultipartParser() {
      this.boundary = null;
      this.boundaryChars = null;
      this.lookbehind = null;
      this.state = S.PARSER_UNINITIALIZED;
    
      this.index = null;
      this.flags = 0;
    }
    exports.MultipartParser = MultipartParser;
    
    MultipartParser.stateToString = function(stateNumber) {
      for (var state in S) {
        var number = S[state];
        if (number === stateNumber) return state;
      }
    };
    
    MultipartParser.prototype.initWithBoundary = function(str) {
      this.boundary = new Buffer(str.length+4);
      this.boundary.write('\r\n--', 'ascii', 0);
      this.boundary.write(str, 'ascii', 4);
      this.lookbehind = new Buffer(this.boundary.length+8);
      this.state = S.START;
    
      this.boundaryChars = {};
      for (var i = 0; i < this.boundary.length; i++) {
        this.boundaryChars[this.boundary[i]] = true;
      }
    };
    
    MultipartParser.prototype.write = function(buffer) {
      var self = this,
          i = 0,
          len = buffer.length,
          prevIndex = this.index,
          index = this.index,
          state = this.state,
          flags = this.flags,
          lookbehind = this.lookbehind,
          boundary = this.boundary,
          boundaryChars = this.boundaryChars,
          boundaryLength = this.boundary.length,
          boundaryEnd = boundaryLength - 1,
          bufferLength = buffer.length,
          c,
          cl,
    
          mark = function(name) {
            self[name+'Mark'] = i;
          },
          clear = function(name) {
            delete self[name+'Mark'];
          },
          callback = function(name, buffer, start, end) {
            if (start !== undefined && start === end) {
              return;
            }
    
            var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);
            if (callbackSymbol in self) {
              self[callbackSymbol](buffer, start, end);
            }
          },
          dataCallback = function(name, clear) {
            var markSymbol = name+'Mark';
            if (!(markSymbol in self)) {
              return;
            }
    
            if (!clear) {
              callback(name, buffer, self[markSymbol], buffer.length);
              self[markSymbol] = 0;
            } else {
              callback(name, buffer, self[markSymbol], i);
              delete self[markSymbol];
            }
          };
    
      for (i = 0; i < len; i++) {
        c = buffer[i];
        switch (state) {
          case S.PARSER_UNINITIALIZED:
            return i;
          case S.START:
            index = 0;
            state = S.START_BOUNDARY;
          case S.START_BOUNDARY:
            if (index == boundary.length - 2) {
              if (c == HYPHEN) {
                flags |= F.LAST_BOUNDARY;
              } else if (c != CR) {
                return i;
              }
              index++;
              break;
            } else if (index - 1 == boundary.length - 2) {
              if (flags & F.LAST_BOUNDARY && c == HYPHEN){
                callback('end');
                state = S.END;
                flags = 0;
              } else if (!(flags & F.LAST_BOUNDARY) && c == LF) {
                index = 0;
                callback('partBegin');
                state = S.HEADER_FIELD_START;
              } else {
                return i;
              }
              break;
            }
    
            if (c != boundary[index+2]) {
              index = -2;
            }
            if (c == boundary[index+2]) {
              index++;
            }
            break;
          case S.HEADER_FIELD_START:
            state = S.HEADER_FIELD;
            mark('headerField');
            index = 0;
          case S.HEADER_FIELD:
            if (c == CR) {
              clear('headerField');
              state = S.HEADERS_ALMOST_DONE;
              break;
            }
    
            index++;
            if (c == HYPHEN) {
              break;
            }
    
            if (c == COLON) {
              if (index == 1) {
                // empty header field
                return i;
              }
              dataCallback('headerField', true);
              state = S.HEADER_VALUE_START;
              break;
            }
    
            cl = lower(c);
            if (cl < A || cl > Z) {
              return i;
            }
            break;
          case S.HEADER_VALUE_START:
            if (c == SPACE) {
              break;
            }
    
            mark('headerValue');
            state = S.HEADER_VALUE;
          case S.HEADER_VALUE:
            if (c == CR) {
              dataCallback('headerValue', true);
              callback('headerEnd');
              state = S.HEADER_VALUE_ALMOST_DONE;
            }
            break;
          case S.HEADER_VALUE_ALMOST_DONE:
            if (c != LF) {
              return i;
            }
            state = S.HEADER_FIELD_START;
            break;
          case S.HEADERS_ALMOST_DONE:
            if (c != LF) {
              return i;
            }
    
            callback('headersEnd');
            state = S.PART_DATA_START;
            break;
          case S.PART_DATA_START:
            state = S.PART_DATA;
            mark('partData');
          case S.PART_DATA:
            prevIndex = index;
    
            if (index === 0) {
              // boyer-moore derrived algorithm to safely skip non-boundary data
              i += boundaryEnd;
              while (i < bufferLength && !(buffer[i] in boundaryChars)) {
                i += boundaryLength;
              }
              i -= boundaryEnd;
              c = buffer[i];
            }
    
            if (index < boundary.length) {
              if (boundary[index] == c) {
                if (index === 0) {
                  dataCallback('partData', true);
                }
                index++;
              } else {
                index = 0;
              }
            } else if (index == boundary.length) {
              index++;
              if (c == CR) {
                // CR = part boundary
                flags |= F.PART_BOUNDARY;
              } else if (c == HYPHEN) {
                // HYPHEN = end boundary
                flags |= F.LAST_BOUNDARY;
              } else {
                index = 0;
              }
            } else if (index - 1 == boundary.length)  {
              if (flags & F.PART_BOUNDARY) {
                index = 0;
                if (c == LF) {
                  // unset the PART_BOUNDARY flag
                  flags &= ~F.PART_BOUNDARY;
                  callback('partEnd');
                  callback('partBegin');
                  state = S.HEADER_FIELD_START;
                  break;
                }
              } else if (flags & F.LAST_BOUNDARY) {
                if (c == HYPHEN) {
                  callback('partEnd');
                  callback('end');
                  state = S.END;
                  flags = 0;
                } else {
                  index = 0;
                }
              } else {
                index = 0;
              }
            }
    
            if (index > 0) {
              // when matching a possible boundary, keep a lookbehind reference
              // in case it turns out to be a false lead
              lookbehind[index-1] = c;
            } else if (prevIndex > 0) {
              // if our boundary turned out to be rubbish, the captured lookbehind
              // belongs to partData
              callback('partData', lookbehind, 0, prevIndex);
              prevIndex = 0;
              mark('partData');
    
              // reconsider the current character even so it interrupted the sequence
              // it could be the beginning of a new sequence
              i--;
            }
    
            break;
          case S.END:
            break;
          default:
            return i;
        }
      }
    
      dataCallback('headerField');
      dataCallback('headerValue');
      dataCallback('partData');
    
      this.index = index;
      this.state = state;
      this.flags = flags;
    
      return len;
    };
    
    MultipartParser.prototype.end = function() {
      var callback = function(self, name) {
        var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);
        if (callbackSymbol in self) {
          self[callbackSymbol]();
        }
      };
      if ((this.state == S.HEADER_FIELD_START && this.index === 0) ||
          (this.state == S.PART_DATA && this.index == this.boundary.length)) {
        callback(this, 'partEnd');
        callback(this, 'end');
      } else if (this.state != S.END) {
        return new Error('MultipartParser.end(): stream ended unexpectedly: ' + this.explain());
      }
    };
    
    MultipartParser.prototype.explain = function() {
      return 'state = ' + MultipartParser.stateToString(this.state);
    };
    
  provide("formidable/multipart_parser", module.exports);
}(global));

// pakmanager:formidable/querystring_parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  if (global.GENTLY) require = GENTLY.hijack(require);
    
    // This is a buffering parser, not quite as nice as the multipart one.
    // If I find time I'll rewrite this to be fully streaming as well
    var querystring = require('querystring');
    
    function QuerystringParser(maxKeys) {
      this.maxKeys = maxKeys;
      this.buffer = '';
    }
    exports.QuerystringParser = QuerystringParser;
    
    QuerystringParser.prototype.write = function(buffer) {
      this.buffer += buffer.toString('ascii');
      return buffer.length;
    };
    
    QuerystringParser.prototype.end = function() {
      var fields = querystring.parse(this.buffer, '&', '=', { maxKeys: this.maxKeys });
      for (var field in fields) {
        this.onField(field, fields[field]);
      }
      this.buffer = '';
    
      this.onEnd();
    };
    
    
  provide("formidable/querystring_parser", module.exports);
}(global));

// pakmanager:formidable/octet_parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var EventEmitter = require('events').EventEmitter
    	, util = require('util');
    
    function OctetParser(options){
    	if(!(this instanceof OctetParser)) return new OctetParser(options);
    	EventEmitter.call(this);
    }
    
    util.inherits(OctetParser, EventEmitter);
    
    exports.OctetParser = OctetParser;
    
    OctetParser.prototype.write = function(buffer) {
        this.emit('data', buffer);
    	return buffer.length;
    };
    
    OctetParser.prototype.end = function() {
    	this.emit('end');
    };
    
  provide("formidable/octet_parser", module.exports);
}(global));

// pakmanager:formidable/json_parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  if (global.GENTLY) require = GENTLY.hijack(require);
    
    var Buffer = require('buffer').Buffer;
    
    function JSONParser() {
      this.data = new Buffer('');
      this.bytesWritten = 0;
    }
    exports.JSONParser = JSONParser;
    
    JSONParser.prototype.initWithLength = function(length) {
      this.data = new Buffer(length);
    };
    
    JSONParser.prototype.write = function(buffer) {
      if (this.data.length >= this.bytesWritten + buffer.length) {
        buffer.copy(this.data, this.bytesWritten);
      } else {
        this.data = Buffer.concat([this.data, buffer]);
      }
      this.bytesWritten += buffer.length;
      return buffer.length;
    };
    
    JSONParser.prototype.end = function() {
      try {
        var fields = JSON.parse(this.data.toString('utf8'));
        for (var field in fields) {
          this.onField(field, fields[field]);
        }
      } catch (e) {}
      this.data = null;
    
      this.onEnd();
    };
    
  provide("formidable/json_parser", module.exports);
}(global));

// pakmanager:formidable/incoming_form
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  if (global.GENTLY) require = GENTLY.hijack(require);
    
    var fs = require('fs');
    var util = require('util'),
        path = require('path'),
        File =  require('formidable/file'),
        MultipartParser =  require('formidable/multipart_parser').MultipartParser,
        QuerystringParser =  require('formidable/querystring_parser').QuerystringParser,
        OctetParser       =  require('formidable/octet_parser').OctetParser,
        JSONParser =  require('formidable/json_parser').JSONParser,
        StringDecoder = require('string_decoder').StringDecoder,
        EventEmitter = require('events').EventEmitter,
        Stream = require('stream').Stream,
        os = require('os');
    
    function IncomingForm(opts) {
      if (!(this instanceof IncomingForm)) return new IncomingForm(opts);
      EventEmitter.call(this);
    
      opts=opts||{};
    
      this.error = null;
      this.ended = false;
    
      this.maxFields = opts.maxFields || 1000;
      this.maxFieldsSize = opts.maxFieldsSize || 2 * 1024 * 1024;
      this.keepExtensions = opts.keepExtensions || false;
      this.uploadDir = opts.uploadDir || os.tmpDir();
      this.encoding = opts.encoding || 'utf-8';
      this.headers = null;
      this.type = null;
      this.hash = opts.hash || false;
      this.multiples = opts.multiples || false;
    
      this.bytesReceived = null;
      this.bytesExpected = null;
    
      this._parser = null;
      this._flushing = 0;
      this._fieldsSize = 0;
      this.openedFiles = [];
    
      return this;
    }
    util.inherits(IncomingForm, EventEmitter);
    exports.IncomingForm = IncomingForm;
    
    IncomingForm.prototype.parse = function(req, cb) {
      this.pause = function() {
        try {
          req.pause();
        } catch (err) {
          // the stream was destroyed
          if (!this.ended) {
            // before it was completed, crash & burn
            this._error(err);
          }
          return false;
        }
        return true;
      };
    
      this.resume = function() {
        try {
          req.resume();
        } catch (err) {
          // the stream was destroyed
          if (!this.ended) {
            // before it was completed, crash & burn
            this._error(err);
          }
          return false;
        }
    
        return true;
      };
    
      // Setup callback first, so we don't miss anything from data events emitted
      // immediately.
      if (cb) {
        var fields = {}, files = {};
        this
          .on('field', function(name, value) {
            fields[name] = value;
          })
          .on('file', function(name, file) {
            if (this.multiples) {
              if (files[name]) {
                if (!Array.isArray(files[name])) {
                  files[name] = [files[name]];
                }
                files[name].push(file);
              } else {
                files[name] = file;
              }
            } else {
              files[name] = file;
            }
          })
          .on('error', function(err) {
            cb(err, fields, files);
          })
          .on('end', function() {
            cb(null, fields, files);
          });
      }
    
      // Parse headers and setup the parser, ready to start listening for data.
      this.writeHeaders(req.headers);
    
      // Start listening for data.
      var self = this;
      req
        .on('error', function(err) {
          self._error(err);
        })
        .on('aborted', function() {
          self.emit('aborted');
          self._error(new Error('Request aborted'));
        })
        .on('data', function(buffer) {
          self.write(buffer);
        })
        .on('end', function() {
          if (self.error) {
            return;
          }
    
          var err = self._parser.end();
          if (err) {
            self._error(err);
          }
        });
    
      return this;
    };
    
    IncomingForm.prototype.writeHeaders = function(headers) {
      this.headers = headers;
      this._parseContentLength();
      this._parseContentType();
    };
    
    IncomingForm.prototype.write = function(buffer) {
      if (this.error) {
        return;
      }
      if (!this._parser) {
        this._error(new Error('uninitialized parser'));
        return;
      }
    
      this.bytesReceived += buffer.length;
      this.emit('progress', this.bytesReceived, this.bytesExpected);
    
      var bytesParsed = this._parser.write(buffer);
      if (bytesParsed !== buffer.length) {
        this._error(new Error('parser error, '+bytesParsed+' of '+buffer.length+' bytes parsed'));
      }
    
      return bytesParsed;
    };
    
    IncomingForm.prototype.pause = function() {
      // this does nothing, unless overwritten in IncomingForm.parse
      return false;
    };
    
    IncomingForm.prototype.resume = function() {
      // this does nothing, unless overwritten in IncomingForm.parse
      return false;
    };
    
    IncomingForm.prototype.onPart = function(part) {
      // this method can be overwritten by the user
      this.handlePart(part);
    };
    
    IncomingForm.prototype.handlePart = function(part) {
      var self = this;
    
      if (part.filename === undefined) {
        var value = ''
          , decoder = new StringDecoder(this.encoding);
    
        part.on('data', function(buffer) {
          self._fieldsSize += buffer.length;
          if (self._fieldsSize > self.maxFieldsSize) {
            self._error(new Error('maxFieldsSize exceeded, received '+self._fieldsSize+' bytes of field data'));
            return;
          }
          value += decoder.write(buffer);
        });
    
        part.on('end', function() {
          self.emit('field', part.name, value);
        });
        return;
      }
    
      this._flushing++;
    
      var file = new File({
        path: this._uploadPath(part.filename),
        name: part.filename,
        type: part.mime,
        hash: self.hash
      });
    
      this.emit('fileBegin', part.name, file);
    
      file.open();
      this.openedFiles.push(file);
    
      part.on('data', function(buffer) {
        if (buffer.length == 0) {
          return;
        }
        self.pause();
        file.write(buffer, function() {
          self.resume();
        });
      });
    
      part.on('end', function() {
        file.end(function() {
          self._flushing--;
          self.emit('file', part.name, file);
          self._maybeEnd();
        });
      });
    };
    
    function dummyParser(self) {
      return {
        end: function () {
          self.ended = true;
          self._maybeEnd();
          return null;
        }
      };
    }
    
    IncomingForm.prototype._parseContentType = function() {
      if (this.bytesExpected === 0) {
        this._parser = dummyParser(this);
        return;
      }
    
      if (!this.headers['content-type']) {
        this._error(new Error('bad content-type header, no content-type'));
        return;
      }
    
      if (this.headers['content-type'].match(/octet-stream/i)) {
        this._initOctetStream();
        return;
      }
    
      if (this.headers['content-type'].match(/urlencoded/i)) {
        this._initUrlencoded();
        return;
      }
    
      if (this.headers['content-type'].match(/multipart/i)) {
        var m = this.headers['content-type'].match(/boundary=(?:"([^"]+)"|([^;]+))/i);
        if (m) {
          this._initMultipart(m[1] || m[2]);
        } else {
          this._error(new Error('bad content-type header, no multipart boundary'));
        }
        return;
      }
    
      if (this.headers['content-type'].match(/json/i)) {
        this._initJSONencoded();
        return;
      }
    
      this._error(new Error('bad content-type header, unknown content-type: '+this.headers['content-type']));
    };
    
    IncomingForm.prototype._error = function(err) {
      if (this.error || this.ended) {
        return;
      }
    
      this.error = err;
      this.emit('error', err);
    
      if (Array.isArray(this.openedFiles)) {
        this.openedFiles.forEach(function(file) {
          file._writeStream.destroy();
          setTimeout(fs.unlink, 0, file.path, function(error) { });
        });
      }
    };
    
    IncomingForm.prototype._parseContentLength = function() {
      this.bytesReceived = 0;
      if (this.headers['content-length']) {
        this.bytesExpected = parseInt(this.headers['content-length'], 10);
      } else if (this.headers['transfer-encoding'] === undefined) {
        this.bytesExpected = 0;
      }
    
      if (this.bytesExpected !== null) {
        this.emit('progress', this.bytesReceived, this.bytesExpected);
      }
    };
    
    IncomingForm.prototype._newParser = function() {
      return new MultipartParser();
    };
    
    IncomingForm.prototype._initMultipart = function(boundary) {
      this.type = 'multipart';
    
      var parser = new MultipartParser(),
          self = this,
          headerField,
          headerValue,
          part;
    
      parser.initWithBoundary(boundary);
    
      parser.onPartBegin = function() {
        part = new Stream();
        part.readable = true;
        part.headers = {};
        part.name = null;
        part.filename = null;
        part.mime = null;
    
        part.transferEncoding = 'binary';
        part.transferBuffer = '';
    
        headerField = '';
        headerValue = '';
      };
    
      parser.onHeaderField = function(b, start, end) {
        headerField += b.toString(self.encoding, start, end);
      };
    
      parser.onHeaderValue = function(b, start, end) {
        headerValue += b.toString(self.encoding, start, end);
      };
    
      parser.onHeaderEnd = function() {
        headerField = headerField.toLowerCase();
        part.headers[headerField] = headerValue;
    
        var m = headerValue.match(/\bname="([^"]+)"/i);
        if (headerField == 'content-disposition') {
          if (m) {
            part.name = m[1];
          }
    
          part.filename = self._fileName(headerValue);
        } else if (headerField == 'content-type') {
          part.mime = headerValue;
        } else if (headerField == 'content-transfer-encoding') {
          part.transferEncoding = headerValue.toLowerCase();
        }
    
        headerField = '';
        headerValue = '';
      };
    
      parser.onHeadersEnd = function() {
        switch(part.transferEncoding){
          case 'binary':
          case '7bit':
          case '8bit':
          parser.onPartData = function(b, start, end) {
            part.emit('data', b.slice(start, end));
          };
    
          parser.onPartEnd = function() {
            part.emit('end');
          };
          break;
    
          case 'base64':
          parser.onPartData = function(b, start, end) {
            part.transferBuffer += b.slice(start, end).toString('ascii');
    
            /*
            four bytes (chars) in base64 converts to three bytes in binary
            encoding. So we should always work with a number of bytes that
            can be divided by 4, it will result in a number of buytes that
            can be divided vy 3.
            */
            var offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
            part.emit('data', new Buffer(part.transferBuffer.substring(0, offset), 'base64'));
            part.transferBuffer = part.transferBuffer.substring(offset);
          };
    
          parser.onPartEnd = function() {
            part.emit('data', new Buffer(part.transferBuffer, 'base64'));
            part.emit('end');
          };
          break;
    
          default:
          return self._error(new Error('unknown transfer-encoding'));
        }
    
        self.onPart(part);
      };
    
    
      parser.onEnd = function() {
        self.ended = true;
        self._maybeEnd();
      };
    
      this._parser = parser;
    };
    
    IncomingForm.prototype._fileName = function(headerValue) {
      var m = headerValue.match(/\bfilename="(.*?)"($|; )/i);
      if (!m) return;
    
      var filename = m[1].substr(m[1].lastIndexOf('\\') + 1);
      filename = filename.replace(/%22/g, '"');
      filename = filename.replace(/&#([\d]{4});/g, function(m, code) {
        return String.fromCharCode(code);
      });
      return filename;
    };
    
    IncomingForm.prototype._initUrlencoded = function() {
      this.type = 'urlencoded';
    
      var parser = new QuerystringParser(this.maxFields)
        , self = this;
    
      parser.onField = function(key, val) {
        self.emit('field', key, val);
      };
    
      parser.onEnd = function() {
        self.ended = true;
        self._maybeEnd();
      };
    
      this._parser = parser;
    };
    
    IncomingForm.prototype._initOctetStream = function() {
      this.type = 'octet-stream';
      var filename = this.headers['x-file-name'];
      var mime = this.headers['content-type'];
    
      var file = new File({
        path: this._uploadPath(filename),
        name: filename,
        type: mime
      });
    
      this.emit('fileBegin', filename, file);
      file.open();
    
      this._flushing++;
    
      var self = this;
    
      self._parser = new OctetParser();
    
      //Keep track of writes that haven't finished so we don't emit the file before it's done being written
      var outstandingWrites = 0;
    
      self._parser.on('data', function(buffer){
        self.pause();
        outstandingWrites++;
    
        file.write(buffer, function() {
          outstandingWrites--;
          self.resume();
    
          if(self.ended){
            self._parser.emit('doneWritingFile');
          }
        });
      });
    
      self._parser.on('end', function(){
        self._flushing--;
        self.ended = true;
    
        var done = function(){
          file.end(function() {
            self.emit('file', 'file', file);
            self._maybeEnd();
          });
        };
    
        if(outstandingWrites === 0){
          done();
        } else {
          self._parser.once('doneWritingFile', done);
        }
      });
    };
    
    IncomingForm.prototype._initJSONencoded = function() {
      this.type = 'json';
    
      var parser = new JSONParser()
        , self = this;
    
      if (this.bytesExpected) {
        parser.initWithLength(this.bytesExpected);
      }
    
      parser.onField = function(key, val) {
        self.emit('field', key, val);
      };
    
      parser.onEnd = function() {
        self.ended = true;
        self._maybeEnd();
      };
    
      this._parser = parser;
    };
    
    IncomingForm.prototype._uploadPath = function(filename) {
      var name = '';
      for (var i = 0; i < 32; i++) {
        name += Math.floor(Math.random() * 16).toString(16);
      }
    
      if (this.keepExtensions) {
        var ext = path.extname(filename);
        ext     = ext.replace(/(\.[a-z0-9]+).*/i, '$1');
    
        name += ext;
      }
    
      return path.join(this.uploadDir, name);
    };
    
    IncomingForm.prototype._maybeEnd = function() {
      if (!this.ended || this._flushing || this.error) {
        return;
      }
    
      this.emit('end');
    };
    
    
  provide("formidable/incoming_form", module.exports);
}(global));

// pakmanager:formidable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var IncomingForm =  require('formidable/incoming_form').IncomingForm;
    IncomingForm.IncomingForm = IncomingForm;
    module.exports = IncomingForm;
    
  provide("formidable", module.exports);
}(global));

// pakmanager:component-emitter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Emitter`.
     */
    
    module.exports = Emitter;
    
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */
    
    function Emitter(obj) {
      if (obj) return mixin(obj);
    };
    
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */
    
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks[event] = this._callbacks[event] || [])
        .push(fn);
      return this;
    };
    
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.once = function(event, fn){
      var self = this;
      this._callbacks = this._callbacks || {};
    
      function on() {
        self.off(event, on);
        fn.apply(this, arguments);
      }
    
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
    
      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
    
      // specific event
      var callbacks = this._callbacks[event];
      if (!callbacks) return this;
    
      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks[event];
        return this;
      }
    
      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */
    
    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1)
        , callbacks = this._callbacks[event];
    
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
    
      return this;
    };
    
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */
    
    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks[event] || [];
    };
    
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */
    
    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    
  provide("component-emitter", module.exports);
}(global));

// pakmanager:methods
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var http = require('http');
    
    if (http.METHODS) {
    
      module.exports = http.METHODS.map(function(method){
        return method.toLowerCase();
      });
    
    } else {
    
      module.exports = [
        'get',
        'post',
        'put',
        'head',
        'delete',
        'options',
        'trace',
        'copy',
        'lock',
        'mkcol',
        'move',
        'purge',
        'propfind',
        'proppatch',
        'unlock',
        'report',
        'mkactivity',
        'checkout',
        'merge',
        'm-search',
        'notify',
        'subscribe',
        'unsubscribe',
        'patch',
        'search',
        'connect'
      ];
    
    }
    
  provide("methods", module.exports);
}(global));

// pakmanager:cookiejar
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* jshint node: true */
    (function () {
        "use strict";
    
        function CookieAccessInfo(domain, path, secure, script) {
            if (this instanceof CookieAccessInfo) {
                this.domain = domain || undefined;
                this.path = path || "/";
                this.secure = !!secure;
                this.script = !!script;
                return this;
            }
            return new CookieAccessInfo(domain, path, secure, script);
        }
        exports.CookieAccessInfo = CookieAccessInfo;
    
        function Cookie(cookiestr, request_domain, request_path) {
            if (cookiestr instanceof Cookie) {
                return cookiestr;
            }
            if (this instanceof Cookie) {
                this.name = null;
                this.value = null;
                this.expiration_date = Infinity;
                this.path = String(request_path || "/");
                this.explicit_path = false;
                this.domain = request_domain || null;
                this.explicit_domain = false;
                this.secure = false; //how to define default?
                this.noscript = false; //httponly
                if (cookiestr) {
                    this.parse(cookiestr, request_domain, request_path);
                }
                return this;
            }
            return new Cookie(cookiestr);
        }
        exports.Cookie = Cookie;
    
        Cookie.prototype.toString = function toString() {
            var str = [this.name + "=" + this.value];
            if (this.expiration_date !== Infinity) {
                str.push("expires=" + (new Date(this.expiration_date)).toGMTString());
            }
            if (this.domain) {
                str.push("domain=" + this.domain);
            }
            if (this.path) {
                str.push("path=" + this.path);
            }
            if (this.secure) {
                str.push("secure");
            }
            if (this.noscript) {
                str.push("httponly");
            }
            return str.join("; ");
        };
    
        Cookie.prototype.toValueString = function toValueString() {
            return this.name + "=" + this.value;
        };
    
        var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
        Cookie.prototype.parse = function parse(str, request_domain, request_path) {
            if (this instanceof Cookie) {
                var parts = str.split(";").filter(function (value) {
                        return !!value;
                    }),
                    pair = parts[0].match(/([^=]+)=([\s\S]*)/),
                    key = pair[1],
                    value = pair[2],
                    i;
                this.name = key;
                this.value = value;
    
                for (i = 1; i < parts.length; i += 1) {
                    pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
                    key = pair[1].trim().toLowerCase();
                    value = pair[2];
                    switch (key) {
                    case "httponly":
                        this.noscript = true;
                        break;
                    case "expires":
                        this.expiration_date = value ?
                                Number(Date.parse(value)) :
                                Infinity;
                        break;
                    case "path":
                        this.path = value ?
                                value.trim() :
                                "";
                        this.explicit_path = true;
                        break;
                    case "domain":
                        this.domain = value ?
                                value.trim() :
                                "";
                        this.explicit_domain = !!this.domain;
                        break;
                    case "secure":
                        this.secure = true;
                        break;
                    }
                }
    
                if (!this.explicit_path) {
                   this.path = request_path || "/";
                }
                if (!this.explicit_domain) {
                   this.domain = request_domain;
                }
    
                return this;
            }
            return new Cookie().parse(str, request_domain, request_path);
        };
    
        Cookie.prototype.matches = function matches(access_info) {
            if (this.noscript && access_info.script ||
                    this.secure && !access_info.secure ||
                    !this.collidesWith(access_info)) {
                return false;
            }
            return true;
        };
    
        Cookie.prototype.collidesWith = function collidesWith(access_info) {
            if ((this.path && !access_info.path) || (this.domain && !access_info.domain)) {
                return false;
            }
            if (this.path && access_info.path.indexOf(this.path) !== 0) {
                return false;
            }
            if (!this.explicit_path) {
               if (this.path !== access_info.path) {
                   return false;
               }
            }
            var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/,'');
            var cookie_domain = this.domain && this.domain.replace(/^[\.]/,'');
            if (cookie_domain === access_domain) {
                return true;
            }
            if (cookie_domain) {
                if (!this.explicit_domain) {
                    return false; // we already checked if the domains were exactly the same
                }
                var wildcard = access_domain.indexOf(cookie_domain);
                if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
                    return false;
                }
                return true;
            }
            return true;
        };
    
        function CookieJar() {
            var cookies, cookies_list, collidable_cookie;
            if (this instanceof CookieJar) {
                cookies = Object.create(null); //name: [Cookie]
    
                this.setCookie = function setCookie(cookie, request_domain, request_path) {
                    var remove, i;
                    cookie = new Cookie(cookie, request_domain, request_path);
                    //Delete the cookie if the set is past the current time
                    remove = cookie.expiration_date <= Date.now();
                    if (cookies[cookie.name] !== undefined) {
                        cookies_list = cookies[cookie.name];
                        for (i = 0; i < cookies_list.length; i += 1) {
                            collidable_cookie = cookies_list[i];
                            if (collidable_cookie.collidesWith(cookie)) {
                                if (remove) {
                                    cookies_list.splice(i, 1);
                                    if (cookies_list.length === 0) {
                                        delete cookies[cookie.name];
                                    }
                                    return false;
                                }
                                cookies_list[i] = cookie;
                                return cookie;
                            }
                        }
                        if (remove) {
                            return false;
                        }
                        cookies_list.push(cookie);
                        return cookie;
                    }
                    if (remove) {
                        return false;
                    }
                    cookies[cookie.name] = [cookie];
                    return cookies[cookie.name];
                };
                //returns a cookie
                this.getCookie = function getCookie(cookie_name, access_info) {
                    var cookie, i;
                    cookies_list = cookies[cookie_name];
                    if (!cookies_list) {
                        return;
                    }
                    for (i = 0; i < cookies_list.length; i += 1) {
                        cookie = cookies_list[i];
                        if (cookie.expiration_date <= Date.now()) {
                            if (cookies_list.length === 0) {
                                delete cookies[cookie.name];
                            }
                            continue;
                        }
                        if (cookie.matches(access_info)) {
                            return cookie;
                        }
                    }
                };
                //returns a list of cookies
                this.getCookies = function getCookies(access_info) {
                    var matches = [], cookie_name, cookie;
                    for (cookie_name in cookies) {
                        cookie = this.getCookie(cookie_name, access_info);
                        if (cookie) {
                            matches.push(cookie);
                        }
                    }
                    matches.toString = function toString() {
                        return matches.join(":");
                    };
                    matches.toValueString = function toValueString() {
                        return matches.map(function (c) {
                            return c.toValueString();
                        }).join(';');
                    };
                    return matches;
                };
    
                return this;
            }
            return new CookieJar();
        }
        exports.CookieJar = CookieJar;
    
        //returns list of cookies that were set correctly. Cookies that are expired and removed are not returned.
        CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
            cookies = Array.isArray(cookies) ?
                    cookies :
                    cookies.split(cookie_str_splitter);
            var successful = [],
                i,
                cookie;
            cookies = cookies.map(Cookie);
            for (i = 0; i < cookies.length; i += 1) {
                cookie = cookies[i];
                if (this.setCookie(cookie, request_domain, request_path)) {
                    successful.push(cookie);
                }
            }
            return successful;
        };
    }());
    
  provide("cookiejar", module.exports);
}(global));

// pakmanager:debug
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var tty = require('tty');
    var util = require('util');
    
    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports =   require('debug');
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    
    /**
     * Colors.
     */
    
    exports.colors = [6, 2, 3, 4, 5, 1];
    
    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */
    
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    var stream = 1 === fd ? process.stdout :
                 2 === fd ? process.stderr :
                 createWritableStdioStream(fd);
    
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */
    
    function useColors() {
      var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
      if (0 === debugColors.length) {
        return tty.isatty(fd);
      } else {
        return '0' !== debugColors
            && 'no' !== debugColors
            && 'false' !== debugColors
            && 'disabled' !== debugColors;
      }
    }
    
    /**
     * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
     */
    
    var inspect = (4 === util.inspect.length ?
      // node <= 0.8.x
      function (v, colors) {
        return util.inspect(v, void 0, void 0, colors);
      } :
      // node > 0.8.x
      function (v, colors) {
        return util.inspect(v, { colors: colors });
      }
    );
    
    exports.formatters.o = function(v) {
      return inspect(v, this.useColors)
        .replace(/\s*\n\s*/g, ' ');
    };
    
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */
    
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      var name = this.namespace;
    
      if (useColors) {
        var c = this.color;
    
        args[0] = '  \u001b[9' + c + 'm' + name + ' '
          + '\u001b[0m'
          + args[0] + '\u001b[3' + c + 'm'
          + ' +' + exports.humanize(this.diff) + '\u001b[0m';
      } else {
        args[0] = new Date().toUTCString()
          + ' ' + name + ' ' + args[0];
      }
      return args;
    }
    
    /**
     * Invokes `console.error()` with the specified arguments.
     */
    
    function log() {
      return stream.write(util.format.apply(this, arguments) + '\n');
    }
    
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    
    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    
    function load() {
      return process.env.DEBUG;
    }
    
    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */
    
    function createWritableStdioStream (fd) {
      var stream;
      var tty_wrap = process.binding('tty_wrap');
    
      // Note stream._type is used for test-module-load-list.js
    
      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          stream = new tty.WriteStream(fd);
          stream._type = 'tty';
    
          // Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        case 'FILE':
          var fs = require('fs');
          stream = new fs.SyncWriteStream(fd, { autoClose: false });
          stream._type = 'fs';
          break;
    
        case 'PIPE':
        case 'TCP':
          var net = require('net');
          stream = new net.Socket({
            fd: fd,
            readable: false,
            writable: true
          });
    
          // FIXME Should probably have an option in net.Socket to create a
          // stream from an existing fd which is writable only. But for now
          // we'll just add this hack and set the `readable` member to false.
          // Test: ./node test/fixtures/echo.js < /etc/passwd
          stream.readable = false;
          stream.read = null;
          stream._type = 'pipe';
    
          // FIXME Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stream file type!');
      }
    
      // For supporting legacy API we put the FD here.
      stream.fd = fd;
    
      stream._isStdio = true;
    
      return stream;
    }
    
    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */
    
    exports.enable(load());
    
  provide("debug", module.exports);
}(global));

// pakmanager:reduce-component
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Reduce `arr` with `fn`.
     *
     * @param {Array} arr
     * @param {Function} fn
     * @param {Mixed} initial
     *
     * TODO: combatible error handling?
     */
    
    module.exports = function(arr, fn, initial){  
      var idx = 0;
      var len = arr.length;
      var curr = arguments.length == 3
        ? initial
        : arr[idx++];
    
      while (idx < len) {
        curr = fn.call(null, curr, arr[idx], ++idx, arr);
      }
      
      return curr;
    };
  provide("reduce-component", module.exports);
}(global));

// pakmanager:extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    var undefined;
    
    var isPlainObject = function isPlainObject(obj) {
    	"use strict";
    	if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval) {
    		return false;
    	}
    
    	var has_own_constructor = hasOwn.call(obj, 'constructor');
    	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    	// Not own constructor property must be Object
    	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
    		return false;
    	}
    
    	// Own properties are enumerated firstly, so to speed up,
    	// if last one is own, then all properties are own.
    	var key;
    	for (key in obj) {}
    
    	return key === undefined || hasOwn.call(obj, key);
    };
    
    module.exports = function extend() {
    	"use strict";
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[0],
    		i = 1,
    		length = arguments.length,
    		deep = false;
    
    	// Handle a deep copy situation
    	if (typeof target === "boolean") {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	} else if (typeof target !== "object" && typeof target !== "function" || target == undefined) {
    			target = {};
    	}
    
    	for (; i < length; ++i) {
    		// Only deal with non-null/undefined values
    		if ((options = arguments[i]) != null) {
    			// Extend the base object
    			for (name in options) {
    				src = target[name];
    				copy = options[name];
    
    				// Prevent never-ending loop
    				if (target === copy) {
    					continue;
    				}
    
    				// Recurse if we're merging plain objects or arrays
    				if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
    					if (copyIsArray) {
    						copyIsArray = false;
    						clone = src && Array.isArray(src) ? src : [];
    					} else {
    						clone = src && isPlainObject(src) ? src : {};
    					}
    
    					// Never move original objects, clone them
    					target[name] = extend(deep, clone, copy);
    
    				// Don't bring in undefined values
    				} else if (copy !== undefined) {
    					target[name] = copy;
    				}
    			}
    		}
    	}
    
    	// Return the modified object
    	return target;
    };
    
    
  provide("extend", module.exports);
}(global));

// pakmanager:form-data
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var CombinedStream = require('combined-stream');
    var util = require('util');
    var path = require('path');
    var http = require('http');
    var https = require('https');
    var parseUrl = require('url').parse;
    var fs = require('fs');
    var mime = require('mime');
    var async = require('async');
    
    module.exports = FormData;
    function FormData() {
      this._overheadLength = 0;
      this._valueLength = 0;
      this._lengthRetrievers = [];
    
      CombinedStream.call(this);
    }
    util.inherits(FormData, CombinedStream);
    
    FormData.LINE_BREAK = '\r\n';
    
    FormData.prototype.append = function(field, value, options) {
      options = options || {};
    
      var append = CombinedStream.prototype.append.bind(this);
    
      // all that streamy business can't handle numbers
      if (typeof value == 'number') value = ''+value;
    
      // https://github.com/felixge/node-form-data/issues/38
      if (util.isArray(value)) {
        // Please convert your array into string
        // the way web server expects it
        this._error(new Error('Arrays are not supported.'));
        return;
      }
    
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter(field, value, options);
    
      append(header);
      append(value);
      append(footer);
    
      // pass along options.knownLength
      this._trackLength(header, value, options);
    };
    
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
    
      // used w/ getLengthSync(), when length is known.
      // e.g. for streaming directly from a remote server,
      // w/ a known file a size, and not wanting to wait for
      // incoming file to finish to get its size.
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
      }
    
      this._valueLength += valueLength;
    
      // @check why add CRLF? does this account for custom/multiple CRLFs?
      this._overheadLength +=
        Buffer.byteLength(header) +
        + FormData.LINE_BREAK.length;
    
      // empty or either doesn't have path or not an http response
      if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
        return;
      }
    
      // no need to bother with the length
      if (!options.knownLength)
      this._lengthRetrievers.push(function(next) {
    
        if (value.hasOwnProperty('fd')) {
    
          // take read range into a account
          // `end` = Infinity –> read file till the end
          //
          // TODO: Looks like there is bug in Node fs.createReadStream
          // it doesn't respect `end` options without `start` options
          // Fix it when node fixes it.
          // https://github.com/joyent/node/issues/7819
          if (value.end != undefined && value.end != Infinity && value.start != undefined) {
    
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            next(null, value.end+1 - (value.start ? value.start : 0));
    
          // not that fast snoopy
          } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
    
              var fileSize;
    
              if (err) {
                next(err);
                return;
              }
    
              // update final size based on the range options
              fileSize = stat.size - (value.start ? value.start : 0);
              next(null, fileSize);
            });
          }
    
        // or http response
        } else if (value.hasOwnProperty('httpVersion')) {
          next(null, +value.headers['content-length']);
    
        // or request stream http://github.com/mikeal/request
        } else if (value.hasOwnProperty('httpModule')) {
          // wait till response come back
          value.on('response', function(response) {
            value.pause();
            next(null, +response.headers['content-length']);
          });
          value.resume();
    
        // something else
        } else {
          next('Unknown stream');
        }
      });
    };
    
    FormData.prototype._multiPartHeader = function(field, value, options) {
      var boundary = this.getBoundary();
      var header = '';
    
      // custom header specified (as string)?
      // it becomes responsible for boundary
      // (e.g. to handle extra CRLFs on .NET servers)
      if (options.header != null) {
        header = options.header;
      } else {
        header += '--' + boundary + FormData.LINE_BREAK +
          'Content-Disposition: form-data; name="' + field + '"';
    
        // fs- and request- streams have path property
        // or use custom filename and/or contentType
        // TODO: Use request's response mime-type
        if (options.filename || value.path) {
          header +=
            '; filename="' + path.basename(options.filename || value.path) + '"' + FormData.LINE_BREAK +
            'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));
    
        // http response has not
        } else if (value.readable && value.hasOwnProperty('httpVersion')) {
          header +=
            '; filename="' + path.basename(value.client._httpMessage.path) + '"' + FormData.LINE_BREAK +
            'Content-Type: ' + value.headers['content-type'];
        }
    
        header += FormData.LINE_BREAK + FormData.LINE_BREAK;
      }
    
      return header;
    };
    
    FormData.prototype._multiPartFooter = function(field, value, options) {
      return function(next) {
        var footer = FormData.LINE_BREAK;
    
        var lastPart = (this._streams.length === 0);
        if (lastPart) {
          footer += this._lastBoundary();
        }
    
        next(footer);
      }.bind(this);
    };
    
    FormData.prototype._lastBoundary = function() {
      return '--' + this.getBoundary() + '--';
    };
    
    FormData.prototype.getHeaders = function(userHeaders) {
      var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
      };
    
      for (var header in userHeaders) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    
      return formHeaders;
    }
    
    FormData.prototype.getCustomHeaders = function(contentType) {
        contentType = contentType ? contentType : 'multipart/form-data';
    
        var formHeaders = {
            'content-type': contentType + '; boundary=' + this.getBoundary(),
            'content-length': this.getLengthSync()
        };
    
        return formHeaders;
    }
    
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
    
      return this._boundary;
    };
    
    FormData.prototype._generateBoundary = function() {
      // This generates a 50 character boundary similar to those used by Firefox.
      // They are optimized for boyer-moore parsing.
      var boundary = '--------------------------';
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
    
      this._boundary = boundary;
    };
    
    // Note: getLengthSync DOESN'T calculate streams length
    // As workaround one can calculate file size manually
    // and add it as knownLength option
    FormData.prototype.getLengthSync = function(debug) {
      var knownLength = this._overheadLength + this._valueLength;
    
      // Don't get confused, there are 3 "internal" streams for each keyval pair
      // so it basically checks if there is any value added to the form
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
    
      // https://github.com/felixge/node-form-data/issues/40
      if (this._lengthRetrievers.length) {
        // Some async length retrivers are present
        // therefore synchronous length calculation is false.
        // Please use getLength(callback) to get proper length
        this._error(new Error('Cannot calculate proper length in synchronous way.'));
      }
    
      return knownLength;
    };
    
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
    
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
    
      if (!this._lengthRetrievers.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
    
      async.parallel(this._lengthRetrievers, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
    
        values.forEach(function(length) {
          knownLength += length;
        });
    
        cb(null, knownLength);
      });
    };
    
    FormData.prototype.submit = function(params, cb) {
    
      var request
        , options
        , defaults = {
            method : 'post'
        };
    
      // parse provided url if it's string
      // or treat it as options object
      if (typeof params == 'string') {
        params = parseUrl(params);
    
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname
        }, defaults);
      }
      else // use custom params
      {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
          options.port = options.protocol == 'https:' ? 443 : 80;
        }
      }
    
      // put that good code in getHeaders to some use
      options.headers = this.getHeaders(params.headers);
    
      // https if specified, fallback to http in any other case
      if (params.protocol == 'https:') {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
    
      // get content length and fire away
      this.getLength(function(err, length) {
    
        // TODO: Add chunked encoding when no length (if err)
    
        // add content length
        request.setHeader('Content-Length', length);
    
        this.pipe(request);
        if (cb) {
          request.on('error', cb);
          request.on('response', cb.bind(this, null));
        }
      }.bind(this));
    
      return request;
    };
    
    FormData.prototype._error = function(err) {
      if (this.error) return;
    
      this.error = err;
      this.pause();
      this.emit('error', err);
    };
    
    /*
     * Santa's little helpers
     */
    
    // populates missing values
    function populate(dst, src) {
      for (var prop in src) {
        if (!dst[prop]) dst[prop] = src[prop];
      }
      return dst;
    }
    
  provide("form-data", module.exports);
}(global));

// pakmanager:util/support/isBuffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function isBuffer(arg) {
      return arg instanceof Buffer;
    }
    
  provide("util/support/isBuffer", module.exports);
}(global));

// pakmanager:util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
    
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    
    
    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    exports.deprecate = function(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined(global.process)) {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
    
      if (process.noDeprecation === true) {
        return fn;
      }
    
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
    
      return deprecated;
    };
    
    
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    
    
    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    
    
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };
    
    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };
    
    
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
    
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    
    
    function stylizeNoColor(str, styleType) {
      return str;
    }
    
    
    function arrayToHash(array) {
      var hash = {};
    
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
    
      return hash;
    }
    
    
    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
    
      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
    
      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
    
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
    
      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
    
      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
    
      var base = '', array = false, braces = ['{', '}'];
    
      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
    
      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
    
      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
    
      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
    
      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
    
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
    
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
    
      ctx.seen.push(value);
    
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
    
      ctx.seen.pop();
    
      return reduceToSingleString(output, base, braces);
    }
    
    
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    
    
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    
    
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }
    
    
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
    
      return name + ': ' + str;
    }
    
    
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
    
      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }
    
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    
    
    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    
    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    
    exports.isBuffer =  require('util/support/isBuffer');
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    
    
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    
    
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];
    
    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    
    
    // log is just a thin wrapper to console.log that prepends a timestamp
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    
    
    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * The Function.prototype.inherits from lang.js rewritten as a standalone
     * function (not on Function.prototype). NOTE: If this file is to be loaded
     * during bootstrapping this function needs to be rewritten using some native
     * functions as prototype setup using normal JavaScript does not work as
     * expected during bootstrapping (see mirror.js in r114903).
     *
     * @param {function} ctor Constructor function which needs to inherit the
     *     prototype.
     * @param {function} superCtor Constructor function to inherit prototype from.
     */
    exports.inherits = require('inherits');
    
    exports._extend = function(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;
    
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    
  provide("util", module.exports);
}(global));

// pakmanager:growl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)
    
    /**
     * Module dependencies.
     */
    
    var exec = require('child_process').exec
      , fs = require('fs')
      , path = require('path')
      , exists = fs.existsSync || path.existsSync
      , os = require('os')
      , quote = JSON.stringify
      , cmd;
    
    function which(name) {
      var paths = process.env.PATH.split(':');
      var loc;
      
      for (var i = 0, len = paths.length; i < len; ++i) {
        loc = path.join(paths[i], name);
        if (exists(loc)) return loc;
      }
    }
    
    switch(os.type()) {
      case 'Darwin':
        if (which('terminal-notifier')) {
          cmd = {
              type: "Darwin-NotificationCenter"
            , pkg: "terminal-notifier"
            , msg: '-message'
            , title: '-title'
            , subtitle: '-subtitle'
            , priority: {
                  cmd: '-execute'
                , range: []
              }
          };
        } else {
          cmd = {
              type: "Darwin-Growl"
            , pkg: "growlnotify"
            , msg: '-m'
            , sticky: '--sticky'
            , priority: {
                  cmd: '--priority'
                , range: [
                    -2
                  , -1
                  , 0
                  , 1
                  , 2
                  , "Very Low"
                  , "Moderate"
                  , "Normal"
                  , "High"
                  , "Emergency"
                ]
              }
          };
        }
        break;
      case 'Linux':
        cmd = {
            type: "Linux"
          , pkg: "notify-send"
          , msg: ''
          , sticky: '-t 0'
          , icon: '-i'
          , priority: {
              cmd: '-u'
            , range: [
                "low"
              , "normal"
              , "critical"
            ]
          }
        };
        break;
      case 'Windows_NT':
        cmd = {
            type: "Windows"
          , pkg: "growlnotify"
          , msg: ''
          , sticky: '/s:true'
          , title: '/t:'
          , icon: '/i:'
          , priority: {
                cmd: '/p:'
              , range: [
                  -2
                , -1
                , 0
                , 1
                , 2
              ]
            }
        };
        break;
    }
    
    /**
     * Expose `growl`.
     */
    
    exports = module.exports = growl;
    
    /**
     * Node-growl version.
     */
    
    exports.version = '1.4.1'
    
    /**
     * Send growl notification _msg_ with _options_.
     *
     * Options:
     *
     *  - title   Notification title
     *  - sticky  Make the notification stick (defaults to false)
     *  - priority  Specify an int or named key (default is 0)
     *  - name    Application name (defaults to growlnotify)
     *  - image
     *    - path to an icon sets --iconpath
     *    - path to an image sets --image
     *    - capitalized word sets --appIcon
     *    - filename uses extname as --icon
     *    - otherwise treated as --icon
     *
     * Examples:
     *
     *   growl('New email')
     *   growl('5 new emails', { title: 'Thunderbird' })
     *   growl('Email sent', function(){
     *     // ... notification sent
     *   })
     *
     * @param {string} msg
     * @param {object} options
     * @param {function} fn
     * @api public
     */
    
    function growl(msg, options, fn) {
      var image
        , args
        , options = options || {}
        , fn = fn || function(){};
    
      // noop
      if (!cmd) return fn(new Error('growl not supported on this platform'));
      args = [cmd.pkg];
    
      // image
      if (image = options.image) {
        switch(cmd.type) {
          case 'Darwin-Growl':
            var flag, ext = path.extname(image).substr(1)
            flag = flag || ext == 'icns' && 'iconpath'
            flag = flag || /^[A-Z]/.test(image) && 'appIcon'
            flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'
            flag = flag || ext && (image = ext) && 'icon'
            flag = flag || 'icon'
            args.push('--' + flag, quote(image))
            break;
          case 'Linux':
            args.push(cmd.icon, quote(image));
            // libnotify defaults to sticky, set a hint for transient notifications
            if (!options.sticky) args.push('--hint=int:transient:1');
            break;
          case 'Windows':
            args.push(cmd.icon + quote(image));
            break;
        }
      }
    
      // sticky
      if (options.sticky) args.push(cmd.sticky);
    
      // priority
      if (options.priority) {
        var priority = options.priority + '';
        var checkindexOf = cmd.priority.range.indexOf(priority);
        if (~cmd.priority.range.indexOf(priority)) {
          args.push(cmd.priority, options.priority);
        }
      }
    
      // name
      if (options.name && cmd.type === "Darwin-Growl") {
        args.push('--name', options.name);
      }
    
      switch(cmd.type) {
        case 'Darwin-Growl':
          args.push(cmd.msg);
          args.push(quote(msg));
          if (options.title) args.push(quote(options.title));
          break;
        case 'Darwin-NotificationCenter':
          args.push(cmd.msg);
          args.push(quote(msg));
          if (options.title) {
            args.push(cmd.title);
            args.push(quote(options.title));
          }
          if (options.subtitle) {
            args.push(cmd.subtitle);
            args.push(quote(options.subtitle));
          }
          break;
        case 'Darwin-Growl':
          args.push(cmd.msg);
          args.push(quote(msg));
          if (options.title) args.push(quote(options.title));
          break;
        case 'Linux':
          if (options.title) {
            args.push(quote(options.title));
            args.push(cmd.msg);
            args.push(quote(msg));
          } else {
            args.push(quote(msg));
          }
          break;
        case 'Windows':
          args.push(quote(msg));
          if (options.title) args.push(cmd.title + quote(options.title));
          break;
      }
    
      // execute
      exec(args.join(' '), fn);
    };
    
  provide("growl", module.exports);
}(global));

// pakmanager:jade/lib/nodes/node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node = module.exports = function Node(){};
    
    /**
     * Clone this node (return itself)
     *
     * @return {Node}
     * @api private
     */
    
    Node.prototype.clone = function(){
      var err = new Error('node.clone is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
      return this;
    };
    
    Node.prototype.type = '';
    
  provide("jade/lib/nodes/node", module.exports);
}(global));

// pakmanager:jade/lib/nodes/attrs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Attrs` node.
     *
     * @api public
     */
    
    var Attrs = module.exports = function Attrs() {
      this.attributeNames = [];
      this.attrs = [];
      this.attributeBlocks = [];
    };
    
    // Inherit from `Node`.
    Attrs.prototype = Object.create(Node.prototype);
    Attrs.prototype.constructor = Attrs;
    
    Attrs.prototype.type = 'Attrs';
    
    /**
     * Set attribute `name` to `val`, keep in mind these become
     * part of a raw js object literal, so to quote a value you must
     * '"quote me"', otherwise or example 'user.name' is literal JavaScript.
     *
     * @param {String} name
     * @param {String} val
     * @param {Boolean} escaped
     * @return {Tag} for chaining
     * @api public
     */
    
    Attrs.prototype.setAttribute = function(name, val, escaped){
      if (name !== 'class' && this.attributeNames.indexOf(name) !== -1) {
        throw new Error('Duplicate attribute "' + name + '" is not allowed.');
      }
      this.attributeNames.push(name);
      this.attrs.push({ name: name, val: val, escaped: escaped });
      return this;
    };
    
    /**
     * Remove attribute `name` when present.
     *
     * @param {String} name
     * @api public
     */
    
    Attrs.prototype.removeAttribute = function(name){
      var err = new Error('attrs.removeAttribute is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      for (var i = 0, len = this.attrs.length; i < len; ++i) {
        if (this.attrs[i] && this.attrs[i].name == name) {
          delete this.attrs[i];
        }
      }
    };
    
    /**
     * Get attribute value by `name`.
     *
     * @param {String} name
     * @return {String}
     * @api public
     */
    
    Attrs.prototype.getAttribute = function(name){
      var err = new Error('attrs.getAttribute is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      for (var i = 0, len = this.attrs.length; i < len; ++i) {
        if (this.attrs[i] && this.attrs[i].name == name) {
          return this.attrs[i].val;
        }
      }
    };
    
    Attrs.prototype.addAttributes = function (src) {
      this.attributeBlocks.push(src);
    };
    
  provide("jade/lib/nodes/attrs", module.exports);
}(global));

// pakmanager:jade/lib/nodes/block
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a new `Block` with an optional `node`.
     *
     * @param {Node} node
     * @api public
     */
    
    var Block = module.exports = function Block(node){
      this.nodes = [];
      if (node) this.push(node);
    };
    
    // Inherit from `Node`.
    Block.prototype = Object.create(Node.prototype);
    Block.prototype.constructor = Block;
    
    Block.prototype.type = 'Block';
    
    /**
     * Block flag.
     */
    
    Block.prototype.isBlock = true;
    
    /**
     * Replace the nodes in `other` with the nodes
     * in `this` block.
     *
     * @param {Block} other
     * @api private
     */
    
    Block.prototype.replace = function(other){
      var err = new Error('block.replace is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      other.nodes = this.nodes;
    };
    
    /**
     * Push the given `node`.
     *
     * @param {Node} node
     * @return {Number}
     * @api public
     */
    
    Block.prototype.push = function(node){
      return this.nodes.push(node);
    };
    
    /**
     * Check if this block is empty.
     *
     * @return {Boolean}
     * @api public
     */
    
    Block.prototype.isEmpty = function(){
      return 0 == this.nodes.length;
    };
    
    /**
     * Unshift the given `node`.
     *
     * @param {Node} node
     * @return {Number}
     * @api public
     */
    
    Block.prototype.unshift = function(node){
      return this.nodes.unshift(node);
    };
    
    /**
     * Return the "last" block, or the first `yield` node.
     *
     * @return {Block}
     * @api private
     */
    
    Block.prototype.includeBlock = function(){
      var ret = this
        , node;
    
      for (var i = 0, len = this.nodes.length; i < len; ++i) {
        node = this.nodes[i];
        if (node.yield) return node;
        else if (node.textOnly) continue;
        else if (node.includeBlock) ret = node.includeBlock();
        else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();
        if (ret.yield) return ret;
      }
    
      return ret;
    };
    
    /**
     * Return a clone of this block.
     *
     * @return {Block}
     * @api private
     */
    
    Block.prototype.clone = function(){
      var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      var clone = new Block;
      for (var i = 0, len = this.nodes.length; i < len; ++i) {
        clone.push(this.nodes[i].clone());
      }
      return clone;
    };
    
  provide("jade/lib/nodes/block", module.exports);
}(global));

// pakmanager:jade/lib/inline-tags
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = [
        'a'
      , 'abbr'
      , 'acronym'
      , 'b'
      , 'br'
      , 'code'
      , 'em'
      , 'font'
      , 'i'
      , 'img'
      , 'ins'
      , 'kbd'
      , 'map'
      , 'samp'
      , 'small'
      , 'span'
      , 'strong'
      , 'sub'
      , 'sup'
    ];
  provide("jade/lib/inline-tags", module.exports);
}(global));

// pakmanager:jade/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Merge `b` into `a`.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @api public
     */
    
    exports.merge = function(a, b) {
      for (var key in b) a[key] = b[key];
      return a;
    };
    
    exports.stringify = function(str) {
      return JSON.stringify(str)
                 .replace(/\u2028/g, '\\u2028')
                 .replace(/\u2029/g, '\\u2029');
    };
    
    exports.walkAST = function walkAST(ast, before, after) {
      before && before(ast);
      switch (ast.type) {
        case 'Block':
          ast.nodes.forEach(function (node) {
            walkAST(node, before, after);
          });
          break;
        case 'Case':
        case 'Each':
        case 'Mixin':
        case 'Tag':
        case 'When':
        case 'Code':
          ast.block && walkAST(ast.block, before, after);
          break;
        case 'Attrs':
        case 'BlockComment':
        case 'Comment':
        case 'Doctype':
        case 'Filter':
        case 'Literal':
        case 'MixinBlock':
        case 'Text':
          break;
        default:
          throw new Error('Unexpected node type ' + ast.type);
          break;
      }
      after && after(ast);
    };
    
  provide("jade/lib/utils", module.exports);
}(global));

// pakmanager:jade/lib/nodes/tag
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Attrs =  require('jade/lib/nodes/attrs');
    var Block =  require('jade/lib/nodes/block');
    var inlineTags =  require('jade/lib/inline-tags');
    
    /**
     * Initialize a `Tag` node with the given tag `name` and optional `block`.
     *
     * @param {String} name
     * @param {Block} block
     * @api public
     */
    
    var Tag = module.exports = function Tag(name, block) {
      Attrs.call(this);
      this.name = name;
      this.block = block || new Block;
    };
    
    // Inherit from `Attrs`.
    Tag.prototype = Object.create(Attrs.prototype);
    Tag.prototype.constructor = Tag;
    
    Tag.prototype.type = 'Tag';
    
    /**
     * Clone this tag.
     *
     * @return {Tag}
     * @api private
     */
    
    Tag.prototype.clone = function(){
      var err = new Error('tag.clone is deprecated and will be removed in v2.0.0');
      console.warn(err.stack);
    
      var clone = new Tag(this.name, this.block.clone());
      clone.line = this.line;
      clone.attrs = this.attrs;
      clone.textOnly = this.textOnly;
      return clone;
    };
    
    /**
     * Check if this tag is an inline tag.
     *
     * @return {Boolean}
     * @api private
     */
    
    Tag.prototype.isInline = function(){
      return ~inlineTags.indexOf(this.name);
    };
    
    /**
     * Check if this tag's contents can be inlined.  Used for pretty printing.
     *
     * @return {Boolean}
     * @api private
     */
    
    Tag.prototype.canInline = function(){
      var nodes = this.block.nodes;
    
      function isInline(node){
        // Recurse if the node is a block
        if (node.isBlock) return node.nodes.every(isInline);
        return node.isText || (node.isInline && node.isInline());
      }
    
      // Empty tag
      if (!nodes.length) return true;
    
      // Text-only or inline-only tag
      if (1 == nodes.length) return isInline(nodes[0]);
    
      // Multi-line inline-only tag
      if (this.block.nodes.every(isInline)) {
        for (var i = 1, len = nodes.length; i < len; ++i) {
          if (nodes[i-1].isText && nodes[i].isText)
            return false;
        }
        return true;
      }
    
      // Mixed tag
      return false;
    };
    
  provide("jade/lib/nodes/tag", module.exports);
}(global));

// pakmanager:jade/lib/nodes/code
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Code` node with the given code `val`.
     * Code may also be optionally buffered and escaped.
     *
     * @param {String} val
     * @param {Boolean} buffer
     * @param {Boolean} escape
     * @api public
     */
    
    var Code = module.exports = function Code(val, buffer, escape) {
      this.val = val;
      this.buffer = buffer;
      this.escape = escape;
      if (val.match(/^ *else/)) this.debug = false;
    };
    
    // Inherit from `Node`.
    Code.prototype = Object.create(Node.prototype);
    Code.prototype.constructor = Code;
    
    Code.prototype.type = 'Code'; // prevent the minifiers removing this
  provide("jade/lib/nodes/code", module.exports);
}(global));

// pakmanager:jade/lib/nodes/each
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize an `Each` node, representing iteration
     *
     * @param {String} obj
     * @param {String} val
     * @param {String} key
     * @param {Block} block
     * @api public
     */
    
    var Each = module.exports = function Each(obj, val, key, block) {
      this.obj = obj;
      this.val = val;
      this.key = key;
      this.block = block;
    };
    
    // Inherit from `Node`.
    Each.prototype = Object.create(Node.prototype);
    Each.prototype.constructor = Each;
    
    Each.prototype.type = 'Each';
    
  provide("jade/lib/nodes/each", module.exports);
}(global));

// pakmanager:jade/lib/nodes/case
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a new `Case` with `expr`.
     *
     * @param {String} expr
     * @api public
     */
    
    var Case = exports = module.exports = function Case(expr, block){
      this.expr = expr;
      this.block = block;
    };
    
    // Inherit from `Node`.
    Case.prototype = Object.create(Node.prototype);
    Case.prototype.constructor = Case;
    
    Case.prototype.type = 'Case';
    
    var When = exports.When = function When(expr, block){
      this.expr = expr;
      this.block = block;
      this.debug = false;
    };
    
    // Inherit from `Node`.
    When.prototype = Object.create(Node.prototype);
    When.prototype.constructor = When;
    
    When.prototype.type = 'When';
    
  provide("jade/lib/nodes/case", module.exports);
}(global));

// pakmanager:jade/lib/nodes/text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Text` node with optional `line`.
     *
     * @param {String} line
     * @api public
     */
    
    var Text = module.exports = function Text(line) {
      this.val = line;
    };
    
    // Inherit from `Node`.
    Text.prototype = Object.create(Node.prototype);
    Text.prototype.constructor = Text;
    
    Text.prototype.type = 'Text';
    
    /**
     * Flag as text.
     */
    
    Text.prototype.isText = true;
  provide("jade/lib/nodes/text", module.exports);
}(global));

// pakmanager:jade/lib/nodes/mixin-block
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a new `Block` with an optional `node`.
     *
     * @param {Node} node
     * @api public
     */
    
    var MixinBlock = module.exports = function MixinBlock(){};
    
    // Inherit from `Node`.
    MixinBlock.prototype = Object.create(Node.prototype);
    MixinBlock.prototype.constructor = MixinBlock;
    
    MixinBlock.prototype.type = 'MixinBlock';
    
  provide("jade/lib/nodes/mixin-block", module.exports);
}(global));

// pakmanager:jade/lib/nodes/mixin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Attrs =  require('jade/lib/nodes/attrs');
    
    /**
     * Initialize a new `Mixin` with `name` and `block`.
     *
     * @param {String} name
     * @param {String} args
     * @param {Block} block
     * @api public
     */
    
    var Mixin = module.exports = function Mixin(name, args, block, call){
      Attrs.call(this);
      this.name = name;
      this.args = args;
      this.block = block;
      this.call = call;
    };
    
    // Inherit from `Attrs`.
    Mixin.prototype = Object.create(Attrs.prototype);
    Mixin.prototype.constructor = Mixin;
    
    Mixin.prototype.type = 'Mixin';
    
  provide("jade/lib/nodes/mixin", module.exports);
}(global));

// pakmanager:jade/lib/nodes/filter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Filter` node with the given
     * filter `name` and `block`.
     *
     * @param {String} name
     * @param {Block|Node} block
     * @api public
     */
    
    var Filter = module.exports = function Filter(name, block, attrs) {
      this.name = name;
      this.block = block;
      this.attrs = attrs;
    };
    
    // Inherit from `Node`.
    Filter.prototype = Object.create(Node.prototype);
    Filter.prototype.constructor = Filter;
    
    Filter.prototype.type = 'Filter';
    
  provide("jade/lib/nodes/filter", module.exports);
}(global));

// pakmanager:jade/lib/nodes/comment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Comment` with the given `val`, optionally `buffer`,
     * otherwise the comment may render in the output.
     *
     * @param {String} val
     * @param {Boolean} buffer
     * @api public
     */
    
    var Comment = module.exports = function Comment(val, buffer) {
      this.val = val;
      this.buffer = buffer;
    };
    
    // Inherit from `Node`.
    Comment.prototype = Object.create(Node.prototype);
    Comment.prototype.constructor = Comment;
    
    Comment.prototype.type = 'Comment';
    
  provide("jade/lib/nodes/comment", module.exports);
}(global));

// pakmanager:jade/lib/nodes/literal
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Literal` node with the given `str.
     *
     * @param {String} str
     * @api public
     */
    
    var Literal = module.exports = function Literal(str) {
      this.str = str;
    };
    
    // Inherit from `Node`.
    Literal.prototype = Object.create(Node.prototype);
    Literal.prototype.constructor = Literal;
    
    Literal.prototype.type = 'Literal';
    
  provide("jade/lib/nodes/literal", module.exports);
}(global));

// pakmanager:jade/lib/nodes/block-comment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `BlockComment` with the given `block`.
     *
     * @param {String} val
     * @param {Block} block
     * @param {Boolean} buffer
     * @api public
     */
    
    var BlockComment = module.exports = function BlockComment(val, block, buffer) {
      this.block = block;
      this.val = val;
      this.buffer = buffer;
    };
    
    // Inherit from `Node`.
    BlockComment.prototype = Object.create(Node.prototype);
    BlockComment.prototype.constructor = BlockComment;
    
    BlockComment.prototype.type = 'BlockComment';
    
  provide("jade/lib/nodes/block-comment", module.exports);
}(global));

// pakmanager:jade/lib/nodes/doctype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Node =  require('jade/lib/nodes/node');
    
    /**
     * Initialize a `Doctype` with the given `val`. 
     *
     * @param {String} val
     * @api public
     */
    
    var Doctype = module.exports = function Doctype(val) {
      this.val = val;
    };
    
    // Inherit from `Node`.
    Doctype.prototype = Object.create(Node.prototype);
    Doctype.prototype.constructor = Doctype;
    
    Doctype.prototype.type = 'Doctype';
    
  provide("jade/lib/nodes/doctype", module.exports);
}(global));

// pakmanager:jade/lib/lexer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var utils =  require('jade/lib/utils');
    var characterParser = require('character-parser');
    
    
    /**
     * Initialize `Lexer` with the given `str`.
     *
     * @param {String} str
     * @param {String} filename
     * @api private
     */
    
    var Lexer = module.exports = function Lexer(str, filename) {
      this.input = str.replace(/\r\n|\r/g, '\n');
      this.filename = filename;
      this.deferredTokens = [];
      this.lastIndents = 0;
      this.lineno = 1;
      this.stash = [];
      this.indentStack = [];
      this.indentRe = null;
      this.pipeless = false;
    };
    
    
    function assertExpression(exp) {
      //this verifies that a JavaScript expression is valid
      Function('', 'return (' + exp + ')');
    }
    function assertNestingCorrect(exp) {
      //this verifies that code is properly nested, but allows
      //invalid JavaScript such as the contents of `attributes`
      var res = characterParser(exp)
      if (res.isNesting()) {
        throw new Error('Nesting must match on expression `' + exp + '`')
      }
    }
    
    /**
     * Lexer prototype.
     */
    
    Lexer.prototype = {
    
      /**
       * Construct a token with the given `type` and `val`.
       *
       * @param {String} type
       * @param {String} val
       * @return {Object}
       * @api private
       */
    
      tok: function(type, val){
        return {
            type: type
          , line: this.lineno
          , val: val
        }
      },
    
      /**
       * Consume the given `len` of input.
       *
       * @param {Number} len
       * @api private
       */
    
      consume: function(len){
        this.input = this.input.substr(len);
      },
    
      /**
       * Scan for `type` with the given `regexp`.
       *
       * @param {String} type
       * @param {RegExp} regexp
       * @return {Object}
       * @api private
       */
    
      scan: function(regexp, type){
        var captures;
        if (captures = regexp.exec(this.input)) {
          this.consume(captures[0].length);
          return this.tok(type, captures[1]);
        }
      },
    
      /**
       * Defer the given `tok`.
       *
       * @param {Object} tok
       * @api private
       */
    
      defer: function(tok){
        this.deferredTokens.push(tok);
      },
    
      /**
       * Lookahead `n` tokens.
       *
       * @param {Number} n
       * @return {Object}
       * @api private
       */
    
      lookahead: function(n){
        var fetch = n - this.stash.length;
        while (fetch-- > 0) this.stash.push(this.next());
        return this.stash[--n];
      },
    
      /**
       * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
       *
       * @return {Number}
       * @api private
       */
    
      bracketExpression: function(skip){
        skip = skip || 0;
        var start = this.input[skip];
        if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');
        var end = ({'(': ')', '{': '}', '[': ']'})[start];
        var range = characterParser.parseMax(this.input, {start: skip + 1});
        if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);
        return range;
      },
    
      /**
       * Stashed token.
       */
    
      stashed: function() {
        return this.stash.length
          && this.stash.shift();
      },
    
      /**
       * Deferred token.
       */
    
      deferred: function() {
        return this.deferredTokens.length
          && this.deferredTokens.shift();
      },
    
      /**
       * end-of-source.
       */
    
      eos: function() {
        if (this.input.length) return;
        if (this.indentStack.length) {
          this.indentStack.shift();
          return this.tok('outdent');
        } else {
          return this.tok('eos');
        }
      },
    
      /**
       * Blank line.
       */
    
      blank: function() {
        var captures;
        if (captures = /^\n *\n/.exec(this.input)) {
          this.consume(captures[0].length - 1);
          ++this.lineno;
          if (this.pipeless) return this.tok('text', '');
          return this.next();
        }
      },
    
      /**
       * Comment.
       */
    
      comment: function() {
        var captures;
        if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
          this.consume(captures[0].length);
          var tok = this.tok('comment', captures[2]);
          tok.buffer = '-' != captures[1];
          this.pipeless = true;
          return tok;
        }
      },
    
      /**
       * Interpolated tag.
       */
    
      interpolation: function() {
        if (/^#\{/.test(this.input)) {
          var match;
          try {
            match = this.bracketExpression(1);
          } catch (ex) {
            return;//not an interpolation expression, just an unmatched open interpolation
          }
    
          this.consume(match.end + 1);
          return this.tok('interpolation', match.src);
        }
      },
    
      /**
       * Tag.
       */
    
      tag: function() {
        var captures;
        if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
          this.consume(captures[0].length);
          var tok, name = captures[1];
          if (':' == name[name.length - 1]) {
            name = name.slice(0, -1);
            tok = this.tok('tag', name);
            this.defer(this.tok(':'));
            while (' ' == this.input[0]) this.input = this.input.substr(1);
          } else {
            tok = this.tok('tag', name);
          }
          tok.selfClosing = !!captures[2];
          return tok;
        }
      },
    
      /**
       * Filter.
       */
    
      filter: function() {
        var tok = this.scan(/^:([\w\-]+)/, 'filter');
        if (tok) {
          this.pipeless = true;
          return tok;
        }
      },
    
      /**
       * Doctype.
       */
    
      doctype: function() {
        if (this.scan(/^!!! *([^\n]+)?/, 'doctype')) {
          throw new Error('`!!!` is deprecated, you must now use `doctype`');
        }
        var node = this.scan(/^(?:doctype) *([^\n]+)?/, 'doctype');
        if (node && node.val && node.val.trim() === '5') {
          throw new Error('`doctype 5` is deprecated, you must now use `doctype html`');
        }
        return node;
      },
    
      /**
       * Id.
       */
    
      id: function() {
        return this.scan(/^#([\w-]+)/, 'id');
      },
    
      /**
       * Class.
       */
    
      className: function() {
        return this.scan(/^\.([\w-]+)/, 'class');
      },
    
      /**
       * Text.
       */
    
      text: function() {
        return this.scan(/^(?:\| ?| )([^\n]+)/, 'text') ||
          this.scan(/^\|?( )/, 'text') ||
          this.scan(/^(<[^\n]*)/, 'text');
      },
    
      textFail: function () {
        var tok;
        if (tok = this.scan(/^([^\.\n][^\n]+)/, 'text')) {
          console.warn('Warning: missing space before text for line ' + this.lineno +
              ' of jade file "' + this.filename + '"');
          return tok;
        }
      },
    
      /**
       * Dot.
       */
    
      dot: function() {
        var match;
        if (match = this.scan(/^\./, 'dot')) {
          this.pipeless = true;
          return match;
        }
      },
    
      /**
       * Extends.
       */
    
      "extends": function() {
        return this.scan(/^extends? +([^\n]+)/, 'extends');
      },
    
      /**
       * Block prepend.
       */
    
      prepend: function() {
        var captures;
        if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var mode = 'prepend'
            , name = captures[1]
            , tok = this.tok('block', name);
          tok.mode = mode;
          return tok;
        }
      },
    
      /**
       * Block append.
       */
    
      append: function() {
        var captures;
        if (captures = /^append +([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var mode = 'append'
            , name = captures[1]
            , tok = this.tok('block', name);
          tok.mode = mode;
          return tok;
        }
      },
    
      /**
       * Block.
       */
    
      block: function() {
        var captures;
        if (captures = /^block\b *(?:(prepend|append) +)?([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var mode = captures[1] || 'replace'
            , name = captures[2]
            , tok = this.tok('block', name);
    
          tok.mode = mode;
          return tok;
        }
      },
    
      /**
       * Mixin Block.
       */
    
      mixinBlock: function() {
        var captures;
        if (captures = /^block[ \t]*(\n|$)/.exec(this.input)) {
          this.consume(captures[0].length - captures[1].length);
          return this.tok('mixin-block');
        }
      },
    
      /**
       * Yield.
       */
    
      'yield': function() {
        return this.scan(/^yield */, 'yield');
      },
    
      /**
       * Include.
       */
    
      include: function() {
        return this.scan(/^include +([^\n]+)/, 'include');
      },
    
      /**
       * Include with filter
       */
    
      includeFiltered: function() {
        var captures;
        if (captures = /^include:([\w\-]+)([\( ])/.exec(this.input)) {
          this.consume(captures[0].length - 1);
          var filter = captures[1];
          var attrs = captures[2] === '(' ? this.attrs() : null;
          if (!(captures[2] === ' ' || this.input[0] === ' ')) {
            throw new Error('expected space after include:filter but got ' + utils.stringify(this.input[0]));
          }
          captures = /^ *([^\n]+)/.exec(this.input);
          if (!captures || captures[1].trim() === '') {
            throw new Error('missing path for include:filter');
          }
          this.consume(captures[0].length);
          var path = captures[1];
          var tok = this.tok('include', path);
          tok.filter = filter;
          tok.attrs = attrs;
          return tok;
        }
      },
    
      /**
       * Case.
       */
    
      "case": function() {
        return this.scan(/^case +([^\n]+)/, 'case');
      },
    
      /**
       * When.
       */
    
      when: function() {
        return this.scan(/^when +([^:\n]+)/, 'when');
      },
    
      /**
       * Default.
       */
    
      "default": function() {
        return this.scan(/^default */, 'default');
      },
    
      /**
       * Call mixin.
       */
    
      call: function(){
    
        var tok, captures;
        if (captures = /^\+(\s*)(([-\w]+)|(#\{))/.exec(this.input)) {
          // try to consume simple or interpolated call
          if (captures[3]) {
            // simple call
            this.consume(captures[0].length);
            tok = this.tok('call', captures[3]);
          } else {
            // interpolated call
            var match;
            try {
              match = this.bracketExpression(2 + captures[1].length);
            } catch (ex) {
              return;//not an interpolation expression, just an unmatched open interpolation
            }
            this.consume(match.end + 1);
            assertExpression(match.src);
            tok = this.tok('call', '#{'+match.src+'}');
          }
    
          // Check for args (not attributes)
          if (captures = /^ *\(/.exec(this.input)) {
            try {
              var range = this.bracketExpression(captures[0].length - 1);
              if (!/^\s*[-\w]+ *=/.test(range.src)) { // not attributes
                this.consume(range.end + 1);
                tok.args = range.src;
              }
            } catch (ex) {
              //not a bracket expcetion, just unmatched open parens
            }
          }
    
          return tok;
        }
      },
    
      /**
       * Mixin.
       */
    
      mixin: function(){
        var captures;
        if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
          this.consume(captures[0].length);
          var tok = this.tok('mixin', captures[1]);
          tok.args = captures[2];
          return tok;
        }
      },
    
      /**
       * Conditional.
       */
    
      conditional: function() {
        var captures;
        if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
          this.consume(captures[0].length);
          var type = captures[1]
          var js = captures[2];
          var isIf = false;
          var isElse = false;
    
          switch (type) {
            case 'if':
              assertExpression(js)
              js = 'if (' + js + ')';
              isIf = true;
              break;
            case 'unless':
              assertExpression(js)
              js = 'if (!(' + js + '))';
              isIf = true;
              break;
            case 'else if':
              assertExpression(js)
              js = 'else if (' + js + ')';
              isIf = true;
              isElse = true;
              break;
            case 'else':
              if (js && js.trim()) {
                throw new Error('`else` cannot have a condition, perhaps you meant `else if`');
              }
              js = 'else';
              isElse = true;
              break;
          }
          var tok = this.tok('code', js);
          tok.isElse = isElse;
          tok.isIf = isIf;
          tok.requiresBlock = true;
          return tok;
        }
      },
    
      /**
       * While.
       */
    
      "while": function() {
        var captures;
        if (captures = /^while +([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          assertExpression(captures[1])
          var tok = this.tok('code', 'while (' + captures[1] + ')');
          tok.requiresBlock = true;
          return tok;
        }
      },
    
      /**
       * Each.
       */
    
      each: function() {
        var captures;
        if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var tok = this.tok('each', captures[1]);
          tok.key = captures[2] || '$index';
          assertExpression(captures[3])
          tok.code = captures[3];
          return tok;
        }
      },
    
      /**
       * Code.
       */
    
      code: function() {
        var captures;
        if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
          this.consume(captures[0].length);
          var flags = captures[1];
          captures[1] = captures[2];
          var tok = this.tok('code', captures[1]);
          tok.escape = flags.charAt(0) === '=';
          tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
          if (tok.buffer) assertExpression(captures[1])
          return tok;
        }
      },
    
      /**
       * Attributes.
       */
    
      attrs: function() {
        if ('(' == this.input.charAt(0)) {
          var index = this.bracketExpression().end
            , str = this.input.substr(1, index-1)
            , tok = this.tok('attrs');
    
          assertNestingCorrect(str);
    
          var quote = '';
          var interpolate = function (attr) {
            return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
              if (escape) return _;
              try {
                var range = characterParser.parseMax(expr);
                if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));
                assertExpression(range.src)
                return quote + " + (" + range.src + ") + " + quote + interpolate(expr.substr(range.end + 1));
              } catch (ex) {
                return _.substr(0, 2) + interpolate(_.substr(2));
              }
            });
          }
    
          this.consume(index + 1);
          tok.attrs = [];
    
          var escapedAttr = true
          var key = '';
          var val = '';
          var interpolatable = '';
          var state = characterParser.defaultState();
          var loc = 'key';
          var isEndOfAttribute = function (i) {
            if (key.trim() === '') return false;
            if (i === str.length) return true;
            if (loc === 'key') {
              if (str[i] === ' ' || str[i] === '\n') {
                for (var x = i; x < str.length; x++) {
                  if (str[x] != ' ' && str[x] != '\n') {
                    if (str[x] === '=' || str[x] === '!' || str[x] === ',') return false;
                    else return true;
                  }
                }
              }
              return str[i] === ','
            } else if (loc === 'value' && !state.isNesting()) {
              try {
                Function('', 'return (' + val + ');');
                if (str[i] === ' ' || str[i] === '\n') {
                  for (var x = i; x < str.length; x++) {
                    if (str[x] != ' ' && str[x] != '\n') {
                      if (characterParser.isPunctuator(str[x]) && str[x] != '"' && str[x] != "'") return false;
                      else return true;
                    }
                  }
                }
                return str[i] === ',';
              } catch (ex) {
                return false;
              }
            }
          }
    
          this.lineno += str.split("\n").length - 1;
    
          for (var i = 0; i <= str.length; i++) {
            if (isEndOfAttribute(i)) {
              val = val.trim();
              if (val) assertExpression(val)
              key = key.trim();
              key = key.replace(/^['"]|['"]$/g, '');
              tok.attrs.push({
                name: key,
                val: '' == val ? true : val,
                escaped: escapedAttr
              });
              key = val = '';
              loc = 'key';
              escapedAttr = false;
            } else {
              switch (loc) {
                case 'key-char':
                  if (str[i] === quote) {
                    loc = 'key';
                    if (i + 1 < str.length && [' ', ',', '!', '=', '\n'].indexOf(str[i + 1]) === -1)
                      throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\n`, `,`, `!` or `=`');
                  } else {
                    key += str[i];
                  }
                  break;
                case 'key':
                  if (key === '' && (str[i] === '"' || str[i] === "'")) {
                    loc = 'key-char';
                    quote = str[i];
                  } else if (str[i] === '!' || str[i] === '=') {
                    escapedAttr = str[i] !== '!';
                    if (str[i] === '!') i++;
                    if (str[i] !== '=') throw new Error('Unexpected character ' + str[i] + ' expected `=`');
                    loc = 'value';
                    state = characterParser.defaultState();
                  } else {
                    key += str[i]
                  }
                  break;
                case 'value':
                  state = characterParser.parseChar(str[i], state);
                  if (state.isString()) {
                    loc = 'string';
                    quote = str[i];
                    interpolatable = str[i];
                  } else {
                    val += str[i];
                  }
                  break;
                case 'string':
                  state = characterParser.parseChar(str[i], state);
                  interpolatable += str[i];
                  if (!state.isString()) {
                    loc = 'value';
                    val += interpolate(interpolatable);
                  }
                  break;
              }
            }
          }
    
          if ('/' == this.input.charAt(0)) {
            this.consume(1);
            tok.selfClosing = true;
          }
    
          return tok;
        }
      },
    
      /**
       * &attributes block
       */
      attributesBlock: function () {
        var captures;
        if (/^&attributes\b/.test(this.input)) {
          this.consume(11);
          var args = this.bracketExpression();
          this.consume(args.end + 1);
          return this.tok('&attributes', args.src);
        }
      },
    
      /**
       * Indent | Outdent | Newline.
       */
    
      indent: function() {
        var captures, re;
    
        // established regexp
        if (this.indentRe) {
          captures = this.indentRe.exec(this.input);
        // determine regexp
        } else {
          // tabs
          re = /^\n(\t*) */;
          captures = re.exec(this.input);
    
          // spaces
          if (captures && !captures[1].length) {
            re = /^\n( *)/;
            captures = re.exec(this.input);
          }
    
          // established
          if (captures && captures[1].length) this.indentRe = re;
        }
    
        if (captures) {
          var tok
            , indents = captures[1].length;
    
          ++this.lineno;
          this.consume(indents + 1);
    
          if (' ' == this.input[0] || '\t' == this.input[0]) {
            throw new Error('Invalid indentation, you can use tabs or spaces but not both');
          }
    
          // blank line
          if ('\n' == this.input[0]) {
            this.pipeless = false;
            return this.tok('newline');
          }
    
          // outdent
          if (this.indentStack.length && indents < this.indentStack[0]) {
            while (this.indentStack.length && this.indentStack[0] > indents) {
              this.stash.push(this.tok('outdent'));
              this.indentStack.shift();
            }
            tok = this.stash.pop();
          // indent
          } else if (indents && indents != this.indentStack[0]) {
            this.indentStack.unshift(indents);
            tok = this.tok('indent', indents);
          // newline
          } else {
            tok = this.tok('newline');
          }
    
          this.pipeless = false;
          return tok;
        }
      },
    
      /**
       * Pipe-less text consumed only when
       * pipeless is true;
       */
    
      pipelessText: function() {
        if (!this.pipeless) return;
        var captures, re;
    
        // established regexp
        if (this.indentRe) {
          captures = this.indentRe.exec(this.input);
        // determine regexp
        } else {
          // tabs
          re = /^\n(\t*) */;
          captures = re.exec(this.input);
    
          // spaces
          if (captures && !captures[1].length) {
            re = /^\n( *)/;
            captures = re.exec(this.input);
          }
    
          // established
          if (captures && captures[1].length) this.indentRe = re;
        }
    
        var indents = captures && captures[1].length;
        if (indents && (this.indentStack.length === 0 || indents > this.indentStack[0])) {
          var indent = captures[1];
          var line;
          var tokens = [];
          var isMatch;
          do {
            // text has `\n` as a prefix
            var i = this.input.substr(1).indexOf('\n');
            if (-1 == i) i = this.input.length - 1;
            var str = this.input.substr(1, i);
            isMatch = str.substr(0, indent.length) === indent || !str.trim();
            if (isMatch) {
              // consume test along with `\n` prefix if match
              this.consume(str.length + 1);
              tokens.push(str.substr(indent.length));
            }
          } while(this.input.length && isMatch);
          while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();
          return this.tok('pipeless-text', tokens);
        }
      },
    
      /**
       * ':'
       */
    
      colon: function() {
        return this.scan(/^: */, ':');
      },
    
      fail: function () {
        throw new Error('unexpected text ' + this.input.substr(0, 5));
      },
    
      /**
       * Return the next token object, or those
       * previously stashed by lookahead.
       *
       * @return {Object}
       * @api private
       */
    
      advance: function(){
        return this.stashed()
          || this.next();
      },
    
      /**
       * Return the next token object.
       *
       * @return {Object}
       * @api private
       */
    
      next: function() {
        return this.deferred()
          || this.blank()
          || this.eos()
          || this.pipelessText()
          || this.yield()
          || this.doctype()
          || this.interpolation()
          || this["case"]()
          || this.when()
          || this["default"]()
          || this["extends"]()
          || this.append()
          || this.prepend()
          || this.block()
          || this.mixinBlock()
          || this.include()
          || this.includeFiltered()
          || this.mixin()
          || this.call()
          || this.conditional()
          || this.each()
          || this["while"]()
          || this.tag()
          || this.filter()
          || this.code()
          || this.id()
          || this.className()
          || this.attrs()
          || this.attributesBlock()
          || this.indent()
          || this.text()
          || this.comment()
          || this.colon()
          || this.dot()
          || this.textFail()
          || this.fail();
      }
    };
    
  provide("jade/lib/lexer", module.exports);
}(global));

// pakmanager:jade/lib/nodes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.Node =  require('jade/lib/nodes/node');
    exports.Tag =  require('jade/lib/nodes/tag');
    exports.Code =  require('jade/lib/nodes/code');
    exports.Each =  require('jade/lib/nodes/each');
    exports.Case =  require('jade/lib/nodes/case');
    exports.Text =  require('jade/lib/nodes/text');
    exports.Block =  require('jade/lib/nodes/block');
    exports.MixinBlock =  require('jade/lib/nodes/mixin-block');
    exports.Mixin =  require('jade/lib/nodes/mixin');
    exports.Filter =  require('jade/lib/nodes/filter');
    exports.Comment =  require('jade/lib/nodes/comment');
    exports.Literal =  require('jade/lib/nodes/literal');
    exports.BlockComment =  require('jade/lib/nodes/block-comment');
    exports.Doctype =  require('jade/lib/nodes/doctype');
    
  provide("jade/lib/nodes", module.exports);
}(global));

// pakmanager:jade/lib/filters
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var transformers = require('transformers');
    
    module.exports = filter;
    function filter(name, str, options) {
      if (typeof filter[name] === 'function') {
        return filter[name](str, options);
      } else if (transformers[name]) {
        return transformers[name].renderSync(str, options);
      } else {
        throw new Error('unknown filter ":' + name + '"');
      }
    }
    
  provide("jade/lib/filters", module.exports);
}(global));

// pakmanager:jade/lib/doctypes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = {
        'default': '<!DOCTYPE html>'
      , 'xml': '<?xml version="1.0" encoding="utf-8" ?>'
      , 'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
      , 'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
      , 'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
      , '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">'
      , 'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
      , 'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
    };
  provide("jade/lib/doctypes", module.exports);
}(global));

// pakmanager:jade/lib/runtime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Merge two attribute objects giving precedence
     * to values in object `b`. Classes are special-cased
     * allowing for arrays and merging/joining appropriately
     * resulting in a string.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object} a
     * @api private
     */
    
    exports.merge = function merge(a, b) {
      if (arguments.length === 1) {
        var attrs = a[0];
        for (var i = 1; i < a.length; i++) {
          attrs = merge(attrs, a[i]);
        }
        return attrs;
      }
      var ac = a['class'];
      var bc = b['class'];
    
      if (ac || bc) {
        ac = ac || [];
        bc = bc || [];
        if (!Array.isArray(ac)) ac = [ac];
        if (!Array.isArray(bc)) bc = [bc];
        a['class'] = ac.concat(bc).filter(nulls);
      }
    
      for (var key in b) {
        if (key != 'class') {
          a[key] = b[key];
        }
      }
    
      return a;
    };
    
    /**
     * Filter null `val`s.
     *
     * @param {*} val
     * @return {Boolean}
     * @api private
     */
    
    function nulls(val) {
      return val != null && val !== '';
    }
    
    /**
     * join array as classes.
     *
     * @param {*} val
     * @return {String}
     */
    exports.joinClasses = joinClasses;
    function joinClasses(val) {
      return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;
    }
    
    /**
     * Render the given classes.
     *
     * @param {Array} classes
     * @param {Array.<Boolean>} escaped
     * @return {String}
     */
    exports.cls = function cls(classes, escaped) {
      var buf = [];
      for (var i = 0; i < classes.length; i++) {
        if (escaped && escaped[i]) {
          buf.push(exports.escape(joinClasses([classes[i]])));
        } else {
          buf.push(joinClasses(classes[i]));
        }
      }
      var text = joinClasses(buf);
      if (text.length) {
        return ' class="' + text + '"';
      } else {
        return '';
      }
    };
    
    /**
     * Render the given attribute.
     *
     * @param {String} key
     * @param {String} val
     * @param {Boolean} escaped
     * @param {Boolean} terse
     * @return {String}
     */
    exports.attr = function attr(key, val, escaped, terse) {
      if ('boolean' == typeof val || null == val) {
        if (val) {
          return ' ' + (terse ? key : key + '="' + key + '"');
        } else {
          return '';
        }
      } else if (0 == key.indexOf('data') && 'string' != typeof val) {
        return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
      } else if (escaped) {
        return ' ' + key + '="' + exports.escape(val) + '"';
      } else {
        return ' ' + key + '="' + val + '"';
      }
    };
    
    /**
     * Render the given attributes object.
     *
     * @param {Object} obj
     * @param {Object} escaped
     * @return {String}
     */
    exports.attrs = function attrs(obj, terse){
      var buf = [];
    
      var keys = Object.keys(obj);
    
      if (keys.length) {
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i]
            , val = obj[key];
    
          if ('class' == key) {
            if (val = joinClasses(val)) {
              buf.push(' ' + key + '="' + val + '"');
            }
          } else {
            buf.push(exports.attr(key, val, false, terse));
          }
        }
      }
    
      return buf.join('');
    };
    
    /**
     * Escape the given string of `html`.
     *
     * @param {String} html
     * @return {String}
     * @api private
     */
    
    exports.escape = function escape(html){
      var result = String(html)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
      if (result === '' + html) return html;
      else return result;
    };
    
    /**
     * Re-throw the given `err` in context to the
     * the jade in `filename` at the given `lineno`.
     *
     * @param {Error} err
     * @param {String} filename
     * @param {String} lineno
     * @api private
     */
    
    exports.rethrow = function rethrow(err, filename, lineno, str){
      if (!(err instanceof Error)) throw err;
      if ((typeof window != 'undefined' || !filename) && !str) {
        err.message += ' on line ' + lineno;
        throw err;
      }
      try {
        str = str || require('fs').readFileSync(filename, 'utf8')
      } catch (ex) {
        rethrow(err, null, lineno)
      }
      var context = 3
        , lines = str.split('\n')
        , start = Math.max(lineno - context, 0)
        , end = Math.min(lines.length, lineno + context);
    
      // Error context
      var context = lines.slice(start, end).map(function(line, i){
        var curr = i + start + 1;
        return (curr == lineno ? '  > ' : '    ')
          + curr
          + '| '
          + line;
      }).join('\n');
    
      // Alter exception message
      err.path = filename;
      err.message = (filename || 'Jade') + ':' + lineno
        + '\n' + context + '\n\n' + err.message;
      throw err;
    };
    
  provide("jade/lib/runtime", module.exports);
}(global));

// pakmanager:jade/lib/parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Lexer =  require('jade/lib/lexer');
    var nodes =  require('jade/lib/nodes');
    var utils =  require('jade/lib/utils');
    var filters =  require('jade/lib/filters');
    var path = require('path');
    var constantinople = require('constantinople');
    var parseJSExpression = require('character-parser').parseMax;
    var extname = path.extname;
    
    /**
     * Initialize `Parser` with the given input `str` and `filename`.
     *
     * @param {String} str
     * @param {String} filename
     * @param {Object} options
     * @api public
     */
    
    var Parser = exports = module.exports = function Parser(str, filename, options){
      //Strip any UTF-8 BOM off of the start of `str`, if it exists.
      this.input = str.replace(/^\uFEFF/, '');
      this.lexer = new Lexer(this.input, filename);
      this.filename = filename;
      this.blocks = {};
      this.mixins = {};
      this.options = options;
      this.contexts = [this];
      this.inMixin = false;
      this.dependencies = [];
      this.inBlock = 0;
    };
    
    /**
     * Parser prototype.
     */
    
    Parser.prototype = {
    
      /**
       * Save original constructor
       */
    
      constructor: Parser,
    
      /**
       * Push `parser` onto the context stack,
       * or pop and return a `Parser`.
       */
    
      context: function(parser){
        if (parser) {
          this.contexts.push(parser);
        } else {
          return this.contexts.pop();
        }
      },
    
      /**
       * Return the next token object.
       *
       * @return {Object}
       * @api private
       */
    
      advance: function(){
        return this.lexer.advance();
      },
    
      /**
       * Single token lookahead.
       *
       * @return {Object}
       * @api private
       */
    
      peek: function() {
        return this.lookahead(1);
      },
    
      /**
       * Return lexer lineno.
       *
       * @return {Number}
       * @api private
       */
    
      line: function() {
        return this.lexer.lineno;
      },
    
      /**
       * `n` token lookahead.
       *
       * @param {Number} n
       * @return {Object}
       * @api private
       */
    
      lookahead: function(n){
        return this.lexer.lookahead(n);
      },
    
      /**
       * Parse input returning a string of js for evaluation.
       *
       * @return {String}
       * @api public
       */
    
      parse: function(){
        var block = new nodes.Block, parser;
        block.line = 0;
        block.filename = this.filename;
    
        while ('eos' != this.peek().type) {
          if ('newline' == this.peek().type) {
            this.advance();
          } else {
            var next = this.peek();
            var expr = this.parseExpr();
            expr.filename = expr.filename || this.filename;
            expr.line = next.line;
            block.push(expr);
          }
        }
    
        if (parser = this.extending) {
          this.context(parser);
          var ast = parser.parse();
          this.context();
    
          // hoist mixins
          for (var name in this.mixins)
            ast.unshift(this.mixins[name]);
          return ast;
        }
    
        if (!this.extending && !this.included && Object.keys(this.blocks).length){
          var blocks = [];
          utils.walkAST(block, function (node) {
            if (node.type === 'Block' && node.name) {
              blocks.push(node.name);
            }
          });
          Object.keys(this.blocks).forEach(function (name) {
            if (blocks.indexOf(name) === -1 && !this.blocks[name].isSubBlock) {
              console.warn('Warning: Unexpected block "'
                           + name
                           + '" '
                           + ' on line '
                           + this.blocks[name].line
                           + ' of '
                           + (this.blocks[name].filename)
                           + '. This block is never used. This warning will be an error in v2.0.0');
            }
          }.bind(this));
        }
    
        return block;
      },
    
      /**
       * Expect the given type, or throw an exception.
       *
       * @param {String} type
       * @api private
       */
    
      expect: function(type){
        if (this.peek().type === type) {
          return this.advance();
        } else {
          throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
        }
      },
    
      /**
       * Accept the given `type`.
       *
       * @param {String} type
       * @api private
       */
    
      accept: function(type){
        if (this.peek().type === type) {
          return this.advance();
        }
      },
    
      /**
       *   tag
       * | doctype
       * | mixin
       * | include
       * | filter
       * | comment
       * | text
       * | each
       * | code
       * | yield
       * | id
       * | class
       * | interpolation
       */
    
      parseExpr: function(){
        switch (this.peek().type) {
          case 'tag':
            return this.parseTag();
          case 'mixin':
            return this.parseMixin();
          case 'block':
            return this.parseBlock();
          case 'mixin-block':
            return this.parseMixinBlock();
          case 'case':
            return this.parseCase();
          case 'extends':
            return this.parseExtends();
          case 'include':
            return this.parseInclude();
          case 'doctype':
            return this.parseDoctype();
          case 'filter':
            return this.parseFilter();
          case 'comment':
            return this.parseComment();
          case 'text':
            return this.parseText();
          case 'each':
            return this.parseEach();
          case 'code':
            return this.parseCode();
          case 'call':
            return this.parseCall();
          case 'interpolation':
            return this.parseInterpolation();
          case 'yield':
            this.advance();
            var block = new nodes.Block;
            block.yield = true;
            return block;
          case 'id':
          case 'class':
            var tok = this.advance();
            this.lexer.defer(this.lexer.tok('tag', 'div'));
            this.lexer.defer(tok);
            return this.parseExpr();
          default:
            throw new Error('unexpected token "' + this.peek().type + '"');
        }
      },
    
      /**
       * Text
       */
    
      parseText: function(){
        var tok = this.expect('text');
        var tokens = this.parseInlineTagsInText(tok.val);
        if (tokens.length === 1) return tokens[0];
        var node = new nodes.Block;
        for (var i = 0; i < tokens.length; i++) {
          node.push(tokens[i]);
        };
        return node;
      },
    
      /**
       *   ':' expr
       * | block
       */
    
      parseBlockExpansion: function(){
        if (':' == this.peek().type) {
          this.advance();
          return new nodes.Block(this.parseExpr());
        } else {
          return this.block();
        }
      },
    
      /**
       * case
       */
    
      parseCase: function(){
        var val = this.expect('case').val;
        var node = new nodes.Case(val);
        node.line = this.line();
    
        var block = new nodes.Block;
        block.line = this.line();
        block.filename = this.filename;
        this.expect('indent');
        while ('outdent' != this.peek().type) {
          switch (this.peek().type) {
            case 'newline':
              this.advance();
              break;
            case 'when':
              block.push(this.parseWhen());
              break;
            case 'default':
              block.push(this.parseDefault());
              break;
            default:
              throw new Error('Unexpected token "' + this.peek().type
                              + '", expected "when", "default" or "newline"');
          }
        }
        this.expect('outdent');
    
        node.block = block;
    
        return node;
      },
    
      /**
       * when
       */
    
      parseWhen: function(){
        var val = this.expect('when').val;
        if (this.peek().type !== 'newline')
          return new nodes.Case.When(val, this.parseBlockExpansion());
        else
          return new nodes.Case.When(val);
      },
    
      /**
       * default
       */
    
      parseDefault: function(){
        this.expect('default');
        return new nodes.Case.When('default', this.parseBlockExpansion());
      },
    
      /**
       * code
       */
    
      parseCode: function(afterIf){
        var tok = this.expect('code');
        var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
        var block;
        node.line = this.line();
    
        // throw an error if an else does not have an if
        if (tok.isElse && !tok.hasIf) {
          throw new Error('Unexpected else without if');
        }
    
        // handle block
        block = 'indent' == this.peek().type;
        if (block) {
          node.block = this.block();
        }
    
        // handle missing block
        if (tok.requiresBlock && !block) {
          node.block = new nodes.Block();
        }
    
        // mark presense of if for future elses
        if (tok.isIf && this.peek().isElse) {
          this.peek().hasIf = true;
        } else if (tok.isIf && this.peek().type === 'newline' && this.lookahead(2).isElse) {
          this.lookahead(2).hasIf = true;
        }
    
        return node;
      },
    
      /**
       * comment
       */
    
      parseComment: function(){
        var tok = this.expect('comment');
        var node;
    
        var block;
        if (block = this.parseTextBlock()) {
          node = new nodes.BlockComment(tok.val, block, tok.buffer);
        } else {
          node = new nodes.Comment(tok.val, tok.buffer);
        }
    
        node.line = this.line();
        return node;
      },
    
      /**
       * doctype
       */
    
      parseDoctype: function(){
        var tok = this.expect('doctype');
        var node = new nodes.Doctype(tok.val);
        node.line = this.line();
        return node;
      },
    
      /**
       * filter attrs? text-block
       */
    
      parseFilter: function(){
        var tok = this.expect('filter');
        var attrs = this.accept('attrs');
        var block;
    
        block = this.parseTextBlock() || new nodes.Block();
    
        var options = {};
        if (attrs) {
          attrs.attrs.forEach(function (attribute) {
            options[attribute.name] = constantinople.toConstant(attribute.val);
          });
        }
    
        var node = new nodes.Filter(tok.val, block, options);
        node.line = this.line();
        return node;
      },
    
      /**
       * each block
       */
    
      parseEach: function(){
        var tok = this.expect('each');
        var node = new nodes.Each(tok.code, tok.val, tok.key);
        node.line = this.line();
        node.block = this.block();
        if (this.peek().type == 'code' && this.peek().val == 'else') {
          this.advance();
          node.alternative = this.block();
        }
        return node;
      },
    
      /**
       * Resolves a path relative to the template for use in
       * includes and extends
       *
       * @param {String}  path
       * @param {String}  purpose  Used in error messages.
       * @return {String}
       * @api private
       */
    
      resolvePath: function (path, purpose) {
        var p = require('path');
        var dirname = p.dirname;
        var basename = p.basename;
        var join = p.join;
    
        if (path[0] !== '/' && !this.filename)
          throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');
    
        if (path[0] === '/' && !this.options.basedir)
          throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');
    
        path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);
    
        if (basename(path).indexOf('.') === -1) path += '.jade';
    
        return path;
      },
    
      /**
       * 'extends' name
       */
    
      parseExtends: function(){
        var fs = require('fs');
    
        var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
        if ('.jade' != path.substr(-5)) path += '.jade';
    
        this.dependencies.push(path);
        var str = fs.readFileSync(path, 'utf8');
        var parser = new this.constructor(str, path, this.options);
        parser.dependencies = this.dependencies;
    
        parser.blocks = this.blocks;
        parser.included = this.included;
        parser.contexts = this.contexts;
        this.extending = parser;
    
        // TODO: null node
        return new nodes.Literal('');
      },
    
      /**
       * 'block' name block
       */
    
      parseBlock: function(){
        var block = this.expect('block');
        var mode = block.mode;
        var name = block.val.trim();
    
        var line = block.line;
    
        this.inBlock++;
        block = 'indent' == this.peek().type
          ? this.block()
          : new nodes.Block(new nodes.Literal(''));
        this.inBlock--;
        block.name = name;
        block.line = line;
    
        var prev = this.blocks[name] || {prepended: [], appended: []}
        if (prev.mode === 'replace') return this.blocks[name] = prev;
    
        var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);
    
        switch (mode) {
          case 'append':
            prev.appended = prev.parser === this ?
                            prev.appended.concat(block.nodes) :
                            block.nodes.concat(prev.appended);
            break;
          case 'prepend':
            prev.prepended = prev.parser === this ?
                             block.nodes.concat(prev.prepended) :
                             prev.prepended.concat(block.nodes);
            break;
        }
        block.nodes = allNodes;
        block.appended = prev.appended;
        block.prepended = prev.prepended;
        block.mode = mode;
        block.parser = this;
    
        block.isSubBlock = this.inBlock > 0;
    
        return this.blocks[name] = block;
      },
    
      parseMixinBlock: function () {
        var block = this.expect('mixin-block');
        if (!this.inMixin) {
          throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
        }
        return new nodes.MixinBlock();
      },
    
      /**
       * include block?
       */
    
      parseInclude: function(){
        var fs = require('fs');
        var tok = this.expect('include');
    
        var path = this.resolvePath(tok.val.trim(), 'include');
        this.dependencies.push(path);
        // has-filter
        if (tok.filter) {
          var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
          var options = {filename: path};
          if (tok.attrs) {
            tok.attrs.attrs.forEach(function (attribute) {
              options[attribute.name] = constantinople.toConstant(attribute.val);
            });
          }
          str = filters(tok.filter, str, options);
          return new nodes.Literal(str);
        }
    
        // non-jade
        if ('.jade' != path.substr(-5)) {
          var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
          return new nodes.Literal(str);
        }
    
        var str = fs.readFileSync(path, 'utf8');
        var parser = new this.constructor(str, path, this.options);
        parser.dependencies = this.dependencies;
    
        parser.blocks = utils.merge({}, this.blocks);
        parser.included = true;
    
        parser.mixins = this.mixins;
    
        this.context(parser);
        var ast = parser.parse();
        this.context();
        ast.filename = path;
    
        if ('indent' == this.peek().type) {
          ast.includeBlock().push(this.block());
        }
    
        return ast;
      },
    
      /**
       * call ident block
       */
    
      parseCall: function(){
        var tok = this.expect('call');
        var name = tok.val;
        var args = tok.args;
        var mixin = new nodes.Mixin(name, args, new nodes.Block, true);
    
        this.tag(mixin);
        if (mixin.code) {
          mixin.block.push(mixin.code);
          mixin.code = null;
        }
        if (mixin.block.isEmpty()) mixin.block = null;
        return mixin;
      },
    
      /**
       * mixin block
       */
    
      parseMixin: function(){
        var tok = this.expect('mixin');
        var name = tok.val;
        var args = tok.args;
        var mixin;
    
        // definition
        if ('indent' == this.peek().type) {
          this.inMixin = true;
          mixin = new nodes.Mixin(name, args, this.block(), false);
          this.mixins[name] = mixin;
          this.inMixin = false;
          return mixin;
        // call
        } else {
          return new nodes.Mixin(name, args, null, true);
        }
      },
    
      parseInlineTagsInText: function (str) {
        var line = this.line();
    
        var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
        if (match) {
          if (match[1]) { // escape
            var text = new nodes.Text(str.substr(0, match.index) + '#[');
            text.line = line;
            var rest = this.parseInlineTagsInText(match[2]);
            if (rest[0].type === 'Text') {
              text.val += rest[0].val;
              rest.shift();
            }
            return [text].concat(rest);
          } else {
            var text = new nodes.Text(str.substr(0, match.index));
            text.line = line;
            var buffer = [text];
            var rest = match[2];
            var range = parseJSExpression(rest);
            var inner = new Parser(range.src, this.filename, this.options);
            buffer.push(inner.parse());
            return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));
          }
        } else {
          var text = new nodes.Text(str);
          text.line = line;
          return [text];
        }
      },
    
      /**
       * indent (text | newline)* outdent
       */
    
      parseTextBlock: function(){
        var block = new nodes.Block;
        block.line = this.line();
        var body = this.peek();
        if (body.type !== 'pipeless-text') return;
        this.advance();
        block.nodes = body.val.reduce(function (accumulator, text) {
          return accumulator.concat(this.parseInlineTagsInText(text));
        }.bind(this), []);
        return block;
      },
    
      /**
       * indent expr* outdent
       */
    
      block: function(){
        var block = new nodes.Block;
        block.line = this.line();
        block.filename = this.filename;
        this.expect('indent');
        while ('outdent' != this.peek().type) {
          if ('newline' == this.peek().type) {
            this.advance();
          } else {
            var expr = this.parseExpr();
            expr.filename = this.filename;
            block.push(expr);
          }
        }
        this.expect('outdent');
        return block;
      },
    
      /**
       * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
       */
    
      parseInterpolation: function(){
        var tok = this.advance();
        var tag = new nodes.Tag(tok.val);
        tag.buffer = true;
        return this.tag(tag);
      },
    
      /**
       * tag (attrs | class | id)* (text | code | ':')? newline* block?
       */
    
      parseTag: function(){
        var tok = this.advance();
        var tag = new nodes.Tag(tok.val);
    
        tag.selfClosing = tok.selfClosing;
    
        return this.tag(tag);
      },
    
      /**
       * Parse tag.
       */
    
      tag: function(tag){
        tag.line = this.line();
    
        var seenAttrs = false;
        // (attrs | class | id)*
        out:
          while (true) {
            switch (this.peek().type) {
              case 'id':
              case 'class':
                var tok = this.advance();
                tag.setAttribute(tok.type, "'" + tok.val + "'");
                continue;
              case 'attrs':
                if (seenAttrs) {
                  console.warn(this.filename + ', line ' + this.peek().line + ':\nYou should not have jade tags with multiple attributes.');
                }
                seenAttrs = true;
                var tok = this.advance();
                var attrs = tok.attrs;
    
                if (tok.selfClosing) tag.selfClosing = true;
    
                for (var i = 0; i < attrs.length; i++) {
                  tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);
                }
                continue;
              case '&attributes':
                var tok = this.advance();
                tag.addAttributes(tok.val);
                break;
              default:
                break out;
            }
          }
    
        // check immediate '.'
        if ('dot' == this.peek().type) {
          tag.textOnly = true;
          this.advance();
        }
    
        // (text | code | ':')?
        switch (this.peek().type) {
          case 'text':
            tag.block.push(this.parseText());
            break;
          case 'code':
            tag.code = this.parseCode();
            break;
          case ':':
            this.advance();
            tag.block = new nodes.Block;
            tag.block.push(this.parseExpr());
            break;
          case 'newline':
          case 'indent':
          case 'outdent':
          case 'eos':
          case 'pipeless-text':
            break;
          default:
            throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`')
        }
    
        // newline*
        while ('newline' == this.peek().type) this.advance();
    
        // block?
        if (tag.textOnly) {
          tag.block = this.parseTextBlock();
        } else if ('indent' == this.peek().type) {
          var block = this.block();
          for (var i = 0, len = block.nodes.length; i < len; ++i) {
            tag.block.push(block.nodes[i]);
          }
        }
    
        return tag;
      }
    };
    
  provide("jade/lib/parser", module.exports);
}(global));

// pakmanager:jade/lib/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var nodes =  require('jade/lib/nodes');
    var filters =  require('jade/lib/filters');
    var doctypes =  require('jade/lib/doctypes');
    var runtime =  require('jade/lib/runtime');
    var utils =  require('jade/lib/utils');
    var selfClosing = require('void-elements');
    var parseJSExpression = require('character-parser').parseMax;
    var constantinople = require('constantinople');
    
    function isConstant(src) {
      return constantinople(src, {jade: runtime, 'jade_interp': undefined});
    }
    function toConstant(src) {
      return constantinople.toConstant(src, {jade: runtime, 'jade_interp': undefined});
    }
    function errorAtNode(node, error) {
      error.line = node.line;
      error.filename = node.filename;
      return error;
    }
    
    /**
     * Initialize `Compiler` with the given `node`.
     *
     * @param {Node} node
     * @param {Object} options
     * @api public
     */
    
    var Compiler = module.exports = function Compiler(node, options) {
      this.options = options = options || {};
      this.node = node;
      this.hasCompiledDoctype = false;
      this.hasCompiledTag = false;
      this.pp = options.pretty || false;
      this.debug = false !== options.compileDebug;
      this.indents = 0;
      this.parentIndents = 0;
      this.terse = false;
      this.mixins = {};
      this.dynamicMixins = false;
      if (options.doctype) this.setDoctype(options.doctype);
    };
    
    /**
     * Compiler prototype.
     */
    
    Compiler.prototype = {
    
      /**
       * Compile parse tree to JavaScript.
       *
       * @api public
       */
    
      compile: function(){
        this.buf = [];
        if (this.pp) this.buf.push("var jade_indent = [];");
        this.lastBufferedIdx = -1;
        this.visit(this.node);
        if (!this.dynamicMixins) {
          // if there are no dynamic mixins we can remove any un-used mixins
          var mixinNames = Object.keys(this.mixins);
          for (var i = 0; i < mixinNames.length; i++) {
            var mixin = this.mixins[mixinNames[i]];
            if (!mixin.used) {
              for (var x = 0; x < mixin.instances.length; x++) {
                for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++) {
                  this.buf[y] = '';
                }
              }
            }
          }
        }
        return this.buf.join('\n');
      },
    
      /**
       * Sets the default doctype `name`. Sets terse mode to `true` when
       * html 5 is used, causing self-closing tags to end with ">" vs "/>",
       * and boolean attributes are not mirrored.
       *
       * @param {string} name
       * @api public
       */
    
      setDoctype: function(name){
        this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';
        this.terse = this.doctype.toLowerCase() == '<!doctype html>';
        this.xml = 0 == this.doctype.indexOf('<?xml');
      },
    
      /**
       * Buffer the given `str` exactly as is or with interpolation
       *
       * @param {String} str
       * @param {Boolean} interpolate
       * @api public
       */
    
      buffer: function (str, interpolate) {
        var self = this;
        if (interpolate) {
          var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
          if (match) {
            this.buffer(str.substr(0, match.index), false);
            if (match[1]) { // escape
              this.buffer(match[2] + '{', false);
              this.buffer(match[3], true);
              return;
            } else {
              var rest = match[3];
              var range = parseJSExpression(rest);
              var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade_interp = " + range.src + ") == null ? '' : jade_interp)";
              this.bufferExpression(code);
              this.buffer(rest.substr(range.end + 1), true);
              return;
            }
          }
        }
    
        str = utils.stringify(str);
        str = str.substr(1, str.length - 2);
    
        if (this.lastBufferedIdx == this.buf.length) {
          if (this.lastBufferedType === 'code') this.lastBuffered += ' + "';
          this.lastBufferedType = 'text';
          this.lastBuffered += str;
          this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '");'
        } else {
          this.buf.push('buf.push("' + str + '");');
          this.lastBufferedType = 'text';
          this.bufferStartChar = '"';
          this.lastBuffered = str;
          this.lastBufferedIdx = this.buf.length;
        }
      },
    
      /**
       * Buffer the given `src` so it is evaluated at run time
       *
       * @param {String} src
       * @api public
       */
    
      bufferExpression: function (src) {
        if (isConstant(src)) {
          return this.buffer(toConstant(src) + '', false)
        }
        if (this.lastBufferedIdx == this.buf.length) {
          if (this.lastBufferedType === 'text') this.lastBuffered += '"';
          this.lastBufferedType = 'code';
          this.lastBuffered += ' + (' + src + ')';
          this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'
        } else {
          this.buf.push('buf.push(' + src + ');');
          this.lastBufferedType = 'code';
          this.bufferStartChar = '';
          this.lastBuffered = '(' + src + ')';
          this.lastBufferedIdx = this.buf.length;
        }
      },
    
      /**
       * Buffer an indent based on the current `indent`
       * property and an additional `offset`.
       *
       * @param {Number} offset
       * @param {Boolean} newline
       * @api public
       */
    
      prettyIndent: function(offset, newline){
        offset = offset || 0;
        newline = newline ? '\n' : '';
        this.buffer(newline + Array(this.indents + offset).join('  '));
        if (this.parentIndents)
          this.buf.push("buf.push.apply(buf, jade_indent);");
      },
    
      /**
       * Visit `node`.
       *
       * @param {Node} node
       * @api public
       */
    
      visit: function(node){
        var debug = this.debug;
    
        if (debug) {
          this.buf.push('jade_debug.unshift({ lineno: ' + node.line
            + ', filename: ' + (node.filename
              ? utils.stringify(node.filename)
              : 'jade_debug[0].filename')
            + ' });');
        }
    
        // Massive hack to fix our context
        // stack for - else[ if] etc
        if (false === node.debug && this.debug) {
          this.buf.pop();
          this.buf.pop();
        }
    
        this.visitNode(node);
    
        if (debug) this.buf.push('jade_debug.shift();');
      },
    
      /**
       * Visit `node`.
       *
       * @param {Node} node
       * @api public
       */
    
      visitNode: function(node){
        return this['visit' + node.type](node);
      },
    
      /**
       * Visit case `node`.
       *
       * @param {Literal} node
       * @api public
       */
    
      visitCase: function(node){
        var _ = this.withinCase;
        this.withinCase = true;
        this.buf.push('switch (' + node.expr + '){');
        this.visit(node.block);
        this.buf.push('}');
        this.withinCase = _;
      },
    
      /**
       * Visit when `node`.
       *
       * @param {Literal} node
       * @api public
       */
    
      visitWhen: function(node){
        if ('default' == node.expr) {
          this.buf.push('default:');
        } else {
          this.buf.push('case ' + node.expr + ':');
        }
        if (node.block) {
          this.visit(node.block);
          this.buf.push('  break;');
        }
      },
    
      /**
       * Visit literal `node`.
       *
       * @param {Literal} node
       * @api public
       */
    
      visitLiteral: function(node){
        this.buffer(node.str);
      },
    
      /**
       * Visit all nodes in `block`.
       *
       * @param {Block} block
       * @api public
       */
    
      visitBlock: function(block){
        var len = block.nodes.length
          , escape = this.escape
          , pp = this.pp
    
        // Pretty print multi-line text
        if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)
          this.prettyIndent(1, true);
    
        for (var i = 0; i < len; ++i) {
          // Pretty print text
          if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)
            this.prettyIndent(1, false);
    
          this.visit(block.nodes[i]);
          // Multiple text nodes are separated by newlines
          if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)
            this.buffer('\n');
        }
      },
    
      /**
       * Visit a mixin's `block` keyword.
       *
       * @param {MixinBlock} block
       * @api public
       */
    
      visitMixinBlock: function(block){
        if (this.pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join('  ') + "');");
        this.buf.push('block && block();');
        if (this.pp) this.buf.push("jade_indent.pop();");
      },
    
      /**
       * Visit `doctype`. Sets terse mode to `true` when html 5
       * is used, causing self-closing tags to end with ">" vs "/>",
       * and boolean attributes are not mirrored.
       *
       * @param {Doctype} doctype
       * @api public
       */
    
      visitDoctype: function(doctype){
        if (doctype && (doctype.val || !this.doctype)) {
          this.setDoctype(doctype.val || 'default');
        }
    
        if (this.doctype) this.buffer(this.doctype);
        this.hasCompiledDoctype = true;
      },
    
      /**
       * Visit `mixin`, generating a function that
       * may be called within the template.
       *
       * @param {Mixin} mixin
       * @api public
       */
    
      visitMixin: function(mixin){
        var name = 'jade_mixins[';
        var args = mixin.args || '';
        var block = mixin.block;
        var attrs = mixin.attrs;
        var attrsBlocks = mixin.attributeBlocks;
        var pp = this.pp;
        var dynamic = mixin.name[0]==='#';
        var key = mixin.name;
        if (dynamic) this.dynamicMixins = true;
        name += (dynamic ? mixin.name.substr(2,mixin.name.length-3):'"'+mixin.name+'"')+']';
    
        this.mixins[key] = this.mixins[key] || {used: false, instances: []};
        if (mixin.call) {
          this.mixins[key].used = true;
          if (pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join('  ') + "');")
          if (block || attrs.length || attrsBlocks.length) {
    
            this.buf.push(name + '.call({');
    
            if (block) {
              this.buf.push('block: function(){');
    
              // Render block with no indents, dynamically added when rendered
              this.parentIndents++;
              var _indents = this.indents;
              this.indents = 0;
              this.visit(mixin.block);
              this.indents = _indents;
              this.parentIndents--;
    
              if (attrs.length || attrsBlocks.length) {
                this.buf.push('},');
              } else {
                this.buf.push('}');
              }
            }
    
            if (attrsBlocks.length) {
              if (attrs.length) {
                var val = this.attrs(attrs);
                attrsBlocks.unshift(val);
              }
              this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
            } else if (attrs.length) {
              var val = this.attrs(attrs);
              this.buf.push('attributes: ' + val);
            }
    
            if (args) {
              this.buf.push('}, ' + args + ');');
            } else {
              this.buf.push('});');
            }
    
          } else {
            this.buf.push(name + '(' + args + ');');
          }
          if (pp) this.buf.push("jade_indent.pop();")
        } else {
          var mixin_start = this.buf.length;
          args = args ? args.split(',') : [];
          var rest;
          if (args.length && /^\.\.\./.test(args[args.length - 1].trim())) {
            rest = args.pop().trim().replace(/^\.\.\./, '');
          }
          this.buf.push(name + ' = function(' + args.join(',') + '){');
          this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');
          if (rest) {
            this.buf.push('var ' + rest + ' = [];');
            this.buf.push('for (jade_interp = ' + args.length + '; jade_interp < arguments.length; jade_interp++) {');
            this.buf.push('  ' + rest + '.push(arguments[jade_interp]);');
            this.buf.push('}');
          }
          this.parentIndents++;
          this.visit(block);
          this.parentIndents--;
          this.buf.push('};');
          var mixin_end = this.buf.length;
          this.mixins[key].instances.push({start: mixin_start, end: mixin_end});
        }
      },
    
      /**
       * Visit `tag` buffering tag markup, generating
       * attributes, visiting the `tag`'s code and block.
       *
       * @param {Tag} tag
       * @api public
       */
    
      visitTag: function(tag){
        this.indents++;
        var name = tag.name
          , pp = this.pp
          , self = this;
    
        function bufferName() {
          if (tag.buffer) self.bufferExpression(name);
          else self.buffer(name);
        }
    
        if ('pre' == tag.name) this.escape = true;
    
        if (!this.hasCompiledTag) {
          if (!this.hasCompiledDoctype && 'html' == name) {
            this.visitDoctype();
          }
          this.hasCompiledTag = true;
        }
    
        // pretty print
        if (pp && !tag.isInline())
          this.prettyIndent(0, true);
    
        if (tag.selfClosing || (!this.xml && selfClosing.indexOf(tag.name) !== -1)) {
          this.buffer('<');
          bufferName();
          this.visitAttributes(tag.attrs, tag.attributeBlocks);
          this.terse
            ? this.buffer('>')
            : this.buffer('/>');
          // if it is non-empty throw an error
          if (tag.block &&
              !(tag.block.type === 'Block' && tag.block.nodes.length === 0) &&
              tag.block.nodes.some(function (tag) {
                return tag.type !== 'Text' || !/^\s*$/.test(tag.val)
              })) {
            throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));
          }
        } else {
          // Optimize attributes buffering
          this.buffer('<');
          bufferName();
          this.visitAttributes(tag.attrs, tag.attributeBlocks);
          this.buffer('>');
          if (tag.code) this.visitCode(tag.code);
          this.visit(tag.block);
    
          // pretty print
          if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())
            this.prettyIndent(0, true);
    
          this.buffer('</');
          bufferName();
          this.buffer('>');
        }
    
        if ('pre' == tag.name) this.escape = false;
    
        this.indents--;
      },
    
      /**
       * Visit `filter`, throwing when the filter does not exist.
       *
       * @param {Filter} filter
       * @api public
       */
    
      visitFilter: function(filter){
        var text = filter.block.nodes.map(
          function(node){ return node.val; }
        ).join('\n');
        filter.attrs.filename = this.options.filename;
        try {
          this.buffer(filters(filter.name, text, filter.attrs), true);
        } catch (err) {
          throw errorAtNode(filter, err);
        }
      },
    
      /**
       * Visit `text` node.
       *
       * @param {Text} text
       * @api public
       */
    
      visitText: function(text){
        this.buffer(text.val, true);
      },
    
      /**
       * Visit a `comment`, only buffering when the buffer flag is set.
       *
       * @param {Comment} comment
       * @api public
       */
    
      visitComment: function(comment){
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('<!--' + comment.val + '-->');
      },
    
      /**
       * Visit a `BlockComment`.
       *
       * @param {Comment} comment
       * @api public
       */
    
      visitBlockComment: function(comment){
        if (!comment.buffer) return;
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('<!--' + comment.val);
        this.visit(comment.block);
        if (this.pp) this.prettyIndent(1, true);
        this.buffer('-->');
      },
    
      /**
       * Visit `code`, respecting buffer / escape flags.
       * If the code is followed by a block, wrap it in
       * a self-calling function.
       *
       * @param {Code} code
       * @api public
       */
    
      visitCode: function(code){
        // Wrap code blocks with {}.
        // we only wrap unbuffered code blocks ATM
        // since they are usually flow control
    
        // Buffer code
        if (code.buffer) {
          var val = code.val.trimLeft();
          val = 'null == (jade_interp = '+val+') ? "" : jade_interp';
          if (code.escape) val = 'jade.escape(' + val + ')';
          this.bufferExpression(val);
        } else {
          this.buf.push(code.val);
        }
    
        // Block support
        if (code.block) {
          if (!code.buffer) this.buf.push('{');
          this.visit(code.block);
          if (!code.buffer) this.buf.push('}');
        }
      },
    
      /**
       * Visit `each` block.
       *
       * @param {Each} each
       * @api public
       */
    
      visitEach: function(each){
        this.buf.push(''
          + '// iterate ' + each.obj + '\n'
          + ';(function(){\n'
          + '  var $$obj = ' + each.obj + ';\n'
          + '  if (\'number\' == typeof $$obj.length) {\n');
    
        if (each.alternative) {
          this.buf.push('  if ($$obj.length) {');
        }
    
        this.buf.push(''
          + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\n'
          + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');
    
        this.visit(each.block);
    
        this.buf.push('    }\n');
    
        if (each.alternative) {
          this.buf.push('  } else {');
          this.visit(each.alternative);
          this.buf.push('  }');
        }
    
        this.buf.push(''
          + '  } else {\n'
          + '    var $$l = 0;\n'
          + '    for (var ' + each.key + ' in $$obj) {\n'
          + '      $$l++;'
          + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');
    
        this.visit(each.block);
    
        this.buf.push('    }\n');
        if (each.alternative) {
          this.buf.push('    if ($$l === 0) {');
          this.visit(each.alternative);
          this.buf.push('    }');
        }
        this.buf.push('  }\n}).call(this);\n');
      },
    
      /**
       * Visit `attrs`.
       *
       * @param {Array} attrs
       * @api public
       */
    
      visitAttributes: function(attrs, attributeBlocks){
        if (attributeBlocks.length) {
          if (attrs.length) {
            var val = this.attrs(attrs);
            attributeBlocks.unshift(val);
          }
          this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(',') + ']), ' + utils.stringify(this.terse) + ')');
        } else if (attrs.length) {
          this.attrs(attrs, true);
        }
      },
    
      /**
       * Compile attributes.
       */
    
      attrs: function(attrs, buffer){
        var buf = [];
        var classes = [];
        var classEscaping = [];
    
        attrs.forEach(function(attr){
          var key = attr.name;
          var escaped = attr.escaped;
    
          if (key === 'class') {
            classes.push(attr.val);
            classEscaping.push(attr.escaped);
          } else if (isConstant(attr.val)) {
            if (buffer) {
              this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
            } else {
              var val = toConstant(attr.val);
              if (escaped && !(key.indexOf('data') === 0 && typeof val !== 'string')) {
                val = runtime.escape(val);
              }
              buf.push(utils.stringify(key) + ': ' + utils.stringify(val));
            }
          } else {
            if (buffer) {
              this.bufferExpression('jade.attr("' + key + '", ' + attr.val + ', ' + utils.stringify(escaped) + ', ' + utils.stringify(this.terse) + ')');
            } else {
              var val = attr.val;
              if (escaped && !(key.indexOf('data') === 0)) {
                val = 'jade.escape(' + val + ')';
              } else if (escaped) {
                val = '(typeof (jade_interp = ' + val + ') == "string" ? jade.escape(jade_interp) : jade_interp)';
              }
              buf.push(utils.stringify(key) + ': ' + val);
            }
          }
        }.bind(this));
        if (buffer) {
          if (classes.every(isConstant)) {
            this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
          } else {
            this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + utils.stringify(classEscaping) + ')');
          }
        } else if (classes.length) {
          if (classes.every(isConstant)) {
            classes = utils.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
              return classEscaping[i] ? runtime.escape(cls) : cls;
            })));
          } else {
            classes = '(jade_interp = ' + utils.stringify(classEscaping) + ',' +
              ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {' +
              '   return jade_interp[i] ? jade.escape(cls) : cls' +
              ' }))' +
              ')';
          }
          if (classes.length)
            buf.push('"class": ' + classes);
        }
        return '{' + buf.join(',') + '}';
      }
    };
    
  provide("jade/lib/compiler", module.exports);
}(global));

// pakmanager:jade/lib/jade
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /*!
     * Jade
     * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var Parser =  require('jade/lib/parser')
      , Lexer =  require('jade/lib/lexer')
      , Compiler =  require('jade/lib/compiler')
      , runtime =  require('jade/lib/runtime')
      , addWith = require('with')
      , fs = require('fs')
      , utils =  require('jade/lib/utils');
    
    /**
     * Expose self closing tags.
     */
    
    exports.selfClosing = require('void-elements');
    
    /**
     * Default supported doctypes.
     */
    
    exports.doctypes =  require('jade/lib/doctypes');
    
    /**
     * Text filters.
     */
    
    exports.filters =  require('jade/lib/filters');
    
    /**
     * Utilities.
     */
    
    exports.utils =  require('jade/lib/utils');
    
    /**
     * Expose `Compiler`.
     */
    
    exports.Compiler = Compiler;
    
    /**
     * Expose `Parser`.
     */
    
    exports.Parser = Parser;
    
    /**
     * Expose `Lexer`.
     */
    
    exports.Lexer = Lexer;
    
    /**
     * Nodes.
     */
    
    exports.nodes =  require('jade/lib/nodes');
    
    /**
     * Jade runtime helpers.
     */
    
    exports.runtime = runtime;
    
    /**
     * Template function cache.
     */
    
    exports.cache = {};
    
    /**
     * Parse the given `str` of jade and return a function body.
     *
     * @param {String} str
     * @param {Object} options
     * @return {Object}
     * @api private
     */
    
    function parse(str, options){
      // Parse
      var parser = new (options.parser || Parser)(str, options.filename, options);
      var tokens;
      try {
        // Parse
        tokens = parser.parse();
      } catch (err) {
        parser = parser.context();
        runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
      }
    
      // Compile
      var compiler = new (options.compiler || Compiler)(tokens, options);
      var js;
      try {
        js = compiler.compile();
      } catch (err) {
        if (err.line && (err.filename || !options.filename)) {
          runtime.rethrow(err, err.filename, err.line, parser.input);
        }
      }
    
      // Debug compiler
      if (options.debug) {
        console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '));
      }
    
      var globals = [];
    
      if (options.globals) {
        globals = options.globals.slice();
      }
    
      globals.push('jade');
      globals.push('jade_mixins');
      globals.push('jade_interp');
      globals.push('jade_debug');
      globals.push('buf');
    
      var body = ''
        + 'var buf = [];\n'
        + 'var jade_mixins = {};\n'
        + 'var jade_interp;\n'
        + (options.self
          ? 'var self = locals || {};\n' + js
          : addWith('locals || {}', '\n' + js, globals)) + ';'
        + 'return buf.join("");';
      return {body: body, dependencies: parser.dependencies};
    }
    
    /**
     * Compile a `Function` representation of the given jade `str`.
     *
     * Options:
     *
     *   - `compileDebug` when `false` debugging code is stripped from the compiled
           template, when it is explicitly `true`, the source code is included in
           the compiled template for better accuracy.
     *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends
     *
     * @param {String} str
     * @param {Options} options
     * @return {Function}
     * @api public
     */
    
    exports.compile = function(str, options){
      var options = options || {}
        , filename = options.filename
          ? utils.stringify(options.filename)
          : 'undefined'
        , fn;
    
      str = String(str);
    
      var parsed = parse(str, options);
      if (options.compileDebug !== false) {
        fn = [
            'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
          , 'try {'
          , parsed.body
          , '} catch (err) {'
          , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + utils.stringify(str) : '') + ');'
          , '}'
        ].join('\n');
      } else {
        fn = parsed.body;
      }
      fn = new Function('locals, jade', fn)
      var res = function(locals){ return fn(locals, Object.create(runtime)) };
      if (options.client) {
        res.toString = function () {
          var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
          err.name = 'Warning';
          console.error(err.stack || err.message);
          return exports.compileClient(str, options);
        };
      }
      res.dependencies = parsed.dependencies;
      return res;
    };
    
    /**
     * Compile a JavaScript source representation of the given jade `str`.
     *
     * Options:
     *
     *   - `compileDebug` When it is `true`, the source code is included in
     *     the compiled template for better error messages.
     *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
     *   - `name` the name of the resulting function (defaults to "template")
     *
     * @param {String} str
     * @param {Options} options
     * @return {String}
     * @api public
     */
    
    exports.compileClient = function(str, options){
      var options = options || {};
      var name = options.name || 'template';
      var filename = options.filename ? utils.stringify(options.filename) : 'undefined';
      var fn;
    
      str = String(str);
    
      if (options.compileDebug) {
        options.compileDebug = true;
        fn = [
            'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
          , 'try {'
          , parse(str, options).body
          , '} catch (err) {'
          , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + utils.stringify(str) + ');'
          , '}'
        ].join('\n');
      } else {
        options.compileDebug = false;
        fn = parse(str, options).body;
      }
    
      return 'function ' + name + '(locals) {\n' + fn + '\n}';
    };
    
    /**
     * Compile a `Function` representation of the given jade file.
     *
     * Options:
     *
     *   - `compileDebug` when `false` debugging code is stripped from the compiled
           template, when it is explicitly `true`, the source code is included in
           the compiled template for better accuracy.
     *
     * @param {String} path
     * @param {Options} options
     * @return {Function}
     * @api public
     */
    exports.compileFile = function (path, options) {
      options = options || {};
    
      var key = path + ':string';
    
      options.filename = path;
      var str = options.cache
        ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
        : fs.readFileSync(path, 'utf8');
    
      return options.cache
        ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))
        : exports.compile(str, options);
    };
    
    /**
     * Render the given `str` of jade.
     *
     * Options:
     *
     *   - `cache` enable template caching
     *   - `filename` filename required for `include` / `extends` and caching
     *
     * @param {String} str
     * @param {Object|Function} options or fn
     * @param {Function|undefined} fn
     * @returns {String}
     * @api public
     */
    
    exports.render = function(str, options, fn){
      // support callback API
      if ('function' == typeof options) {
        fn = options, options = undefined;
      }
      if (typeof fn === 'function') {
        var res
        try {
          res = exports.render(str, options);
        } catch (ex) {
          return fn(ex);
        }
        return fn(null, res);
      }
    
      options = options || {};
    
      // cache requires .filename
      if (options.cache && !options.filename) {
        throw new Error('the "filename" option is required for caching');
      }
    
      var path = options.filename;
      var tmpl = options.cache
        ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))
        : exports.compile(str, options);
      return tmpl(options);
    };
    
    /**
     * Render a Jade file at the given `path`.
     *
     * @param {String} path
     * @param {Object|Function} options or callback
     * @param {Function|undefined} fn
     * @returns {String}
     * @api public
     */
    
    exports.renderFile = function(path, options, fn){
      // support callback API
      if ('function' == typeof options) {
        fn = options, options = undefined;
      }
      if (typeof fn === 'function') {
        var res
        try {
          res = exports.renderFile(path, options);
        } catch (ex) {
          return fn(ex);
        }
        return fn(null, res);
      }
    
      options = options || {};
    
      var key = path + ':string';
    
      options.filename = path;
      var str = options.cache
        ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
        : fs.readFileSync(path, 'utf8');
      return exports.render(str, options);
    };
    
    
    /**
     * Compile a Jade file at the given `path` for use on the client.
     *
     * @param {String} path
     * @param {Object} options
     * @returns {String}
     * @api public
     */
    
    exports.compileFileClient = function(path, options){
      options = options || {};
    
      var key = path + ':string';
    
      options.filename = path;
      var str = options.cache
        ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
        : fs.readFileSync(path, 'utf8');
    
      return exports.compileClient(str, options);
    };
    
    /**
     * Express support.
     */
    
    exports.__express = exports.renderFile;
    
  provide("jade/lib/jade", module.exports);
}(global));

// pakmanager:jade
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports =  require('jade/lib/jade');
    
  provide("jade", module.exports);
}(global));

// pakmanager:diff
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* See LICENSE file for terms of use */
    
    /*
     * Text diff implementation.
     *
     * This library supports the following APIS:
     * JsDiff.diffChars: Character by character diff
     * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
     * JsDiff.diffLines: Line based diff
     *
     * JsDiff.diffCss: Diff targeted at CSS content
     *
     * These methods are based on the implementation proposed in
     * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
     * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
     */
    var JsDiff = (function() {
      /*jshint maxparams: 5*/
      function clonePath(path) {
        return { newPos: path.newPos, components: path.components.slice(0) };
      }
      function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      }
      function escapeHTML(s) {
        var n = s;
        n = n.replace(/&/g, '&amp;');
        n = n.replace(/</g, '&lt;');
        n = n.replace(/>/g, '&gt;');
        n = n.replace(/"/g, '&quot;');
    
        return n;
      }
    
      var Diff = function(ignoreWhitespace) {
        this.ignoreWhitespace = ignoreWhitespace;
      };
      Diff.prototype = {
          diff: function(oldString, newString) {
            // Handle the identity case (this is due to unrolling editLength == 0
            if (newString === oldString) {
              return [{ value: newString }];
            }
            if (!newString) {
              return [{ value: oldString, removed: true }];
            }
            if (!oldString) {
              return [{ value: newString, added: true }];
            }
    
            newString = this.tokenize(newString);
            oldString = this.tokenize(oldString);
    
            var newLen = newString.length, oldLen = oldString.length;
            var maxEditLength = newLen + oldLen;
            var bestPath = [{ newPos: -1, components: [] }];
    
            // Seed editLength = 0
            var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
            if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {
              return bestPath[0].components;
            }
    
            for (var editLength = 1; editLength <= maxEditLength; editLength++) {
              for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {
                var basePath;
                var addPath = bestPath[diagonalPath-1],
                    removePath = bestPath[diagonalPath+1];
                oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
                if (addPath) {
                  // No one else is going to attempt to use this value, clear it
                  bestPath[diagonalPath-1] = undefined;
                }
    
                var canAdd = addPath && addPath.newPos+1 < newLen;
                var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
                if (!canAdd && !canRemove) {
                  bestPath[diagonalPath] = undefined;
                  continue;
                }
    
                // Select the diagonal that we want to branch from. We select the prior
                // path whose position in the new string is the farthest from the origin
                // and does not pass the bounds of the diff graph
                if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
                  basePath = clonePath(removePath);
                  this.pushComponent(basePath.components, oldString[oldPos], undefined, true);
                } else {
                  basePath = clonePath(addPath);
                  basePath.newPos++;
                  this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);
                }
    
                var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);
    
                if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {
                  return basePath.components;
                } else {
                  bestPath[diagonalPath] = basePath;
                }
              }
            }
          },
    
          pushComponent: function(components, value, added, removed) {
            var last = components[components.length-1];
            if (last && last.added === added && last.removed === removed) {
              // We need to clone here as the component clone operation is just
              // as shallow array clone
              components[components.length-1] =
                {value: this.join(last.value, value), added: added, removed: removed };
            } else {
              components.push({value: value, added: added, removed: removed });
            }
          },
          extractCommon: function(basePath, newString, oldString, diagonalPath) {
            var newLen = newString.length,
                oldLen = oldString.length,
                newPos = basePath.newPos,
                oldPos = newPos - diagonalPath;
            while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {
              newPos++;
              oldPos++;
    
              this.pushComponent(basePath.components, newString[newPos], undefined, undefined);
            }
            basePath.newPos = newPos;
            return oldPos;
          },
    
          equals: function(left, right) {
            var reWhitespace = /\S/;
            if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {
              return true;
            } else {
              return left === right;
            }
          },
          join: function(left, right) {
            return left + right;
          },
          tokenize: function(value) {
            return value;
          }
      };
    
      var CharDiff = new Diff();
    
      var WordDiff = new Diff(true);
      var WordWithSpaceDiff = new Diff();
      WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {
        return removeEmpty(value.split(/(\s+|\b)/));
      };
    
      var CssDiff = new Diff(true);
      CssDiff.tokenize = function(value) {
        return removeEmpty(value.split(/([{}:;,]|\s+)/));
      };
    
      var LineDiff = new Diff();
      LineDiff.tokenize = function(value) {
        var retLines = [],
            lines = value.split(/^/m);
    
        for(var i = 0; i < lines.length; i++) {
          var line = lines[i],
              lastLine = lines[i - 1];
    
          // Merge lines that may contain windows new lines
          if (line == '\n' && lastLine && lastLine[lastLine.length - 1] === '\r') {
            retLines[retLines.length - 1] += '\n';
          } else if (line) {
            retLines.push(line);
          }
        }
    
        return retLines;
      };
    
      return {
        Diff: Diff,
    
        diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },
        diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },
        diffWordsWithSpace: function(oldStr, newStr) { return WordWithSpaceDiff.diff(oldStr, newStr); },
        diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },
    
        diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },
    
        createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
          var ret = [];
    
          ret.push('Index: ' + fileName);
          ret.push('===================================================================');
          ret.push('--- ' + fileName + (typeof oldHeader === 'undefined' ? '' : '\t' + oldHeader));
          ret.push('+++ ' + fileName + (typeof newHeader === 'undefined' ? '' : '\t' + newHeader));
    
          var diff = LineDiff.diff(oldStr, newStr);
          if (!diff[diff.length-1].value) {
            diff.pop();   // Remove trailing newline add
          }
          diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier
    
          function contextLines(lines) {
            return lines.map(function(entry) { return ' ' + entry; });
          }
          function eofNL(curRange, i, current) {
            var last = diff[diff.length-2],
                isLast = i === diff.length-2,
                isLastOfType = i === diff.length-3 && (current.added !== last.added || current.removed !== last.removed);
    
            // Figure out if this is the last line for the given file and missing NL
            if (!/\n$/.test(current.value) && (isLast || isLastOfType)) {
              curRange.push('\\ No newline at end of file');
            }
          }
    
          var oldRangeStart = 0, newRangeStart = 0, curRange = [],
              oldLine = 1, newLine = 1;
          for (var i = 0; i < diff.length; i++) {
            var current = diff[i],
                lines = current.lines || current.value.replace(/\n$/, '').split('\n');
            current.lines = lines;
    
            if (current.added || current.removed) {
              if (!oldRangeStart) {
                var prev = diff[i-1];
                oldRangeStart = oldLine;
                newRangeStart = newLine;
    
                if (prev) {
                  curRange = contextLines(prev.lines.slice(-4));
                  oldRangeStart -= curRange.length;
                  newRangeStart -= curRange.length;
                }
              }
              curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?'+':'-') + entry; }));
              eofNL(curRange, i, current);
    
              if (current.added) {
                newLine += lines.length;
              } else {
                oldLine += lines.length;
              }
            } else {
              if (oldRangeStart) {
                // Close out any changes that have been output (or join overlapping)
                if (lines.length <= 8 && i < diff.length-2) {
                  // Overlapping
                  curRange.push.apply(curRange, contextLines(lines));
                } else {
                  // end the range and output
                  var contextSize = Math.min(lines.length, 4);
                  ret.push(
                      '@@ -' + oldRangeStart + ',' + (oldLine-oldRangeStart+contextSize)
                      + ' +' + newRangeStart + ',' + (newLine-newRangeStart+contextSize)
                      + ' @@');
                  ret.push.apply(ret, curRange);
                  ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
                  if (lines.length <= 4) {
                    eofNL(ret, i, current);
                  }
    
                  oldRangeStart = 0;  newRangeStart = 0; curRange = [];
                }
              }
              oldLine += lines.length;
              newLine += lines.length;
            }
          }
    
          return ret.join('\n') + '\n';
        },
    
        applyPatch: function(oldStr, uniDiff) {
          var diffstr = uniDiff.split('\n');
          var diff = [];
          var remEOFNL = false,
              addEOFNL = false;
    
          for (var i = (diffstr[0][0]==='I'?4:0); i < diffstr.length; i++) {
            if(diffstr[i][0] === '@') {
              var meh = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
              diff.unshift({
                start:meh[3],
                oldlength:meh[2],
                oldlines:[],
                newlength:meh[4],
                newlines:[]
              });
            } else if(diffstr[i][0] === '+') {
              diff[0].newlines.push(diffstr[i].substr(1));
            } else if(diffstr[i][0] === '-') {
              diff[0].oldlines.push(diffstr[i].substr(1));
            } else if(diffstr[i][0] === ' ') {
              diff[0].newlines.push(diffstr[i].substr(1));
              diff[0].oldlines.push(diffstr[i].substr(1));
            } else if(diffstr[i][0] === '\\') {
              if (diffstr[i-1][0] === '+') {
                remEOFNL = true;
              } else if(diffstr[i-1][0] === '-') {
                addEOFNL = true;
              }
            }
          }
    
          var str = oldStr.split('\n');
          for (var i = diff.length - 1; i >= 0; i--) {
            var d = diff[i];
            for (var j = 0; j < d.oldlength; j++) {
              if(str[d.start-1+j] !== d.oldlines[j]) {
                return false;
              }
            }
            Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));
          }
    
          if (remEOFNL) {
            while (!str[str.length-1]) {
              str.pop();
            }
          } else if (addEOFNL) {
            str.push('');
          }
          return str.join('\n');
        },
    
        convertChangesToXML: function(changes){
          var ret = [];
          for ( var i = 0; i < changes.length; i++) {
            var change = changes[i];
            if (change.added) {
              ret.push('<ins>');
            } else if (change.removed) {
              ret.push('<del>');
            }
    
            ret.push(escapeHTML(change.value));
    
            if (change.added) {
              ret.push('</ins>');
            } else if (change.removed) {
              ret.push('</del>');
            }
          }
          return ret.join('');
        },
    
        // See: http://code.google.com/p/google-diff-match-patch/wiki/API
        convertChangesToDMP: function(changes){
          var ret = [], change;
          for ( var i = 0; i < changes.length; i++) {
            change = changes[i];
            ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);
          }
          return ret;
        }
      };
    })();
    
    if (typeof module !== 'undefined') {
        module.exports = JsDiff;
    }
    
  provide("diff", module.exports);
}(global));

// pakmanager:glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    // readdir(PREFIX) as ENTRIES
    //   If fails, END
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $])
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $])
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    
    
    module.exports = glob
    
    var fs = require("graceful-fs")
    , minimatch = require("minimatch")
    , Minimatch = minimatch.Minimatch
    , inherits = require("inherits")
    , EE = require("events").EventEmitter
    , path = require("path")
    , isDir = {}
    , assert = require("assert").ok
    , once = require("once")
    
    function glob (pattern, options, cb) {
      if (typeof options === "function") cb = options, options = {}
      if (!options) options = {}
    
      if (typeof options === "number") {
        deprecated()
        return
      }
    
      var g = new Glob(pattern, options, cb)
      return g.sync ? g.found : g
    }
    
    glob.fnmatch = deprecated
    
    function deprecated () {
      throw new Error("glob's interface has changed. Please see the docs.")
    }
    
    glob.sync = globSync
    function globSync (pattern, options) {
      if (typeof options === "number") {
        deprecated()
        return
      }
    
      options = options || {}
      options.sync = true
      return glob(pattern, options)
    }
    
    this._processingEmitQueue = false
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (!(this instanceof Glob)) {
        return new Glob(pattern, options, cb)
      }
    
      if (typeof options === "function") {
        cb = options
        options = null
      }
    
      if (typeof cb === "function") {
        cb = once(cb)
        this.on("error", cb)
        this.on("end", function (matches) {
          cb(null, matches)
        })
      }
    
      options = options || {}
    
      this._endEmitted = false
      this.EOF = {}
      this._emitQueue = []
    
      this.paused = false
      this._processingEmitQueue = false
    
      this.maxDepth = options.maxDepth || 1000
      this.maxLength = options.maxLength || Infinity
      this.cache = options.cache || {}
      this.statCache = options.statCache || {}
    
      this.changedCwd = false
      var cwd = process.cwd()
      if (!options.hasOwnProperty("cwd")) this.cwd = cwd
      else {
        this.cwd = options.cwd
        this.changedCwd = path.resolve(options.cwd) !== cwd
      }
    
      this.root = options.root || path.resolve(this.cwd, "/")
      this.root = path.resolve(this.root)
      if (process.platform === "win32")
        this.root = this.root.replace(/\\/g, "/")
    
      this.nomount = !!options.nomount
    
      if (!pattern) {
        throw new Error("must provide pattern")
      }
    
      // base-matching: just use globstar for that.
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar")
        }
        pattern = "**/" + pattern
      }
    
      this.strict = options.strict !== false
      this.dot = !!options.dot
      this.mark = !!options.mark
      this.sync = !!options.sync
      this.nounique = !!options.nounique
      this.nonull = !!options.nonull
      this.nosort = !!options.nosort
      this.nocase = !!options.nocase
      this.stat = !!options.stat
    
      this.debug = !!options.debug || !!options.globDebug
    
      if (/\bglob\b/.test(process.env.NODE_DEBUG || ''))
        this.debug = true
    
      if (this.debug)
        this.log = console.error
    
      this.silent = !!options.silent
    
      var mm = this.minimatch = new Minimatch(pattern, options)
      this.options = mm.options
      pattern = this.pattern = mm.pattern
    
      this.error = null
      this.aborted = false
    
      // list of all the patterns that ** has resolved do, so
      // we can avoid visiting multiple times.
      this._globstars = {}
    
      EE.call(this)
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (this.minimatch.set.length === 0) {
        return process.nextTick(this._finish.bind(this))
      }
    
      this.minimatch.set.forEach(iterator.bind(this))
      function iterator (pattern, i, set) {
        this._process(pattern, 0, i, function (er) {
          if (er) this.emit("error", er)
          if (-- n <= 0) this._finish()
        })
      }
    }
    
    Glob.prototype.log = function () {}
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
    
      var nou = this.nounique
      , all = nou ? [] : {}
    
      for (var i = 0, l = this.matches.length; i < l; i ++) {
        var matches = this.matches[i]
        this.log("matches[%d] =", i, matches)
        // do like the shell, and spit out the literal glob
        if (!matches) {
          if (this.nonull) {
            var literal = this.minimatch.globSet[i]
            if (nou) all.push(literal)
            else all[literal] = true
          }
        } else {
          // had matches
          var m = Object.keys(matches)
          if (nou) all.push.apply(all, m)
          else m.forEach(function (m) {
            all[m] = true
          })
        }
      }
    
      if (!nou) all = Object.keys(all)
    
      if (!this.nosort) {
        all = all.sort(this.nocase ? alphasorti : alphasort)
      }
    
      if (this.mark) {
        // at *some* point we statted all of these
        all = all.map(this._mark, this)
      }
    
      this.log("emitting end", all)
    
      this.EOF = this.found = all
      this.emitMatch(this.EOF)
    }
    
    function alphasorti (a, b) {
      a = a.toLowerCase()
      b = b.toLowerCase()
      return alphasort(a, b)
    }
    
    function alphasort (a, b) {
      return a > b ? 1 : a < b ? -1 : 0
    }
    
    Glob.prototype._mark = function (p) {
      var c = this.cache[p]
      var m = p
      if (c) {
        var isDir = c === 2 || Array.isArray(c)
        var slash = p.slice(-1) === '/'
    
        if (isDir && !slash)
          m += '/'
        else if (!isDir && slash)
          m = m.slice(0, -1)
    
        if (m !== p) {
          this.statCache[m] = this.statCache[p]
          this.cache[m] = this.cache[p]
        }
      }
    
      return m
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit("abort")
    }
    
    Glob.prototype.pause = function () {
      if (this.paused) return
      if (this.sync)
        this.emit("error", new Error("Can't pause/resume sync glob"))
      this.paused = true
      this.emit("pause")
    }
    
    Glob.prototype.resume = function () {
      if (!this.paused) return
      if (this.sync)
        this.emit("error", new Error("Can't pause/resume sync glob"))
      this.paused = false
      this.emit("resume")
      this._processEmitQueue()
      //process.nextTick(this.emit.bind(this, "resume"))
    }
    
    Glob.prototype.emitMatch = function (m) {
      this.log('emitMatch', m)
      this._emitQueue.push(m)
      this._processEmitQueue()
    }
    
    Glob.prototype._processEmitQueue = function (m) {
      this.log("pEQ paused=%j processing=%j m=%j", this.paused,
               this._processingEmitQueue, m)
      var done = false
      while (!this._processingEmitQueue &&
             !this.paused) {
        this._processingEmitQueue = true
        var m = this._emitQueue.shift()
        this.log(">processEmitQueue", m === this.EOF ? ":EOF:" : m)
        if (!m) {
          this.log(">processEmitQueue, falsey m")
          this._processingEmitQueue = false
          break
        }
    
        if (m === this.EOF || !(this.mark && !this.stat)) {
          this.log("peq: unmarked, or eof")
          next.call(this, 0, false)
        } else if (this.statCache[m]) {
          var sc = this.statCache[m]
          var exists
          if (sc)
            exists = sc.isDirectory() ? 2 : 1
          this.log("peq: stat cached")
          next.call(this, exists, exists === 2)
        } else {
          this.log("peq: _stat, then next")
          this._stat(m, next)
        }
      }
      done = true
    
      function next(exists, isDir) {
        this.log("next", m, exists, isDir)
        var ev = m === this.EOF ? "end" : "match"
    
        // "end" can only happen once.
        assert(!this._endEmitted)
        if (ev === "end")
          this._endEmitted = true
    
        if (exists) {
          // Doesn't mean it necessarily doesn't exist, it's possible
          // we just didn't check because we don't care that much, or
          // this is EOF anyway.
          if (isDir && !m.match(/\/$/)) {
            m = m + "/"
          } else if (!isDir && m.match(/\/$/)) {
            m = m.replace(/\/+$/, "")
          }
        }
        this.log("emit", ev, m)
        this.emit(ev, m)
        this._processingEmitQueue = false
        if (done && m !== this.EOF && !this.paused)
          this._processEmitQueue()
      }
    }
    
    Glob.prototype._process = function (pattern, depth, index, cb_) {
      assert(this instanceof Glob)
    
      var cb = function cb (er, res) {
        assert(this instanceof Glob)
        if (this.paused) {
          if (!this._processQueue) {
            this._processQueue = []
            this.once("resume", function () {
              var q = this._processQueue
              this._processQueue = null
              q.forEach(function (cb) { cb() })
            })
          }
          this._processQueue.push(cb_.bind(this, er, res))
        } else {
          cb_.call(this, er, res)
        }
      }.bind(this)
    
      if (this.aborted) return cb()
    
      if (depth > this.maxDepth) return cb()
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === "string") {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          prefix = pattern.join("/")
          this._stat(prefix, function (exists, isDir) {
            // either it's there, or it isn't.
            // nothing more to do, either way.
            if (exists) {
              if (prefix && isAbsolute(prefix) && !this.nomount) {
                if (prefix.charAt(0) === "/") {
                  prefix = path.join(this.root, prefix)
                } else {
                  prefix = path.resolve(this.root, prefix)
                }
              }
    
              if (process.platform === "win32")
                prefix = prefix.replace(/\\/g, "/")
    
              this.matches[index] = this.matches[index] || {}
              this.matches[index][prefix] = true
              this.emitMatch(prefix)
            }
            return cb()
          })
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's "absolute" like /foo/bar,
          // or "relative" like "../baz"
          prefix = pattern.slice(0, n)
          prefix = prefix.join("/")
          break
      }
    
      // get the list of entries.
      var read
      if (prefix === null) read = "."
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix)) {
          prefix = "/" + prefix
        }
        read = prefix
    
        // if (process.platform === "win32")
        //   read = prefix = prefix.replace(/^[a-zA-Z]:|\\/g, "/")
    
        this.log('absolute: ', prefix, this.root, pattern, read)
      } else {
        read = prefix
      }
    
      this.log('readdir(%j)', read, this.cwd, this.root)
    
      return this._readdir(read, function (er, entries) {
        if (er) {
          // not a directory!
          // this means that, whatever else comes after this, it can never match
          return cb()
        }
    
        // globstar is special
        if (pattern[n] === minimatch.GLOBSTAR) {
          // test without the globstar, and with every child both below
          // and replacing the globstar.
          var s = [ pattern.slice(0, n).concat(pattern.slice(n + 1)) ]
          entries.forEach(function (e) {
            if (e.charAt(0) === "." && !this.dot) return
            // instead of the globstar
            s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1)))
            // below the globstar
            s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n)))
          }, this)
    
          s = s.filter(function (pattern) {
            var key = gsKey(pattern)
            var seen = !this._globstars[key]
            this._globstars[key] = true
            return seen
          }, this)
    
          if (!s.length)
            return cb()
    
          // now asyncForEach over this
          var l = s.length
          , errState = null
          s.forEach(function (gsPattern) {
            this._process(gsPattern, depth + 1, index, function (er) {
              if (errState) return
              if (er) return cb(errState = er)
              if (--l <= 0) return cb()
            })
          }, this)
    
          return
        }
    
        // not a globstar
        // It will only match dot entries if it starts with a dot, or if
        // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
        var pn = pattern[n]
        var negate = !!this.minimatch.negate;
        var rawGlob = pattern[n]._glob
        , dotOk = this.dot || rawGlob.charAt(0) === "."
    
        entries = entries.filter(function (e) {
          if (e.charAt(0) !== "." || dotOk) {
            if (negate && n === 0) {
              return !e.match(pattern[n]);
            } else {
              return e.match(pattern[n]);
            }
          }
    
          return null;
        })
    
        // If n === pattern.length - 1, then there's no need for the extra stat
        // *unless* the user has specified "mark" or "stat" explicitly.
        // We know that they exist, since the readdir returned them.
        if (n === pattern.length - 1 &&
            !this.mark &&
            !this.stat) {
          entries.forEach(function (e) {
            if (prefix) {
              if (prefix !== "/") e = prefix + "/" + e
              else e = prefix + e
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path.join(this.root, e)
            }
    
            if (process.platform === "win32")
              e = e.replace(/\\/g, "/")
    
            this.matches[index] = this.matches[index] || {}
            this.matches[index][e] = true
            this.emitMatch(e)
          }, this)
          return cb.call(this)
        }
    
    
        // now test all the remaining entries as stand-ins for that part
        // of the pattern.
        var l = entries.length
        , errState = null
        if (l === 0) return cb() // no matches possible
        entries.forEach(function (e) {
          var p = pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1))
          this._process(p, depth + 1, index, function (er) {
            if (errState) return
            if (er) return cb(errState = er)
            if (--l === 0) return cb.call(this)
          })
        }, this)
      })
    
    }
    
    function gsKey (pattern) {
      return '**' + pattern.map(function (p) {
        return (p === minimatch.GLOBSTAR) ? '**' : (''+p)
      }).join('/')
    }
    
    Glob.prototype._stat = function (f, cb) {
      assert(this instanceof Glob)
      var abs = f
      if (f.charAt(0) === "/") {
        abs = path.join(this.root, f)
      } else if (this.changedCwd) {
        abs = path.resolve(this.cwd, f)
      }
    
      if (f.length > this.maxLength) {
        var er = new Error("Path name too long")
        er.code = "ENAMETOOLONG"
        er.path = f
        return this._afterStat(f, abs, cb, er)
      }
    
      this.log('stat', [this.cwd, f, '=', abs])
    
      if (!this.stat && this.cache.hasOwnProperty(f)) {
        var exists = this.cache[f]
        , isDir = exists && (Array.isArray(exists) || exists === 2)
        if (this.sync) return cb.call(this, !!exists, isDir)
        return process.nextTick(cb.bind(this, !!exists, isDir))
      }
    
      var stat = this.statCache[abs]
      if (this.sync || stat) {
        var er
        try {
          stat = fs.statSync(abs)
        } catch (e) {
          er = e
        }
        this._afterStat(f, abs, cb, er, stat)
      } else {
        fs.stat(abs, this._afterStat.bind(this, f, abs, cb))
      }
    }
    
    Glob.prototype._afterStat = function (f, abs, cb, er, stat) {
      var exists
      assert(this instanceof Glob)
    
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory()) {
        this.log("should be ENOTDIR, fake it")
    
        er = new Error("ENOTDIR, not a directory '" + abs + "'")
        er.path = abs
        er.code = "ENOTDIR"
        stat = null
      }
    
      var emit = !this.statCache[abs]
      this.statCache[abs] = stat
    
      if (er || !stat) {
        exists = false
      } else {
        exists = stat.isDirectory() ? 2 : 1
        if (emit)
          this.emit('stat', f, stat)
      }
      this.cache[f] = this.cache[f] || exists
      cb.call(this, !!exists, exists === 2)
    }
    
    Glob.prototype._readdir = function (f, cb) {
      assert(this instanceof Glob)
      var abs = f
      if (f.charAt(0) === "/") {
        abs = path.join(this.root, f)
      } else if (isAbsolute(f)) {
        abs = f
      } else if (this.changedCwd) {
        abs = path.resolve(this.cwd, f)
      }
    
      if (f.length > this.maxLength) {
        var er = new Error("Path name too long")
        er.code = "ENAMETOOLONG"
        er.path = f
        return this._afterReaddir(f, abs, cb, er)
      }
    
      this.log('readdir', [this.cwd, f, abs])
      if (this.cache.hasOwnProperty(f)) {
        var c = this.cache[f]
        if (Array.isArray(c)) {
          if (this.sync) return cb.call(this, null, c)
          return process.nextTick(cb.bind(this, null, c))
        }
    
        if (!c || c === 1) {
          // either ENOENT or ENOTDIR
          var code = c ? "ENOTDIR" : "ENOENT"
          , er = new Error((c ? "Not a directory" : "Not found") + ": " + f)
          er.path = f
          er.code = code
          this.log(f, er)
          if (this.sync) return cb.call(this, er)
          return process.nextTick(cb.bind(this, er))
        }
    
        // at this point, c === 2, meaning it's a dir, but we haven't
        // had to read it yet, or c === true, meaning it's *something*
        // but we don't have any idea what.  Need to read it, either way.
      }
    
      if (this.sync) {
        var er, entries
        try {
          entries = fs.readdirSync(abs)
        } catch (e) {
          er = e
        }
        return this._afterReaddir(f, abs, cb, er, entries)
      }
    
      fs.readdir(abs, this._afterReaddir.bind(this, f, abs, cb))
    }
    
    Glob.prototype._afterReaddir = function (f, abs, cb, er, entries) {
      assert(this instanceof Glob)
      if (entries && !er) {
        this.cache[f] = entries
        // if we haven't asked to stat everything for suresies, then just
        // assume that everything in there exists, so we can avoid
        // having to stat it a second time.  This also gets us one step
        // further into ELOOP territory.
        if (!this.mark && !this.stat) {
          entries.forEach(function (e) {
            if (f === "/") e = f + e
            else e = f + "/" + e
            this.cache[e] = true
          }, this)
        }
    
        return cb.call(this, er, entries)
      }
    
      // now handle errors, and cache the information
      if (er) switch (er.code) {
        case "ENOTDIR": // totally normal. means it *does* exist.
          this.cache[f] = 1
          return cb.call(this, er)
        case "ENOENT": // not terribly unusual
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[f] = false
          return cb.call(this, er)
        default: // some unusual error.  Treat as failure.
          this.cache[f] = false
          if (this.strict) this.emit("error", er)
          if (!this.silent) console.error("glob error", er)
          return cb.call(this, er)
      }
    }
    
    var isAbsolute = process.platform === "win32" ? absWin : absUnix
    
    function absWin (p) {
      if (absUnix(p)) return true
      // pull off the device/UNC bit from a windows path.
      // from node's lib/path.js
      var splitDeviceRe =
          /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
        , result = splitDeviceRe.exec(p)
        , device = result[1] || ''
        , isUnc = device && device.charAt(1) !== ':'
        , isAbsolute = !!result[2] || isUnc // UNC paths are always absolute
    
      return isAbsolute
    }
    
    function absUnix (p) {
      return p.charAt(0) === "/" || p === ""
    }
    
  provide("glob", module.exports);
}(global));

// pakmanager:xml2js/processors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    (function() {
      var prefixMatch;
    
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    
      exports.normalize = function(str) {
        return str.toLowerCase();
      };
    
      exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
    
      exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, '');
      };
    
    }).call(this);
    
  provide("xml2js/processors", module.exports);
}(global));

// pakmanager:xml2js/xml2js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    (function() {
      var bom, builder, events, isEmpty, processName, processors, sax,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
    
      sax = require('sax');
    
      events = require('events');
    
      builder = require('xmlbuilder');
    
      bom =  require('xml2js/bom');
    
      processors =  require('xml2js/processors');
    
      isEmpty = function(thing) {
        return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
      };
    
      processName = function(processors, processedName) {
        var process, _i, _len;
        for (_i = 0, _len = processors.length; _i < _len; _i++) {
          process = processors[_i];
          processedName = process(processedName);
        }
        return processedName;
      };
    
      exports.processors = processors;
    
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: '@@',
          charsAsChildren: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          tagNameProcessors: null
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: '$$',
          charsAsChildren: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          tagNameProcessors: null,
          rootName: 'root',
          xmldec: {
            'version': '1.0',
            'encoding': 'UTF-8',
            'standalone': true
          },
          doctype: null,
          renderOpts: {
            'pretty': true,
            'indent': '  ',
            'newline': '\n'
          },
          headless: false
        }
      };
    
      exports.ValidationError = (function(_super) {
        __extends(ValidationError, _super);
    
        function ValidationError(message) {
          this.message = message;
        }
    
        return ValidationError;
    
      })(Error);
    
      exports.Builder = (function() {
        function Builder(opts) {
          var key, value, _ref;
          this.options = {};
          _ref = exports.defaults["0.2"];
          for (key in _ref) {
            if (!__hasProp.call(_ref, key)) continue;
            value = _ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!__hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
    
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = function(element, obj) {
            var attr, child, entry, index, key, value, _ref, _ref1;
            if (typeof obj !== 'object') {
              element.txt(obj);
            } else {
              for (key in obj) {
                if (!__hasProp.call(obj, key)) continue;
                child = obj[key];
                if (key === attrkey) {
                  if (typeof child === "object") {
                    for (attr in child) {
                      value = child[attr];
                      element = element.att(attr, value);
                    }
                  }
                } else if (key === charkey) {
                  element = element.txt(child);
                } else if (typeof child === 'object' && ((child != null ? child.constructor : void 0) != null) && ((child != null ? (_ref = child.constructor) != null ? _ref.name : void 0 : void 0) != null) && (child != null ? (_ref1 = child.constructor) != null ? _ref1.name : void 0 : void 0) === 'Array') {
                  for (index in child) {
                    if (!__hasProp.call(child, index)) continue;
                    entry = child[index];
                    if (typeof entry === 'string') {
                      element = element.ele(key, entry).up();
                    } else {
                      element = arguments.callee(element.ele(key), entry).up();
                    }
                  }
                } else if (typeof child === "object") {
                  element = arguments.callee(element.ele(key), child).up();
                } else {
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
            return element;
          };
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
    
        return Builder;
    
      })();
    
      exports.Parser = (function(_super) {
        __extends(Parser, _super);
    
        function Parser(opts) {
          this.parseString = __bind(this.parseString, this);
          this.reset = __bind(this.reset, this);
          this.assignOrPush = __bind(this.assignOrPush, this);
          var key, value, _ref;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          _ref = exports.defaults["0.2"];
          for (key in _ref) {
            if (!__hasProp.call(_ref, key)) continue;
            value = _ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!__hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
    
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
    
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = (function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          })(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = (function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, _ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                _ref = node.attributes;
                for (key in _ref) {
                  if (!__hasProp.call(_ref, key)) continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processName(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processName(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          })(this);
          this.saxParser.onclosetag = (function(_this) {
            return function() {
              var cdata, emptyStr, err, node, nodeName, obj, old, s, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              delete obj["#name"];
              cdata = obj.cdata;
              delete obj.cdata;
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== void 0 ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + ((function() {
                  var _i, _len, _results;
                  _results = [];
                  for (_i = 0, _len = stack.length; _i < _len; _i++) {
                    node = stack[_i];
                    _results.push(node["#name"]);
                  }
                  return _results;
                })()).concat(nodeName).join("/");
                try {
                  obj = _this.options.validator(xpath, s && s[nodeName], obj);
                } catch (_error) {
                  err = _error;
                  _this.emit("error", err);
                }
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                node = {};
                if (_this.options.attrkey in obj) {
                  node[_this.options.attrkey] = obj[_this.options.attrkey];
                  delete obj[_this.options.attrkey];
                }
                if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                  node[_this.options.charkey] = obj[_this.options.charkey];
                  delete obj[_this.options.charkey];
                }
                if (Object.getOwnPropertyNames(obj).length > 0) {
                  node[_this.options.childkey] = obj;
                }
                obj = node;
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          })(this);
          ontext = (function(_this) {
            return function(text) {
              var s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                return s;
              }
            };
          })(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = (function(_this) {
            return function(text) {
              var s;
              s = ontext(text);
              if (s) {
                return s.cdata = true;
              }
            };
          })(this);
        };
    
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if ((cb != null) && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              if (this.options.async) {
                return process.nextTick(function() {
                  return cb(null, result);
                });
              } else {
                return cb(null, result);
              }
            });
            this.on("error", function(err) {
              this.reset();
              if (this.options.async) {
                return process.nextTick(function() {
                  return cb(err);
                });
              } else {
                return cb(err);
              }
            });
          }
          if (str.toString().trim() === '') {
            this.emit("end", null);
            return true;
          }
          try {
            return this.saxParser.write(bom.stripBOM(str.toString())).close();
          } catch (_error) {
            err = _error;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit('error', err);
              return this.saxParser.errThrown = true;
            }
          }
        };
    
        return Parser;
    
      })(events.EventEmitter);
    
      exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === 'function') {
            cb = b;
          }
          if (typeof a === 'object') {
            options = a;
          }
        } else {
          if (typeof a === 'function') {
            cb = a;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
    
    }).call(this);
    
  provide("xml2js/xml2js", module.exports);
}(global));

// pakmanager:xml2js/bom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    (function() {
      var xml2js;
    
      xml2js =  require('xml2js/xml2js');
    
      exports.stripBOM = function(str) {
        if (str[0] === '\uFEFF') {
          return str.substring(1);
        } else {
          return str;
        }
      };
    
    }).call(this);
    
  provide("xml2js/bom", module.exports);
}(global));

// pakmanager:xml2js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Generated by CoffeeScript 1.7.1
    (function() {
      var bom, builder, events, isEmpty, processName, processors, sax,
        __hasProp = {}.hasOwnProperty,
        __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
        __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
    
      sax = require('sax');
    
      events = require('events');
    
      builder = require('xmlbuilder');
    
      bom =  require('xml2js/bom');
    
      processors =  require('xml2js/processors');
    
      isEmpty = function(thing) {
        return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
      };
    
      processName = function(processors, processedName) {
        var process, _i, _len;
        for (_i = 0, _len = processors.length; _i < _len; _i++) {
          process = processors[_i];
          processedName = process(processedName);
        }
        return processedName;
      };
    
      exports.processors = processors;
    
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: '@@',
          charsAsChildren: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          tagNameProcessors: null
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: '$$',
          charsAsChildren: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          tagNameProcessors: null,
          rootName: 'root',
          xmldec: {
            'version': '1.0',
            'encoding': 'UTF-8',
            'standalone': true
          },
          doctype: null,
          renderOpts: {
            'pretty': true,
            'indent': '  ',
            'newline': '\n'
          },
          headless: false
        }
      };
    
      exports.ValidationError = (function(_super) {
        __extends(ValidationError, _super);
    
        function ValidationError(message) {
          this.message = message;
        }
    
        return ValidationError;
    
      })(Error);
    
      exports.Builder = (function() {
        function Builder(opts) {
          var key, value, _ref;
          this.options = {};
          _ref = exports.defaults["0.2"];
          for (key in _ref) {
            if (!__hasProp.call(_ref, key)) continue;
            value = _ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!__hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
    
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = function(element, obj) {
            var attr, child, entry, index, key, value, _ref, _ref1;
            if (typeof obj !== 'object') {
              element.txt(obj);
            } else {
              for (key in obj) {
                if (!__hasProp.call(obj, key)) continue;
                child = obj[key];
                if (key === attrkey) {
                  if (typeof child === "object") {
                    for (attr in child) {
                      value = child[attr];
                      element = element.att(attr, value);
                    }
                  }
                } else if (key === charkey) {
                  element = element.txt(child);
                } else if (typeof child === 'object' && ((child != null ? child.constructor : void 0) != null) && ((child != null ? (_ref = child.constructor) != null ? _ref.name : void 0 : void 0) != null) && (child != null ? (_ref1 = child.constructor) != null ? _ref1.name : void 0 : void 0) === 'Array') {
                  for (index in child) {
                    if (!__hasProp.call(child, index)) continue;
                    entry = child[index];
                    if (typeof entry === 'string') {
                      element = element.ele(key, entry).up();
                    } else {
                      element = arguments.callee(element.ele(key), entry).up();
                    }
                  }
                } else if (typeof child === "object") {
                  element = arguments.callee(element.ele(key), child).up();
                } else {
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
            return element;
          };
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
    
        return Builder;
    
      })();
    
      exports.Parser = (function(_super) {
        __extends(Parser, _super);
    
        function Parser(opts) {
          this.parseString = __bind(this.parseString, this);
          this.reset = __bind(this.reset, this);
          this.assignOrPush = __bind(this.assignOrPush, this);
          var key, value, _ref;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          _ref = exports.defaults["0.2"];
          for (key in _ref) {
            if (!__hasProp.call(_ref, key)) continue;
            value = _ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!__hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
    
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
    
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = (function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          })(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = (function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, _ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                _ref = node.attributes;
                for (key in _ref) {
                  if (!__hasProp.call(_ref, key)) continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processName(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processName(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          })(this);
          this.saxParser.onclosetag = (function(_this) {
            return function() {
              var cdata, emptyStr, err, node, nodeName, obj, old, s, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              delete obj["#name"];
              cdata = obj.cdata;
              delete obj.cdata;
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== void 0 ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + ((function() {
                  var _i, _len, _results;
                  _results = [];
                  for (_i = 0, _len = stack.length; _i < _len; _i++) {
                    node = stack[_i];
                    _results.push(node["#name"]);
                  }
                  return _results;
                })()).concat(nodeName).join("/");
                try {
                  obj = _this.options.validator(xpath, s && s[nodeName], obj);
                } catch (_error) {
                  err = _error;
                  _this.emit("error", err);
                }
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                node = {};
                if (_this.options.attrkey in obj) {
                  node[_this.options.attrkey] = obj[_this.options.attrkey];
                  delete obj[_this.options.attrkey];
                }
                if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                  node[_this.options.charkey] = obj[_this.options.charkey];
                  delete obj[_this.options.charkey];
                }
                if (Object.getOwnPropertyNames(obj).length > 0) {
                  node[_this.options.childkey] = obj;
                }
                obj = node;
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          })(this);
          ontext = (function(_this) {
            return function(text) {
              var s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                return s;
              }
            };
          })(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = (function(_this) {
            return function(text) {
              var s;
              s = ontext(text);
              if (s) {
                return s.cdata = true;
              }
            };
          })(this);
        };
    
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if ((cb != null) && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              if (this.options.async) {
                return process.nextTick(function() {
                  return cb(null, result);
                });
              } else {
                return cb(null, result);
              }
            });
            this.on("error", function(err) {
              this.reset();
              if (this.options.async) {
                return process.nextTick(function() {
                  return cb(err);
                });
              } else {
                return cb(err);
              }
            });
          }
          if (str.toString().trim() === '') {
            this.emit("end", null);
            return true;
          }
          try {
            return this.saxParser.write(bom.stripBOM(str.toString())).close();
          } catch (_error) {
            err = _error;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit('error', err);
              return this.saxParser.errThrown = true;
            }
          }
        };
    
        return Parser;
    
      })(events.EventEmitter);
    
      exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === 'function') {
            cb = b;
          }
          if (typeof a === 'object') {
            options = a;
          }
        } else {
          if (typeof a === 'function') {
            cb = a;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
    
    }).call(this);
    
  provide("xml2js", module.exports);
}(global));

// pakmanager:yaml
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // YAML - Core - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)
    
    /**
     * Version triplet.
     */
    
    exports.version = '0.2.3'
    
    // --- Helpers
    
    /**
     * Return 'near "context"' where context
     * is replaced by a chunk of _str_.
     *
     * @param  {string} str
     * @return {string}
     * @api public
     */
    
    function context(str) {
      if (typeof str !== 'string') return ''
      str = str
        .slice(0, 25)
        .replace(/\n/g, '\\n')
        .replace(/"/g, '\\\"')
      return 'near "' + str + '"'
    }
    
    // --- Lexer
    
    /**
     * YAML grammar tokens.
     */
    
    var tokens = [
      ['comment', /^#[^\n]*/],
      ['indent', /^\n( *)/],
      ['space', /^ +/],
      ['true', /^\b(enabled|true|yes|on)\b/],
      ['false', /^\b(disabled|false|no|off)\b/],
      ['null', /^\b(null|Null|NULL|~)\b/],
      ['string', /^"(.*?)"/],
      ['string', /^'(.*?)'/],
      ['timestamp', /^((\d{4})-(\d\d?)-(\d\d?)(?:(?:[ \t]+)(\d\d?):(\d\d)(?::(\d\d))?)?)/],
      ['float', /^(\d+\.\d+)/],
      ['int', /^(\d+)/],
      ['doc', /^---/],
      [',', /^,/],
      ['{', /^\{(?![^\n\}]*\}[^\n]*[^\s\n\}])/],
      ['}', /^\}/],
      ['[', /^\[(?![^\n\]]*\][^\n]*[^\s\n\]])/],
      [']', /^\]/],
      ['-', /^\-/],
      [':', /^[:]/],
      ['string', /^(?![^:\n\s]*:[^\/]{2})(([^:,\]\}\n\s]|(?!\n)\s(?!\s*?\n)|:\/\/|,(?=[^\n]*\s*[^\]\}\s\n]\s*\n)|[\]\}](?=[^\n]*\s*[^\]\}\s\n]\s*\n))*)(?=[,:\]\}\s\n]|$)/], 
      ['id', /^([\w][\w -]*)/]
    ]
    
    /**
     * Tokenize the given _str_.
     *
     * @param  {string} str
     * @return {array}
     * @api private
     */
    
    exports.tokenize = function (str) {
      var token, captures, ignore, input,
          indents = 0, lastIndents = 0,
          stack = [], indentAmount = -1
      while (str.length) {
        for (var i = 0, len = tokens.length; i < len; ++i)
          if (captures = tokens[i][1].exec(str)) {
            token = [tokens[i][0], captures],
            str = str.replace(tokens[i][1], '')
            switch (token[0]) {
              case 'comment':
                ignore = true
                break
              case 'indent':
                lastIndents = indents 
                // determine the indentation amount from the first indent
                if (indentAmount == -1) {
                  indentAmount = token[1][1].length
                }
    
                indents = token[1][1].length / indentAmount
                if (indents === lastIndents)
                  ignore = true
                else if (indents > lastIndents + 1)
                  throw new SyntaxError('invalid indentation, got ' + indents + ' instead of ' + (lastIndents + 1))
                else if (indents < lastIndents) {
                  input = token[1].input
                  token = ['dedent']
                  token.input = input
                  while (--lastIndents > indents)
                    stack.push(token)
                }
            }
            break
          }
        if (!ignore)
          if (token)
            stack.push(token),
            token = null
          else 
            throw new SyntaxError(context(str))
        ignore = false
      }
      return stack
    }
    
    // --- Parser
    
    /**
     * Initialize with _tokens_.
     */
    
    function Parser(tokens) {
      this.tokens = tokens
    }
    
    /**
     * Look-ahead a single token.
     *
     * @return {array}
     * @api public
     */
    
    Parser.prototype.peek = function() {
      return this.tokens[0]
    }
    
    /**
     * Advance by a single token.
     *
     * @return {array}
     * @api public
     */
    
    Parser.prototype.advance = function() {
      return this.tokens.shift()
    }
    
    /**
     * Advance and return the token's value.
     *
     * @return {mixed}
     * @api private
     */
    
    Parser.prototype.advanceValue = function() {
      return this.advance()[1][1]
    }
    
    /**
     * Accept _type_ and advance or do nothing.
     *
     * @param  {string} type
     * @return {bool}
     * @api private
     */
    
    Parser.prototype.accept = function(type) {
      if (this.peekType(type))
        return this.advance()
    }
    
    /**
     * Expect _type_ or throw an error _msg_.
     *
     * @param  {string} type
     * @param  {string} msg
     * @api private
     */
    
    Parser.prototype.expect = function(type, msg) {
      if (this.accept(type)) return
      throw new Error(msg + ', ' + context(this.peek()[1].input))
    }
    
    /**
     * Return the next token type.
     *
     * @return {string}
     * @api private
     */
    
    Parser.prototype.peekType = function(val) {
      return this.tokens[0] &&
             this.tokens[0][0] === val
    }
    
    /**
     * space*
     */
    
    Parser.prototype.ignoreSpace = function() {
      while (this.peekType('space'))
        this.advance()
    }
    
    /**
     * (space | indent | dedent)*
     */
    
    Parser.prototype.ignoreWhitespace = function() {
      while (this.peekType('space') ||
             this.peekType('indent') ||
             this.peekType('dedent'))
        this.advance()
    }
    
    /**
     *   block
     * | doc
     * | list
     * | inlineList
     * | hash
     * | inlineHash
     * | string
     * | float
     * | int
     * | true
     * | false
     * | null
     */
    
    Parser.prototype.parse = function() {
      switch (this.peek()[0]) {
        case 'doc':
          return this.parseDoc()
        case '-':
          return this.parseList()
        case '{':
          return this.parseInlineHash()
        case '[':
          return this.parseInlineList()
        case 'id':
          return this.parseHash()
        case 'string':
          return this.advanceValue()
        case 'timestamp':
          return this.parseTimestamp()
        case 'float':
          return parseFloat(this.advanceValue())
        case 'int':
          return parseInt(this.advanceValue())
        case 'true':
          this.advanceValue(); return true
        case 'false':
          this.advanceValue(); return false
        case 'null':
          this.advanceValue(); return null
      }
    }
    
    /**
     * '---'? indent expr dedent
     */
    
    Parser.prototype.parseDoc = function() {
      this.accept('doc')
      this.expect('indent', 'expected indent after document')
      var val = this.parse()
      this.expect('dedent', 'document not properly dedented')
      return val
    }
    
    /**
     *  ( id ':' - expr -
     *  | id ':' - indent expr dedent
     *  )+
     */
    
    Parser.prototype.parseHash = function() {
      var id, hash = {}
      while (this.peekType('id') && (id = this.advanceValue())) {
        this.expect(':', 'expected semi-colon after id')
        this.ignoreSpace()
        if (this.accept('indent'))
          hash[id] = this.parse(),
          this.expect('dedent', 'hash not properly dedented')
        else
          hash[id] = this.parse()
        this.ignoreSpace()
      }
      return hash
    }
    
    /**
     * '{' (- ','? ws id ':' - expr ws)* '}'
     */
    
    Parser.prototype.parseInlineHash = function() {
      var hash = {}, id, i = 0
      this.accept('{')
      while (!this.accept('}')) {
        this.ignoreSpace()
        if (i) this.expect(',', 'expected comma')
        this.ignoreWhitespace()
        if (this.peekType('id') && (id = this.advanceValue())) {
          this.expect(':', 'expected semi-colon after id')
          this.ignoreSpace()
          hash[id] = this.parse()
          this.ignoreWhitespace()
        }
        ++i
      }
      return hash
    }
    
    /**
     *  ( '-' - expr -
     *  | '-' - indent expr dedent
     *  )+
     */
    
    Parser.prototype.parseList = function() {
      var list = []
      while (this.accept('-')) {
        this.ignoreSpace()
        if (this.accept('indent'))
          list.push(this.parse()),
          this.expect('dedent', 'list item not properly dedented')
        else
          list.push(this.parse())
        this.ignoreSpace()
      }
      return list
    }
    
    /**
     * '[' (- ','? - expr -)* ']'
     */
    
    Parser.prototype.parseInlineList = function() {
      var list = [], i = 0
      this.accept('[')
      while (!this.accept(']')) {
        this.ignoreSpace()
        if (i) this.expect(',', 'expected comma')
        this.ignoreSpace()
        list.push(this.parse())
        this.ignoreSpace()
        ++i
      }
      return list
    }
    
    /**
     * yyyy-mm-dd hh:mm:ss
     *
     * For full format: http://yaml.org/type/timestamp.html
     */
    
    Parser.prototype.parseTimestamp = function() {
      var token = this.advance()[1]
      var date = new Date
      var year = token[2]
        , month = token[3]
        , day = token[4]
        , hour = token[5] || 0 
        , min = token[6] || 0
        , sec = token[7] || 0
    
      date.setUTCFullYear(year, month-1, day)
      date.setUTCHours(hour)
      date.setUTCMinutes(min)
      date.setUTCSeconds(sec)
      date.setUTCMilliseconds(0)
      return date
    }
    
    /**
     * Evaluate a _str_ of yaml.
     *
     * @param  {string} str
     * @return {mixed}
     * @api public
     */
    
    exports.eval = function(str) {
      return (new Parser(exports.tokenize(str))).parse()
    }
    
  provide("yaml", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/internal
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Export Node.js internal encodings.
    
    var utf16lebom = new Buffer([0xFF, 0xFE]);
    
    module.exports = {
        // Encodings
        utf8:   { type: "_internal", enc: "utf8" },
        cesu8:  { type: "_internal", enc: "utf8" },
        unicode11utf8: { type: "_internal", enc: "utf8" },
        ucs2:   { type: "_internal", enc: "ucs2", bom: utf16lebom },
        utf16le:{ type: "_internal", enc: "ucs2", bom: utf16lebom },
        binary: { type: "_internal", enc: "binary" },
        base64: { type: "_internal", enc: "base64" },
        hex:    { type: "_internal", enc: "hex" },
    
        // Codec.
        _internal: function(options) {
            if (!options || !options.enc)
                throw new Error("Internal codec is called without encoding type.")
    
            return {
                encoder: options.enc == "base64" ? encoderBase64 : encoderInternal,
                decoder: decoderInternal,
    
                enc: options.enc,
                bom: options.bom,
            };
        },
    };
    
    // We use node.js internal decoder. It's signature is the same as ours.
    var StringDecoder = require('string_decoder').StringDecoder;
    
    if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
        StringDecoder.prototype.end = function() {};
    
    function decoderInternal() {
        return new StringDecoder(this.enc);
    }
    
    // Encoder is mostly trivial
    
    function encoderInternal() {
        return {
            write: encodeInternal,
            end: function() {},
            
            enc: this.enc,
        }
    }
    
    function encodeInternal(str) {
        return new Buffer(str, this.enc);
    }
    
    
    // Except base64 encoder, which must keep its state.
    
    function encoderBase64() {
        return {
            write: encodeBase64Write,
            end: encodeBase64End,
    
            prevStr: '',
        };
    }
    
    function encodeBase64Write(str) {
        str = this.prevStr + str;
        var completeQuads = str.length - (str.length % 4);
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);
    
        return new Buffer(str, "base64");
    }
    
    function encodeBase64End() {
        return new Buffer(this.prevStr, "base64");
    }
    
    
  provide("iconv-lite/encodings/internal", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/utf16
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    
    // == UTF16-BE codec. ==========================================================
    
    exports.utf16be = function(options) {
        return {
            encoder: utf16beEncoder,
            decoder: utf16beDecoder,
    
            bom: new Buffer([0xFE, 0xFF]),
        };
    };
    
    
    // -- Encoding
    
    function utf16beEncoder(options) {
        return {
            write: utf16beEncoderWrite,
            end: function() {},
        }
    }
    
    function utf16beEncoderWrite(str) {
        var buf = new Buffer(str, 'ucs2');
        for (var i = 0; i < buf.length; i += 2) {
            var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
        }
        return buf;
    }
    
    
    // -- Decoding
    
    function utf16beDecoder(options) {
        return {
            write: utf16beDecoderWrite,
            end: function() {},
    
            overflowByte: -1,
        };
    }
    
    function utf16beDecoderWrite(buf) {
        if (buf.length == 0)
            return '';
    
        var buf2 = new Buffer(buf.length + 1),
            i = 0, j = 0;
    
        if (this.overflowByte !== -1) {
            buf2[0] = buf[0];
            buf2[1] = this.overflowByte;
            i = 1; j = 2;
        }
    
        for (; i < buf.length-1; i += 2, j+= 2) {
            buf2[j] = buf[i+1];
            buf2[j+1] = buf[i];
        }
    
        this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;
    
        return buf2.slice(0, j).toString('ucs2');
    }
    
    
    // == UTF-16 codec =============================================================
    // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
    // Defaults to UTF-16BE, according to RFC 2781, although it is against some industry practices, see
    // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
    // Decoder default can be changed: iconv.decode(buf, 'utf16', {default: 'utf-16le'});
    
    // Encoder prepends BOM and uses UTF-16BE.
    // Endianness can also be changed: iconv.encode(str, 'utf16', {use: 'utf-16le'});
    
    exports.utf16 = function(options) {
        return {
            encoder: utf16Encoder,
            decoder: utf16Decoder,
    
            getCodec: options.iconv.getCodec,
        };
    };
    
    // -- Encoding
    
    function utf16Encoder(options) {
        options = options || {};
        var codec = this.getCodec(options.use || 'utf-16be');
        if (!codec.bom)
            throw new Error("iconv-lite: in UTF-16 encoder, 'use' parameter should be either UTF-16BE or UTF16-LE.");
    
        return {
            write: utf16EncoderWrite,
            end: utf16EncoderEnd,
    
            bom: codec.bom,
            internalEncoder: codec.encoder(options),
        };
    }
    
    function utf16EncoderWrite(str) {
        var buf = this.internalEncoder.write(str);
    
        if (this.bom) {
            buf = Buffer.concat([this.bom, buf]);
            this.bom = null;
        }
    
        return buf;
    }
    
    function utf16EncoderEnd() {
        return this.internalEncoder.end();
    }
    
    
    // -- Decoding
    
    function utf16Decoder(options) {
        return {
            write: utf16DecoderWrite,
            end: utf16DecoderEnd,
    
            internalDecoder: null,
            initialBytes: [],
            initialBytesLen: 0,
    
            options: options || {},
            getCodec: this.getCodec,
        };
    }
    
    function utf16DecoderWrite(buf) {
        if (this.internalDecoder)
            return this.internalDecoder.write(buf);
    
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need > 2 bytes to use space heuristic (see below)
            return '';
    
        // We have enough bytes -> decide endianness.
        return utf16DecoderDecideEndianness.call(this);
    }
    
    function utf16DecoderEnd() {
        if (this.internalDecoder)
            return this.internalDecoder.end();
    
        var res = utf16DecoderDecideEndianness.call(this);
        var trail;
    
        if (this.internalDecoder)
            trail = this.internalDecoder.end();
    
        return (trail && trail.length > 0) ? (res + trail) : res;
    }
    
    function utf16DecoderDecideEndianness() {
        var buf = Buffer.concat(this.initialBytes);
        this.initialBytes.length = this.initialBytesLen = 0;
    
        if (buf.length < 2)
            return ''; // Not a valid UTF-16 sequence anyway.
    
        // Default encoding.
        var enc = this.options.default || 'utf-16be';
    
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) { // UTF-16BE BOM
            enc = 'utf-16be'; buf = buf.slice(2);
        }
        else if (buf[0] == 0xFF && buf[1] == 0xFE) { // UTF-16LE BOM
            enc = 'utf-16le'; buf = buf.slice(2);
        }
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has spaces (U+0020), but the opposite (U+2000) is very uncommon.
            // So, we count spaces as if it was LE or BE, and decide from that.
            var spaces = [0, 0], // Counts of space chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.
    
            for (var i = 0; i < _len; i += 2) {
                if (buf[i] == 0x00 && buf[i+1] == 0x20) spaces[0]++;
                if (buf[i] == 0x20 && buf[i+1] == 0x00) spaces[1]++;
            }
    
            if (spaces[0] > 0 && spaces[1] == 0)  
                enc = 'utf-16be';
            else if (spaces[0] == 0 && spaces[1] > 0)
                enc = 'utf-16le';
        }
    
        this.internalDecoder = this.getCodec(enc).decoder(this.options);
        return this.internalDecoder.write(buf);
    }
    
    
    
  provide("iconv-lite/encodings/utf16", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/utf7
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
    // Below is UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3
    
    exports.utf7 = function(options) {
        return {
            encoder: function utf7Encoder() {
                return {
                    write: utf7EncoderWrite,
                    end: function() {},
    
                    iconv: options.iconv,
                };
            },
            decoder: function utf7Decoder() {
                return {
                    write: utf7DecoderWrite,
                    end: utf7DecoderEnd,
    
                    iconv: options.iconv,
                    inBase64: false,
                    base64Accum: '',
                };
            },
        };
    };
    
    
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    
    function utf7EncoderWrite(str) {
        // Naive implementation.
        // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
        return new Buffer(str.replace(nonDirectChars, function(chunk) {
            return "+" + (chunk === '+' ? '' : 
                this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
                + "-";
        }.bind(this)));
    }
    
    
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (var i = 0; i < 256; i++)
        base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    
    var plusChar = '+'.charCodeAt(0), 
        minusChar = '-'.charCodeAt(0),
        andChar = '&'.charCodeAt(0);
    
    function utf7DecoderWrite(buf) {
        var res = "", lastI = 0,
            inBase64 = this.inBase64,
            base64Accum = this.base64Accum;
    
        // The decoder is more involved as we must handle chunks in stream.
    
        for (var i = 0; i < buf.length; i++) {
            if (!inBase64) { // We're in direct mode.
                // Write direct chars until '+'
                if (buf[i] == plusChar) {
                    res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                    lastI = i+1;
                    inBase64 = true;
                }
            } else { // We decode base64.
                if (!base64Chars[buf[i]]) { // Base64 ended.
                    if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                        res += "+";
                    } else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString();
                        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
                    }
    
                    if (buf[i] != minusChar) // Minus is absorbed after base64.
                        i--;
    
                    lastI = i+1;
                    inBase64 = false;
                    base64Accum = '';
                }
            }
        }
    
        if (!inBase64) {
            res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
            var b64str = base64Accum + buf.slice(lastI).toString();
    
            var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
            base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
            b64str = b64str.slice(0, canBeDecoded);
    
            res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
        }
    
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
    
        return res;
    }
    
    function utf7DecoderEnd() {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
            res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
    
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
    }
    
    
    // UTF-7-IMAP codec.
    // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
    // Differences:
    //  * Base64 part is started by "&" instead of "+"
    //  * Direct characters are 0x20-0x7E, except "&" (0x26)
    //  * In Base64, "," is used instead of "/"
    //  * Base64 must not be used to represent direct characters.
    //  * No implicit shift back from Base64 (should always end with '-')
    //  * String must end in non-shifted position.
    //  * "-&" while in base64 is not allowed.
    
    
    exports.utf7imap = function(options) {
        return {
            encoder: function utf7ImapEncoder() {
                return {
                    write: utf7ImapEncoderWrite,
                    end: utf7ImapEncoderEnd,
    
                    iconv: options.iconv,
                    inBase64: false,
                    base64Accum: new Buffer(6),
                    base64AccumIdx: 0,
                };
            },
            decoder: function utf7ImapDecoder() {
                return {
                    write: utf7ImapDecoderWrite,
                    end: utf7ImapDecoderEnd,
    
                    iconv: options.iconv,
                    inBase64: false,
                    base64Accum: '',
                };
            },
        };
    };
    
    
    function utf7ImapEncoderWrite(str) {
        var inBase64 = this.inBase64,
            base64Accum = this.base64Accum,
            base64AccumIdx = this.base64AccumIdx,
            buf = new Buffer(str.length*5 + 10), bufIdx = 0;
    
        for (var i = 0; i < str.length; i++) {
            var uChar = str.charCodeAt(i);
            if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
                if (inBase64) {
                    if (base64AccumIdx > 0) {
                        bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                        base64AccumIdx = 0;
                    }
    
                    buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                    inBase64 = false;
                }
    
                if (!inBase64) {
                    buf[bufIdx++] = uChar; // Write direct character
    
                    if (uChar === andChar)  // Ampersand -> '&-'
                        buf[bufIdx++] = minusChar;
                }
    
            } else { // Non-direct character
                if (!inBase64) {
                    buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                    inBase64 = true;
                }
                if (inBase64) {
                    base64Accum[base64AccumIdx++] = uChar >> 8;
                    base64Accum[base64AccumIdx++] = uChar & 0xFF;
    
                    if (base64AccumIdx == base64Accum.length) {
                        bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                        base64AccumIdx = 0;
                    }
                }
            }
        }
    
        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;
    
        return buf.slice(0, bufIdx);
    }
    
    function utf7ImapEncoderEnd() {
        var buf = new Buffer(10), bufIdx = 0;
        if (this.inBase64) {
            if (this.base64AccumIdx > 0) {
                bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                this.base64AccumIdx = 0;
            }
    
            buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
            this.inBase64 = false;
        }
    
        return buf.slice(0, bufIdx);
    }
    
    
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[','.charCodeAt(0)] = true;
    
    function utf7ImapDecoderWrite(buf) {
        var res = "", lastI = 0,
            inBase64 = this.inBase64,
            base64Accum = this.base64Accum;
    
        // The decoder is more involved as we must handle chunks in stream.
        // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).
    
        for (var i = 0; i < buf.length; i++) {
            if (!inBase64) { // We're in direct mode.
                // Write direct chars until '&'
                if (buf[i] == andChar) {
                    res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                    lastI = i+1;
                    inBase64 = true;
                }
            } else { // We decode base64.
                if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                    if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                        res += "&";
                    } else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
                    }
    
                    if (buf[i] != minusChar) // Minus may be absorbed after base64.
                        i--;
    
                    lastI = i+1;
                    inBase64 = false;
                    base64Accum = '';
                }
            }
        }
    
        if (!inBase64) {
            res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
            var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
    
            var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
            base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
            b64str = b64str.slice(0, canBeDecoded);
    
            res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
        }
    
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
    
        return res;
    }
    
    function utf7ImapDecoderEnd() {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
            res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
    
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
    }
    
    
    
  provide("iconv-lite/encodings/utf7", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/sbcs-codec
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
    // correspond to encoded bytes (if 128 - then lower half is ASCII). 
    
    exports._sbcs = function(options) {
        if (!options)
            throw new Error("SBCS codec is called without the data.")
        
        // Prepare char buffer for decoding.
        if (!options.chars || (options.chars.length !== 128 && options.chars.length !== 256))
            throw new Error("Encoding '"+options.type+"' has incorrect 'chars' (must be of len 128 or 256)");
        
        if (options.chars.length === 128) {
            var asciiString = "";
            for (var i = 0; i < 128; i++)
                asciiString += String.fromCharCode(i);
            options.chars = asciiString + options.chars;
        }
    
        var decodeBuf = new Buffer(options.chars, 'ucs2');
        
        // Encoding buffer.
        var encodeBuf = new Buffer(65536);
        encodeBuf.fill(options.iconv.defaultCharSingleByte.charCodeAt(0));
    
        for (var i = 0; i < options.chars.length; i++)
            encodeBuf[options.chars.charCodeAt(i)] = i;
    
        return {
            encoder: encoderSBCS,
            decoder: decoderSBCS,
    
            encodeBuf: encodeBuf,
            decodeBuf: decodeBuf,
        };
    }
    
    function encoderSBCS(options) {
        return {
            write: encoderSBCSWrite,
            end: function() {},
    
            encodeBuf: this.encodeBuf,
        };
    }
    
    function encoderSBCSWrite(str) {
        var buf = new Buffer(str.length);
        for (var i = 0; i < str.length; i++)
            buf[i] = this.encodeBuf[str.charCodeAt(i)];
        
        return buf;
    }
    
    
    function decoderSBCS(options) {
        return {
            write: decoderSBCSWrite,
            end: function() {},
            
            decodeBuf: this.decodeBuf,
        };
    }
    
    function decoderSBCSWrite(buf) {
        // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
        var decodeBuf = this.decodeBuf;
        var newBuf = new Buffer(buf.length*2);
        var idx1 = 0, idx2 = 0;
        for (var i = 0, _len = buf.length; i < _len; i++) {
            idx1 = buf[i]*2; idx2 = i*2;
            newBuf[idx2] = decodeBuf[idx1];
            newBuf[idx2+1] = decodeBuf[idx1+1];
        }
        return newBuf.toString('ucs2');
    }
    
  provide("iconv-lite/encodings/sbcs-codec", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/sbcs-data
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Manually added data to be used by sbcs codec in addition to generated one.
    
    module.exports = {
        // Not supported by iconv, not sure why.
        "10029": "maccenteuro",
        "maccenteuro": {
            "type": "_sbcs",
            "chars": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
        },
    
        "808": "cp808",
        "ibm808": "cp808",
        "cp808": {
            "type": "_sbcs",
            "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ "
        },
    
        // Aliases of generated encodings.
        "ascii8bit": "ascii",
        "usascii": "ascii",
        "ansix3.4": "ascii",
        "ansix3.41968": "ascii",
        "ansix3.41986": "ascii",
        "csascii": "ascii",
        "cp367": "ascii",
        "ibm367": "ascii",
        "isoir6": "ascii",
        "iso646us": "ascii",
        "iso646.irv": "ascii",
        "us": "ascii",
    
        "latin1": "iso88591",
        "latin2": "iso88592",
        "latin3": "iso88593",
        "latin4": "iso88594",
        "latin5": "iso88599",
        "latin6": "iso885910",
        "latin7": "iso885913",
        "latin8": "iso885914",
        "latin9": "iso885915",
        "latin10": "iso885916",
    
        "csisolatin1": "iso88591",
        "csisolatin2": "iso88592",
        "csisolatin3": "iso88593",
        "csisolatin4": "iso88594",
        "csisolatincyrillic": "iso88595",
        "csisolatinarabic": "iso88596",
        "csisolatingreek" : "iso88597",
        "csisolatinhebrew": "iso88598",
        "csisolatin5": "iso88599",
        "csisolatin6": "iso885910",
    
        "l1": "iso88591",
        "l2": "iso88592",
        "l3": "iso88593",
        "l4": "iso88594",
        "l5": "iso88599",
        "l6": "iso885910",
        "l7": "iso885913",
        "l8": "iso885914",
        "l9": "iso885915",
        "l10": "iso885916",
    
        "isoir14": "iso646jp",
        "isoir57": "iso646cn",
        "isoir100": "iso88591",
        "isoir101": "iso88592",
        "isoir109": "iso88593",
        "isoir110": "iso88594",
        "isoir144": "iso88595",
        "isoir127": "iso88596",
        "isoir126": "iso88597",
        "isoir138": "iso88598",
        "isoir148": "iso88599",
        "isoir157": "iso885910",
        "isoir166": "tis620",
        "isoir179": "iso885913",
        "isoir199": "iso885914",
        "isoir203": "iso885915",
        "isoir226": "iso885916",
    
        "cp819": "iso88591",
        "ibm819": "iso88591",
    
        "cyrillic": "iso88595",
    
        "arabic": "iso88596",
        "arabic8": "iso88596",
        "ecma114": "iso88596",
        "asmo708": "iso88596",
    
        "greek" : "iso88597",
        "greek8" : "iso88597",
        "ecma118" : "iso88597",
        "elot928" : "iso88597",
    
        "hebrew": "iso88598",
        "hebrew8": "iso88598",
    
        "turkish": "iso88599",
        "turkish8": "iso88599",
    
        "thai": "iso885911",
        "thai8": "iso885911",
    
        "celtic": "iso885914",
        "celtic8": "iso885914",
        "isoceltic": "iso885914",
    
        "tis6200": "tis620",
        "tis620.25291": "tis620",
        "tis620.25330": "tis620",
    
        "10000": "macroman",
        "10006": "macgreek",
        "10007": "maccyrillic",
        "10079": "maciceland",
        "10081": "macturkish",
    
        "cspc8codepage437": "cp437",
        "cspc775baltic": "cp775",
        "cspc850multilingual": "cp850",
        "cspcp852": "cp852",
        "cspc862latinhebrew": "cp862",
        "cpgr": "cp869",
    
        "msee": "cp1250",
        "mscyrl": "cp1251",
        "msansi": "cp1252",
        "msgreek": "cp1253",
        "msturk": "cp1254",
        "mshebr": "cp1255",
        "msarab": "cp1256",
        "winbaltrim": "cp1257",
    
        "cp20866": "koi8r",
        "20866": "koi8r",
        "ibm878": "koi8r",
        "cskoi8r": "koi8r",
    
        "cp21866": "koi8u",
        "21866": "koi8u",
        "ibm1168": "koi8u",
    
        "strk10482002": "rk1048",
    
        "tcvn5712": "tcvn",
        "tcvn57121": "tcvn",
    
        "gb198880": "iso646cn",
        "cn": "iso646cn",
    
        "csiso14jisc6220ro": "iso646jp",
        "jisc62201969ro": "iso646jp",
        "jp": "iso646jp",
    
        "cshproman8": "hproman8",
        "r8": "hproman8",
        "roman8": "hproman8",
        "xroman8": "hproman8",
        "ibm1051": "hproman8",
    
        "mac": "macintosh",
        "csmacintosh": "macintosh",
    };
    
    
  provide("iconv-lite/encodings/sbcs-data", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/sbcs-data-generated
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
    module.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹ�ֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ "
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ "
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ "
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ "
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ "
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ "
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ "
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ "
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ "
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู﻿​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\u0000ÚỤ\u0003ỪỬỮ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010ỨỰỲỶỸÝỴ\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\u0000\u0001Ẳ\u0003\u0004ẴẪ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013Ỷ\u0015\u0016\u0017\u0018Ỹ\u001a\u001b\u001c\u001dỴ\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "��������������������������������������������������������������������������������������������������������������������������������"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
      }
    }
  provide("iconv-lite/encodings/sbcs-data-generated", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/dbcs-codec
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
    // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
    // To save memory and loading time, we read table files only when requested.
    
    exports._dbcs = function(options) {
        return new DBCSCodec(options);
    }
    
    var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START  = -10,
        NODE_START = -1000,
        UNASSIGNED_NODE = new Array(0x100),
        DEF_CHAR = -1;
    
    for (var i = 0; i < 0x100; i++)
        UNASSIGNED_NODE[i] = UNASSIGNED;
    
    
    // Class DBCSCodec reads and initializes mapping tables.
    function DBCSCodec(options) {
        this.options = options;
        if (!options)
            throw new Error("DBCS codec is called without the data.")
        if (!options.table)
            throw new Error("Encoding '" + options.encodingName + "' has no data.");
    
        // Load tables.
        var mappingTable = options.table();
    
    
        // Decode tables: MBCS -> Unicode.
    
        // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
        // Trie root is decodeTables[0].
        // Values: >=  0 -> unicode character code. can be > 0xFFFF
        //         == UNASSIGNED -> unknown/unassigned sequence.
        //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
        //         <= NODE_START -> index of the next node in our trie to process next byte.
        //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.
    
        // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
        this.decodeTableSeq = [];
    
        // Actual mapping tables consist of chunks. Use them to fill up decode tables.
        for (var i = 0; i < mappingTable.length; i++)
            this._addDecodeChunk(mappingTable[i]);
    
        this.defaultCharUnicode = options.iconv.defaultCharUnicode;
    
        
        // Encode tables: Unicode -> DBCS.
    
        // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
        // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
        // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
        //         == UNASSIGNED -> no conversion found. Output a default char.
        //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
        this.encodeTable = [];
        
        // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
        // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
        // means end of sequence (needed when one sequence is a strict subsequence of another).
        // Objects are kept separately from encodeTable to increase performance.
        this.encodeTableSeq = [];
    
        // Some chars can be decoded, but need not be encoded.
        var skipEncodeChars = {};
        if (options.encodeSkipVals)
            for (var i = 0; i < options.encodeSkipVals.length; i++) {
                var range = options.encodeSkipVals[i];
                for (var j = range.from; j <= range.to; j++)
                    skipEncodeChars[j] = true;
            }
            
        // Use decode trie to recursively fill out encode tables.
        this._fillEncodeTable(0, 0, skipEncodeChars);
    
        // Add more encoding pairs when needed.
        for (var uChar in options.encodeAdd || {})
            this._setEncodeChar(uChar.charCodeAt(0), options.encodeAdd[uChar]);
    
        this.defCharSB  = this.encodeTable[0][options.iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    
    
        // Load & create GB18030 tables when needed.
        if (typeof options.gb18030 === 'function') {
            this.gb18030 = options.gb18030(); // Load GB18030 ranges.
    
            // Add GB18030 decode tables.
            var thirdByteNodeIdx = this.decodeTables.length;
            var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
    
            var fourthByteNodeIdx = this.decodeTables.length;
            var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
    
            for (var i = 0x81; i <= 0xFE; i++) {
                var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
                var secondByteNode = this.decodeTables[secondByteNodeIdx];
                for (var j = 0x30; j <= 0x39; j++)
                    secondByteNode[j] = NODE_START - thirdByteNodeIdx;
            }
            for (var i = 0x81; i <= 0xFE; i++)
                thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
            for (var i = 0x30; i <= 0x39; i++)
                fourthByteNode[i] = GB18030_CODE
        }        
    }
    
    // Public interface: create encoder and decoder objects. 
    // The methods (write, end) are simple functions to not inhibit optimizations.
    DBCSCodec.prototype.encoder = function encoderDBCS(options) {
        return {
            // Methods
            write: encoderDBCSWrite,
            end: encoderDBCSEnd,
    
            // Encoder state
            leadSurrogate: -1,
            seqObj: undefined,
            
            // Static data
            encodeTable: this.encodeTable,
            encodeTableSeq: this.encodeTableSeq,
            defaultCharSingleByte: this.defCharSB,
            gb18030: this.gb18030,
    
            // Export for testing
            findIdx: findIdx,
        }
    }
    
    DBCSCodec.prototype.decoder = function decoderDBCS(options) {
        return {
            // Methods
            write: decoderDBCSWrite,
            end: decoderDBCSEnd,
    
            // Decoder state
            nodeIdx: 0,
            prevBuf: new Buffer(0),
    
            // Static data
            decodeTables: this.decodeTables,
            decodeTableSeq: this.decodeTableSeq,
            defaultCharUnicode: this.defaultCharUnicode,
            gb18030: this.gb18030,
        }
    }
    
    
    
    // Decoder helpers
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
        var bytes = [];
        for (; addr > 0; addr >>= 8)
            bytes.push(addr & 0xFF);
        if (bytes.length == 0)
            bytes.push(0);
    
        var node = this.decodeTables[0];
        for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
            var val = node[bytes[i]];
    
            if (val == UNASSIGNED) { // Create new node.
                node[bytes[i]] = NODE_START - this.decodeTables.length;
                this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
            }
            else if (val <= NODE_START) { // Existing node.
                node = this.decodeTables[NODE_START - val];
            }
            else
                throw new Error("Overwrite byte in " + this.options.encodingName + ", addr: " + addr.toString(16));
        }
        return node;
    }
    
    
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
        // First element of chunk is the hex mbcs code where we start.
        var curAddr = parseInt(chunk[0], 16);
    
        // Choose the decoding node where we'll write our chars.
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 0xFF;
    
        // Write all other elements of the chunk to the table.
        for (var k = 1; k < chunk.length; k++) {
            var part = chunk[k];
            if (typeof part === "string") { // String, write as-is.
                for (var l = 0; l < part.length;) {
                    var code = part.charCodeAt(l++);
                    if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                        var codeTrail = part.charCodeAt(l++);
                        if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                            writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                        else
                            throw new Error("Incorrect surrogate pair in "  + this.options.encodingName + " at chunk " + chunk[0]);
                    }
                    else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                        var len = 0xFFF - code + 2;
                        var seq = [];
                        for (var m = 0; m < len; m++)
                            seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.
    
                        writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                        this.decodeTableSeq.push(seq);
                    }
                    else
                        writeTable[curAddr++] = code; // Basic char
                }
            } 
            else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
                var charCode = writeTable[curAddr - 1] + 1;
                for (var l = 0; l < part; l++)
                    writeTable[curAddr++] = charCode++;
            }
            else
                throw new Error("Incorrect type '" + typeof part + "' given in "  + this.options.encodingName + " at chunk " + chunk[0]);
        }
        if (curAddr > 0xFF)
            throw new Error("Incorrect chunk in "  + this.options.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    }
    
    // Encoder helpers
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
        var high = uCode >> 8; // This could be > 0xFF because of astral characters.
        if (this.encodeTable[high] === undefined)
            this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
        return this.encodeTable[high];
    }
    
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
        if (bucket[low] <= SEQ_START)
            this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
        else if (bucket[low] == UNASSIGNED)
            bucket[low] = dbcsCode;
    }
    
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
        
        // Get the root of character tree according to first character of the sequence.
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
    
        var node;
        if (bucket[low] <= SEQ_START) {
            // There's already a sequence with  - use it.
            node = this.encodeTableSeq[SEQ_START-bucket[low]];
        }
        else {
            // There was no sequence object - allocate a new one.
            node = {};
            if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
            bucket[low] = SEQ_START - this.encodeTableSeq.length;
            this.encodeTableSeq.push(node);
        }
    
        // Traverse the character tree, allocating new nodes as needed.
        for (var j = 1; j < seq.length-1; j++) {
            var oldVal = node[uCode];
            if (typeof oldVal === 'object')
                node = oldVal;
            else {
                node = node[uCode] = {}
                if (oldVal !== undefined)
                    node[DEF_CHAR] = oldVal
            }
        }
    
        // Set the leaf to given dbcsCode.
        uCode = seq[seq.length-1];
        node[uCode] = dbcsCode;
    }
    
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
        var node = this.decodeTables[nodeIdx];
        for (var i = 0; i < 0x100; i++) {
            var uCode = node[i];
            var mbCode = prefix + i;
            if (skipEncodeChars[mbCode])
                continue;
    
            if (uCode >= 0)
                this._setEncodeChar(uCode, mbCode);
            else if (uCode <= NODE_START)
                this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
            else if (uCode <= SEQ_START)
                this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        }
    }
    
    
    
    // == Actual Encoding ==========================================================
    
    
    function encoderDBCSWrite(str) {
        var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)), 
            leadSurrogate = this.leadSurrogate,
            seqObj = this.seqObj, nextChar = -1,
            i = 0, j = 0;
    
        while (true) {
            // 0. Get next character.
            if (nextChar === -1) {
                if (i == str.length) break;
                var uCode = str.charCodeAt(i++);
            }
            else {
                var uCode = nextChar;
                nextChar = -1;    
            }
    
            // 1. Handle surrogates.
            if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
                if (uCode < 0xDC00) { // We've got lead surrogate.
                    if (leadSurrogate === -1) {
                        leadSurrogate = uCode;
                        continue;
                    } else {
                        leadSurrogate = uCode;
                        // Double lead surrogate found.
                        uCode = UNASSIGNED;
                    }
                } else { // We've got trail surrogate.
                    if (leadSurrogate !== -1) {
                        uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                        leadSurrogate = -1;
                    } else {
                        // Incomplete surrogate pair - only trail surrogate found.
                        uCode = UNASSIGNED;
                    }
                    
                }
            }
            else if (leadSurrogate !== -1) {
                // Incomplete surrogate pair - only lead surrogate found.
                nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
                leadSurrogate = -1;
            }
    
            // 2. Convert uCode character.
            var dbcsCode = UNASSIGNED;
            if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
                var resCode = seqObj[uCode];
                if (typeof resCode === 'object') { // Sequence continues.
                    seqObj = resCode;
                    continue;
    
                } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                    dbcsCode = resCode;
    
                } else if (resCode == undefined) { // Current character is not part of the sequence.
    
                    // Try default character for this sequence
                    resCode = seqObj[DEF_CHAR];
                    if (resCode !== undefined) {
                        dbcsCode = resCode; // Found. Write it.
                        nextChar = uCode; // Current character will be written too in the next iteration.
    
                    } else {
                        // TODO: What if we have no default? (resCode == undefined)
                        // Then, we should write first char of the sequence as-is and try the rest recursively.
                        // Didn't do it for now because no encoding has this situation yet.
                        // Currently, just skip the sequence and write current char.
                    }
                }
                seqObj = undefined;
            }
            else if (uCode >= 0) {  // Regular character
                var subtable = this.encodeTable[uCode >> 8];
                if (subtable !== undefined)
                    dbcsCode = subtable[uCode & 0xFF];
                
                if (dbcsCode <= SEQ_START) { // Sequence start
                    seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                    continue;
                }
    
                if (dbcsCode == UNASSIGNED && this.gb18030) {
                    // Use GB18030 algorithm to find character(s) to write.
                    var idx = findIdx(this.gb18030.uChars, uCode);
                    if (idx != -1) {
                        var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                        newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                        newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                        newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                        newBuf[j++] = 0x30 + dbcsCode;
                        continue;
                    }
                }
            }
    
            // 3. Write dbcsCode character.
            if (dbcsCode === UNASSIGNED)
                dbcsCode = this.defaultCharSingleByte;
            
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else if (dbcsCode < 0x10000) {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
            else {
                newBuf[j++] = dbcsCode >> 16;
                newBuf[j++] = (dbcsCode >> 8) & 0xFF;
                newBuf[j++] = dbcsCode & 0xFF;
            }
        }
    
        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
    }
    
    function encoderDBCSEnd() {
        if (this.leadSurrogate === -1 && this.seqObj === undefined)
            return; // All clean. Most often case.
    
        var newBuf = new Buffer(10), j = 0;
    
        if (this.seqObj) { // We're in the sequence.
            var dbcsCode = this.seqObj[DEF_CHAR];
            if (dbcsCode !== undefined) { // Write beginning of the sequence.
                if (dbcsCode < 0x100) {
                    newBuf[j++] = dbcsCode;
                }
                else {
                    newBuf[j++] = dbcsCode >> 8;   // high byte
                    newBuf[j++] = dbcsCode & 0xFF; // low byte
                }
            } else {
                // See todo above.
            }
            this.seqObj = undefined;
        }
    
        if (this.leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            newBuf[j++] = this.defaultCharSingleByte;
            this.leadSurrogate = -1;
        }
        
        return newBuf.slice(0, j);
    }
    
    
    // == Actual Decoding ==========================================================
    
    
    function decoderDBCSWrite(buf) {
        var newBuf = new Buffer(buf.length*2),
            nodeIdx = this.nodeIdx, 
            prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
            seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
            uCode;
    
        if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
            prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
        
        for (var i = 0, j = 0; i < buf.length; i++) {
            var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];
    
            // Lookup in current trie node.
            var uCode = this.decodeTables[nodeIdx][curByte];
    
            if (uCode >= 0) { 
                // Normal character, just use it.
            }
            else if (uCode === UNASSIGNED) { // Unknown char.
                // TODO: Callback with seq.
                //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
                i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
                uCode = this.defaultCharUnicode.charCodeAt(0);
            }
            else if (uCode === GB18030_CODE) {
                var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
                var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
                var idx = findIdx(this.gb18030.gbChars, ptr);
                uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
            }
            else if (uCode <= NODE_START) { // Go to next trie node.
                nodeIdx = NODE_START - uCode;
                continue;
            }
            else if (uCode <= SEQ_START) { // Output a sequence of chars.
                var seq = this.decodeTableSeq[SEQ_START - uCode];
                for (var k = 0; k < seq.length - 1; k++) {
                    uCode = seq[k];
                    newBuf[j++] = uCode & 0xFF;
                    newBuf[j++] = uCode >> 8;
                }
                uCode = seq[seq.length-1];
            }
            else
                throw new Error("Unknown table value when decoding: " + val);
    
            // Write the character to buffer, handling higher planes using surrogate pair.
            if (uCode > 0xFFFF) { 
                uCode -= 0x10000;
                var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
                newBuf[j++] = uCodeLead & 0xFF;
                newBuf[j++] = uCodeLead >> 8;
    
                uCode = 0xDC00 + uCode % 0x400;
            }
            newBuf[j++] = uCode & 0xFF;
            newBuf[j++] = uCode >> 8;
    
            // Reset trie node.
            nodeIdx = 0; seqStart = i+1;
        }
    
        this.nodeIdx = nodeIdx;
        this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
        return newBuf.slice(0, j).toString('ucs2');
    }
    
    function decoderDBCSEnd() {
        var ret = '';
    
        // Try to parse all remaining chars.
        while (this.prevBuf.length > 0) {
            // Skip 1 character in the buffer.
            ret += this.defaultCharUnicode;
            var buf = this.prevBuf.slice(1);
    
            // Parse remaining as usual.
            this.prevBuf = new Buffer(0);
            this.nodeIdx = 0;
            if (buf.length > 0)
                ret += decoderDBCSWrite.call(this, buf);
        }
    
        this.nodeIdx = 0;
        return ret;
    }
    
    // Binary search for GB18030. Returns largest i such that table[i] <= val.
    function findIdx(table, val) {
        if (table[0] > val)
            return -1;
    
        var l = 0, r = table.length;
        while (l < r-1) { // always table[l] <= val < table[r]
            var mid = l + Math.floor((r-l+1)/2);
            if (table[mid] <= val)
                l = mid;
            else
                r = mid;
        }
        return l;
    }
    
    
  provide("iconv-lite/encodings/dbcs-codec", module.exports);
}(global));

// pakmanager:iconv-lite/encodings/dbcs-data
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Description of supported double byte encodings and aliases.
    // Tables are not require()-d until they are needed to speed up library load.
    // require()-s are direct to support Browserify.
    
    module.exports = {
        
        // == Japanese/ShiftJIS ====================================================
        // All japanese encodings are based on JIS X set of standards:
        // JIS X 0201 - Single-byte encoding of ASCII + ¥ + Kana chars at 0xA1-0xDF.
        // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
        //              Has several variations in 1978, 1983, 1990 and 1997.
        // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
        // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
        //              2 planes, first is superset of 0208, second - revised 0212.
        //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    
        // Byte encodings are:
        //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
        //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
        //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
        //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
        //               0x00-0x7F       - lower part of 0201
        //               0x8E, 0xA1-0xDF - upper part of 0201
        //               (0xA1-0xFE)x2   - 0208 plane (94x94).
        //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
        //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
        //               Used as-is in ISO2022 family.
        //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
        //                0201-1976 Roman, 0208-1978, 0208-1983.
        //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
        //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
        //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
        //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
        //
        // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
        //
        // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    
    
        'shiftjis': {
            type: '_dbcs',
            table: function() { return require('./tables/shiftjis.json') },
            encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
            encodeSkipVals: [{from: 0xED40, to: 0xF940}],
        },
        'csshiftjis': 'shiftjis',
        'mskanji': 'shiftjis',
        'sjis': 'shiftjis',
        'windows-31j': 'shiftjis',
        'x-sjis': 'shiftjis',
        'windows932': 'shiftjis',
        '932': 'shiftjis',
        'cp932': 'shiftjis',
    
        'eucjp': {
            type: '_dbcs',
            table: function() { return require('./tables/eucjp.json') },
            encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        },
    
        // TODO: KDDI extension to Shift_JIS
        // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
        // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    
        // == Chinese/GBK ==========================================================
        // http://en.wikipedia.org/wiki/GBK
    
        // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
        'gb2312': 'cp936',
        'gb231280': 'cp936',
        'gb23121980': 'cp936',
        'csgb2312': 'cp936',
        'csiso58gb231280': 'cp936',
        'euccn': 'cp936',
        'isoir58': 'gbk',
    
        // Microsoft's CP936 is a subset and approximation of GBK.
        // TODO: Euro = 0x80 in cp936, but not in GBK (where it's valid but undefined)
        'windows936': 'cp936',
        '936': 'cp936',
        'cp936': {
            type: '_dbcs',
            table: function() { return require('./tables/cp936.json') },
        },
    
        // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
        'gbk': {
            type: '_dbcs',
            table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
        },
        'xgbk': 'gbk',
    
        // GB18030 is an algorithmic extension of GBK.
        'gb18030': {
            type: '_dbcs',
            table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
            gb18030: function() { return require('./tables/gb18030-ranges.json') },
        },
    
        'chinese': 'gb18030',
    
        // TODO: Support GB18030 (~27000 chars + whole unicode mapping, cp54936)
        // http://icu-project.org/docs/papers/gb18030.html
        // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
        // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    
        // == Korean ===============================================================
        // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
        'windows949': 'cp949',
        '949': 'cp949',
        'cp949': {
            type: '_dbcs',
            table: function() { return require('./tables/cp949.json') },
        },
    
        'cseuckr': 'cp949',
        'csksc56011987': 'cp949',
        'euckr': 'cp949',
        'isoir149': 'cp949',
        'korean': 'cp949',
        'ksc56011987': 'cp949',
        'ksc56011989': 'cp949',
        'ksc5601': 'cp949',
    
    
        // == Big5/Taiwan/Hong Kong ================================================
        // There are lots of tables for Big5 and cp950. Please see the following links for history:
        // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
        // Variations, in roughly number of defined chars:
        //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
        //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
        //  * Big5-2003 (Taiwan standard) almost superset of cp950.
        //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
        //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
        //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
        //    Plus, it has 4 combining sequences.
        //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
        //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
        //    Implementations are not consistent within browsers; sometimes labeled as just big5.
        //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
        //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
        //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
        //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
        //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
        // 
        // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
        // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    
        'windows950': 'cp950',
        '950': 'cp950',
        'cp950': {
            type: '_dbcs',
            table: function() { return require('./tables/cp950.json') },
        },
    
        // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
        'big5': 'big5hkscs',
        'big5hkscs': {
            type: '_dbcs',
            table: function() { return require('./tables/cp950.json').concat(require('./tables/big5-added.json')) },
        },
    
        'cnbig5': 'big5hkscs',
        'csbig5': 'big5hkscs',
        'xxbig5': 'big5hkscs',
    
    };
  provide("iconv-lite/encodings/dbcs-data", module.exports);
}(global));

// pakmanager:iconv-lite/encodings
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Update this array if you add/rename/remove files in this directory.
    // We support Browserify by skipping automatic module discovery and requiring modules directly.
    var modules = [
         require('iconv-lite/encodings/internal'),
         require('iconv-lite/encodings/utf16'),
         require('iconv-lite/encodings/utf7'),
         require('iconv-lite/encodings/sbcs-codec'),
         require('iconv-lite/encodings/sbcs-data'),
         require('iconv-lite/encodings/sbcs-data-generated'),
         require('iconv-lite/encodings/dbcs-codec'),
         require('iconv-lite/encodings/dbcs-data'),
    ];
    
    // Put all encoding/alias/codec definitions to single object and export it. 
    for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module)
            exports[enc] = module[enc];
    }
    
  provide("iconv-lite/encodings", module.exports);
}(global));

// pakmanager:iconv-lite/lib/streams
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Transform = require("stream").Transform;
    
    
    // == Exports ==================================================================
    module.exports = function(iconv) {
        
        // Additional Public API.
        iconv.encodeStream = function encodeStream(encoding, options) {
            return new IconvLiteEncoderStream(iconv.getCodec(encoding).encoder(options), options);
        }
    
        iconv.decodeStream = function decodeStream(encoding, options) {
            return new IconvLiteDecoderStream(iconv.getCodec(encoding).decoder(options), options);
        }
    
        iconv.supportsStreams = true;
    
    
        // Not published yet.
        iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
        iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
        iconv._collect = IconvLiteDecoderStream.prototype.collect;
    };
    
    
    // == Encoder stream =======================================================
    function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
        Transform.call(this, options);
    }
    
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
    });
    
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != 'string')
            return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on('error', cb);
        this.on('data', function(chunk) { chunks.push(chunk); });
        this.on('end', function() {
            cb(null, Buffer.concat(chunks));
        });
        return this;
    }
    
    
    // == Decoder stream =======================================================
    function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = 'utf8'; // We output strings.
        Transform.call(this, options);
    }
    
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
    });
    
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer.isBuffer(chunk))
            return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);                
            done();
        }
        catch (e) {
            done(e);
        }
    }
    
    IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = '';
        this.on('error', cb);
        this.on('data', function(chunk) { res += chunk; });
        this.on('end', function() {
            cb(null, res);
        });
        return this;
    }
    
    
  provide("iconv-lite/lib/streams", module.exports);
}(global));

// pakmanager:iconv-lite/lib/extend-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // == Extend Node primitives to use iconv-lite =================================
    
    module.exports = function (iconv) {
        var original = undefined; // Place to keep original methods.
    
        iconv.extendNodeEncodings = function extendNodeEncodings() {
            if (original) return;
            original = {};
    
            var nodeNativeEncodings = {
                'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
                'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
            };
    
            Buffer.isNativeEncoding = function(enc) {
                return nodeNativeEncodings[enc && enc.toLowerCase()];
            }
    
            // -- SlowBuffer -----------------------------------------------------------
            var SlowBuffer = require('buffer').SlowBuffer;
    
            original.SlowBufferToString = SlowBuffer.prototype.toString;
            SlowBuffer.prototype.toString = function(encoding, start, end) {
                encoding = String(encoding || 'utf8').toLowerCase();
                start = +start || 0;
                if (typeof end !== 'number') end = this.length;
    
                // Fastpath empty strings
                if (+end == start)
                    return '';
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.SlowBufferToString.call(this, encoding, start, end);
    
                // Otherwise, use our decoding method.
                if (typeof start == 'undefined') start = 0;
                if (typeof end == 'undefined') end = this.length;
                return iconv.decode(this.slice(start, end), encoding);
            }
    
            original.SlowBufferWrite = SlowBuffer.prototype.write;
            SlowBuffer.prototype.write = function(string, offset, length, encoding) {
                // Support both (string, offset, length, encoding)
                // and the legacy (string, encoding, offset, length)
                if (isFinite(offset)) {
                    if (!isFinite(length)) {
                        encoding = length;
                        length = undefined;
                    }
                } else {  // legacy
                    var swap = encoding;
                    encoding = offset;
                    offset = length;
                    length = swap;
                }
    
                offset = +offset || 0;
                var remaining = this.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = +length;
                    if (length > remaining) {
                        length = remaining;
                    }
                }
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.SlowBufferWrite.call(this, string, offset, length, encoding);
    
                if (string.length > 0 && (length < 0 || offset < 0))
                    throw new RangeError('attempt to write beyond buffer bounds');
    
                // Otherwise, use our encoding method.
                var buf = iconv.encode(string, encoding);
                if (buf.length < length) length = buf.length;
                buf.copy(this, offset, 0, length);
                return length;
            }
    
            // -- Buffer ---------------------------------------------------------------
    
            original.BufferIsEncoding = Buffer.isEncoding;
            Buffer.isEncoding = function(encoding) {
                return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
            }
    
            original.BufferByteLength = Buffer.byteLength;
            Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.BufferByteLength.call(this, str, encoding);
    
                // Slow, I know, but we don't have a better way yet.
                return iconv.encode(str, encoding).length;
            }
    
            original.BufferToString = Buffer.prototype.toString;
            Buffer.prototype.toString = function(encoding, start, end) {
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.BufferToString.call(this, encoding, start, end);
    
                // Otherwise, use our decoding method.
                if (typeof start == 'undefined') start = 0;
                if (typeof end == 'undefined') end = this.length;
                return iconv.decode(this.slice(start, end), encoding);
            }
    
            original.BufferWrite = Buffer.prototype.write;
            Buffer.prototype.write = function(string, offset, length, encoding) {
                var _offset = offset, _length = length, _encoding = encoding;
                // Support both (string, offset, length, encoding)
                // and the legacy (string, encoding, offset, length)
                if (isFinite(offset)) {
                    if (!isFinite(length)) {
                        encoding = length;
                        length = undefined;
                    }
                } else {  // legacy
                    var swap = encoding;
                    encoding = offset;
                    offset = length;
                    length = swap;
                }
    
                encoding = String(encoding || 'utf8').toLowerCase();
    
                // Use native conversion when possible
                if (Buffer.isNativeEncoding(encoding))
                    return original.BufferWrite.call(this, string, _offset, _length, _encoding);
    
                offset = +offset || 0;
                var remaining = this.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = +length;
                    if (length > remaining) {
                        length = remaining;
                    }
                }
    
                if (string.length > 0 && (length < 0 || offset < 0))
                    throw new RangeError('attempt to write beyond buffer bounds');
    
                // Otherwise, use our encoding method.
                var buf = iconv.encode(string, encoding);
                if (buf.length < length) length = buf.length;
                buf.copy(this, offset, 0, length);
                return length;
    
                // TODO: Set _charsWritten.
            }
    
    
            // -- Readable -------------------------------------------------------------
            if (iconv.supportsStreams) {
                var Readable = require('stream').Readable;
    
                original.ReadableSetEncoding = Readable.prototype.setEncoding;
                Readable.prototype.setEncoding = function setEncoding(enc, options) {
                    // Try to use original function when possible.
                    if (Buffer.isNativeEncoding(enc))
                        return original.ReadableSetEncoding.call(this, enc);
    
                    // Try to use our own decoder, it has the same interface.
                    this._readableState.decoder = iconv.getCodec(enc).decoder(options);
                    this._readableState.encoding = enc;
                }
    
                Readable.prototype.collect = iconv._collect;
            }
        }
    
        // Remove iconv-lite Node primitive extensions.
        iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
            if (!original)
                throw new Error(" require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")
    
            delete Buffer.isNativeEncoding;
    
            var SlowBuffer = require('buffer').SlowBuffer;
    
            SlowBuffer.prototype.toString = original.SlowBufferToString;
            SlowBuffer.prototype.write = original.SlowBufferWrite;
    
            Buffer.isEncoding = original.BufferIsEncoding;
            Buffer.byteLength = original.BufferByteLength;
            Buffer.prototype.toString = original.BufferToString;
            Buffer.prototype.write = original.BufferWrite;
    
            if (iconv.supportsStreams) {
                var Readable = require('stream').Readable;
    
                Readable.prototype.setEncoding = original.ReadableSetEncoding;
                delete Readable.prototype.collect;
            }
    
            original = undefined;
        }
    }
    
  provide("iconv-lite/lib/extend-node", module.exports);
}(global));

// pakmanager:iconv-lite
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var iconv = module.exports;
    
    // All codecs and aliases are kept here, keyed by encoding name/alias.
    // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
    iconv.encodings = null;
    
    // Characters emitted in case of error.
    iconv.defaultCharUnicode = '�';
    iconv.defaultCharSingleByte = '?';
    
    // Public API.
    iconv.encode = function encode(str, encoding, options) {
        str = "" + (str || ""); // Ensure string.
    
        var encoder = iconv.getCodec(encoding).encoder(options);
    
        var res = encoder.write(str);
        var trail = encoder.end();
        
        return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
    }
    
    iconv.decode = function decode(buf, encoding, options) {
        if (typeof buf === 'string') {
            if (!iconv.skipDecodeWarning) {
                console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
                iconv.skipDecodeWarning = true;
            }
    
            buf = new Buffer("" + (buf || ""), "binary"); // Ensure buffer.
        }
    
        var decoder = iconv.getCodec(encoding).decoder(options);
    
        var res = decoder.write(buf);
        var trail = decoder.end();
    
        return (trail && trail.length > 0) ? (res + trail) : res;
    }
    
    iconv.encodingExists = function encodingExists(enc) {
        try {
            iconv.getCodec(enc);
            return true;
        } catch (e) {
            return false;
        }
    }
    
    // Legacy aliases to convert functions
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    
    // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
        if (!iconv.encodings)
            iconv.encodings =  require('iconv-lite/encodings'); // Lazy load all encoding definitions.
        
        // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
        var enc = (''+encoding).toLowerCase().replace(/[^0-9a-z]|:\d{4}$/g, "");
    
        // Traverse iconv.encodings to find actual codec.
        var codecData, codecOptions;
        while (true) {
            codecData = iconv._codecDataCache[enc];
            if (codecData)
                return codecData;
    
            var codec = iconv.encodings[enc];
    
            switch (typeof codec) {
                case "string": // Direct alias to other encoding.
                    enc = codec;
                    break;
    
                case "object": // Alias with options. Can be layered.
                    if (!codecOptions) {
                        codecOptions = codec;
                        codecOptions.encodingName = enc;
                    }
                    else {
                        for (var key in codec)
                            codecOptions[key] = codec[key];
                    }
    
                    enc = codec.type;
                    break;
    
                case "function": // Codec itself.
                    if (!codecOptions)
                        codecOptions = { encodingName: enc };
                    codecOptions.iconv = iconv;
    
                    // The codec function must load all tables and return object with .encoder and .decoder methods.
                    // It'll be called only once (for each different options object).
                    codecData = codec.call(iconv.encodings, codecOptions);
    
                    iconv._codecDataCache[codecOptions.encodingName] = codecData; // Save it to be reused later.
                    return codecData;
    
                default:
                    throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
            }
        }
    }
    
    // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
    var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
    if (nodeVer) {
    
        // Load streaming support in Node v0.10+
        var nodeVerArr = nodeVer.split(".").map(Number);
        if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
             require('iconv-lite/lib/streams')(iconv);
        }
    
        // Load Node primitive extensions.
         require('iconv-lite/lib/extend-node')(iconv);
    }
    
    
  provide("iconv-lite", module.exports);
}(global));

// pakmanager:superagent/lib/node/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var StringDecoder = require('string_decoder').StringDecoder;
    var Stream = require('stream');
    var zlib;
    
    /**
     * Require zlib module for Node 0.6+
     */
    
    try {
      zlib = require('zlib');
    } catch (e) { }
    
    /**
     * Generate a UID with the given `len`.
     *
     * @param {Number} len
     * @return {String}
     * @api private
     */
    
    exports.uid = function(len){
      var buf = '';
      var chars = 'abcdefghijklmnopqrstuvwxyz123456789';
      var nchars = chars.length;
      while (len--) buf += chars[Math.random() * nchars | 0];
      return buf;
    };
    
    /**
     * Return the mime type for the given `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    exports.type = function(str){
      return str.split(/ *; */).shift();
    };
    
    /**
     * Return header field parameters.
     *
     * @param {String} str
     * @return {Object}
     * @api private
     */
    
    exports.params = function(str){
      return str.split(/ *; */).reduce(function(obj, str){
        var parts = str.split(/ *= */);
        var key = parts.shift();
        var val = parts.shift();
    
        if (key && val) obj[key] = val;
        return obj;
      }, {});
    };
    
    /**
     * Parse Link header fields.
     *
     * @param {String} str
     * @return {Object}
     * @api private
     */
    
    exports.parseLinks = function(str){
      return str.split(/ *, */).reduce(function(obj, str){
        var parts = str.split(/ *; */);
        var url = parts[0].slice(1, -1);
        var rel = parts[1].split(/ *= */)[1].slice(1, -1);
        obj[rel] = url;
        return obj;
      }, {});
    };
    
    /**
     * Buffers response data events and re-emits when they're unzipped.
     *
     * @param {Request} req
     * @param {Response} res
     * @api private
     */
    
    exports.unzip = function(req, res){
      if (!zlib) return;
    
      var unzip = zlib.createUnzip();
      var stream = new Stream;
      var decoder;
    
      // make node responseOnEnd() happy
      stream.req = req;
    
      unzip.on('error', function(err){
        stream.emit('error', err);
      });
    
      // pipe to unzip
      res.pipe(unzip);
    
      // override `setEncoding` to capture encoding
      res.setEncoding = function(type){
        decoder = new StringDecoder(type);
      };
    
      // decode upon decompressing with captured encoding
      unzip.on('data', function(buf){
        if (decoder) {
          var str = decoder.write(buf);
          if (str.length) stream.emit('data', str);
        } else {
          stream.emit('data', buf);
        }
      });
    
      unzip.on('end', function(){
        stream.emit('end');
      });
    
      // override `on` to capture data listeners
      var _on = res.on;
      res.on = function(type, fn){
        if ('data' == type || 'end' == type) {
          stream.on(type, fn);
        } else if ('error' == type) {
          stream.on(type, fn);
          _on.call(res, type, fn);
        } else {
          _on.call(res, type, fn);
        }
      };
    };
    
    /**
     * Strip content related fields from `header`.
     *
     * @param {Object} header
     * @return {Object} header
     * @api private
     */
    
    exports.cleanHeader = function(header){
      delete header['content-type'];
      delete header['content-length'];
      delete header['transfer-encoding'];
      delete header['cookie'];
      delete header['host'];
      return header;
    };
    
  provide("superagent/lib/node/utils", module.exports);
}(global));

// pakmanager:superagent/lib/node/parsers/urlencoded
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var qs = require('qs');
    
    module.exports = function(res, fn){
      res.text = '';
      res.setEncoding('ascii');
      res.on('data', function(chunk){ res.text += chunk; });
      res.on('end', function(){
        try {
          fn(null, qs.parse(res.text));
        } catch (err) {
          fn(err);
        }
      });
    };
  provide("superagent/lib/node/parsers/urlencoded", module.exports);
}(global));

// pakmanager:superagent/lib/node/parsers/json
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = function(res, fn){
      res.text = '';
      res.setEncoding('utf8');
      res.on('data', function(chunk){ res.text += chunk; });
      res.on('end', function(){
        try {
          fn(null, JSON.parse(res.text));
        } catch (err) {
          fn(err);
        }
      });
    };
  provide("superagent/lib/node/parsers/json", module.exports);
}(global));

// pakmanager:superagent/lib/node/parsers/text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = function(res, fn){
      res.text = '';
      res.setEncoding('utf8');
      res.on('data', function(chunk){ res.text += chunk; });
      res.on('end', fn);
    };
  provide("superagent/lib/node/parsers/text", module.exports);
}(global));

// pakmanager:superagent/lib/node/parsers/image
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function(res, fn){
      var data = []; // Binary data needs binary storage
    
      res.on('data', function(chunk){
          data.push(chunk);
      });
      res.on('end', function () {
          fn(null, Buffer.concat(data));
      });
    };
  provide("superagent/lib/node/parsers/image", module.exports);
}(global));

// pakmanager:superagent/lib/node/response
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var util = require('util');
    var utils =  require('superagent/lib/node/utils');
    var Stream = require('stream');
    
    /**
     * Expose `Response`.
     */
    
    module.exports = Response;
    
    /**
     * Initialize a new `Response` with the given `xhr`.
     *
     *  - set flags (.ok, .error, etc)
     *  - parse header
     *
     * @param {Request} req
     * @param {Object} options
     * @constructor
     * @extends {Stream}
     * @implements {ReadableStream}
     * @api private
     */
    
    function Response(req, options) {
      Stream.call(this);
      options = options || {};
      var res = this.res = req.res;
      this.request = req;
      this.req = req.req;
      this.links = {};
      this.text = res.text;
      this.body = res.body || {};
      this.files = res.files || {};
      this.buffered = 'string' == typeof this.text;
      this.header = this.headers = res.headers;
      this.setStatusProperties(res.statusCode);
      this.setHeaderProperties(this.header);
      this.setEncoding = res.setEncoding.bind(res);
      res.on('data', this.emit.bind(this, 'data'));
      res.on('end', this.emit.bind(this, 'end'));
      res.on('close', this.emit.bind(this, 'close'));
      res.on('error', this.emit.bind(this, 'error'));
    }
    
    /**
     * Inherit from `Stream`.
     */
    
    util.inherits(Response, Stream);
    
    /**
     * Get case-insensitive `field` value.
     *
     * @param {String} field
     * @return {String}
     * @api public
     */
    
    Response.prototype.get = function(field){
      return this.header[field.toLowerCase()];
    };
    
    /**
     * Implements methods of a `ReadableStream`
     */
    
    Response.prototype.destroy = function(err){
      this.res.destroy(err);
    };
    
    /**
     * Pause.
     */
    
    Response.prototype.pause = function(){
      this.res.pause();
    };
    
    /**
     * Resume.
     */
    
    Response.prototype.resume = function(){
      this.res.resume();
    };
    
    /**
     * Return an `Error` representative of this response.
     *
     * @return {Error}
     * @api public
     */
    
    Response.prototype.toError = function(){
      var req = this.req;
      var method = req.method;
      var path = req.path;
    
      var msg = 'cannot ' + method + ' ' + path + ' (' + this.status + ')';
      var err = new Error(msg);
      err.status = this.status;
      err.text = this.text;
      err.method = method;
      err.path = path;
    
      return err;
    };
    
    /**
     * Set header related properties:
     *
     *   - `.type` the content type without params
     *
     * A response of "Content-Type: text/plain; charset=utf-8"
     * will provide you with a `.type` of "text/plain".
     *
     * @param {Object} header
     * @api private
     */
    
    Response.prototype.setHeaderProperties = function(header){
      // TODO: moar!
      // TODO: make this a util
    
      // content-type
      var ct = this.header['content-type'] || '';
    
      // params
      var params = utils.params(ct);
      for (var key in params) this[key] = params[key];
    
      this.type = utils.type(ct);
    
      // links
      try {
        if (header.link) this.links = utils.parseLinks(header.link);
      } catch (err) {
        // ignore
      }
    };
    
    /**
     * Parse cookies from the header into an array.
     */
    
    function parseCookies(header) {
      return Array.isArray(header)
        ? header.map(Cookie.parse)
        : [Cookie.parse(header)];
    }
    
    /**
     * Set flags such as `.ok` based on `status`.
     *
     * For example a 2xx response will give you a `.ok` of __true__
     * whereas 5xx will be __false__ and `.error` will be __true__. The
     * `.clientError` and `.serverError` are also available to be more
     * specific, and `.statusType` is the class of error ranging from 1..5
     * sometimes useful for mapping respond colors etc.
     *
     * "sugar" properties are also defined for common cases. Currently providing:
     *
     *   - .noContent
     *   - .badRequest
     *   - .unauthorized
     *   - .notAcceptable
     *   - .notFound
     *
     * @param {Number} status
     * @api private
     */
    
    Response.prototype.setStatusProperties = function(status){
      var type = status / 100 | 0;
    
      // status / class
      this.status = this.statusCode = status;
      this.statusType = type;
    
      // basics
      this.info = 1 == type;
      this.ok = 2 == type;
      this.redirect = 3 == type;
      this.clientError = 4 == type;
      this.serverError = 5 == type;
      this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;
    
      // sugar
      this.accepted = 202 == status;
      this.noContent = 204 == status;
      this.badRequest = 400 == status;
      this.unauthorized = 401 == status;
      this.notAcceptable = 406 == status;
      this.forbidden = 403 == status;
      this.notFound = 404 == status;
    };
    
    /**
     * To json.
     *
     * @return {Object}
     * @api public
     */
    
    Response.prototype.toJSON = function(){
      return {
        req: this.request.toJSON(),
        header: this.header,
        status: this.status,
        text: this.text
      };
    };
    
  provide("superagent/lib/node/response", module.exports);
}(global));

// pakmanager:superagent/lib/node/part
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var util = require('util');
    var mime = require('mime');
    var FormData = require('form-data');
    var PassThrough = require('readable-stream/passthrough');
    
    /**
     * Initialize a new `Part` for the given `req`.
     *
     * @param {Request} req
     * @api public
     * @deprecated pass a readable stream in to `Request#attach()` instead
     */
    
    var Part = function (req) {
      PassThrough.call(this);
      this._req = req;
      this._attached = false;
      this._name = null;
      this._type = null;
      this._header = null;
      this._filename = null;
    
      this.once('pipe', this._attach.bind(this));
    };
    Part = util.deprecate(Part, 'The `Part()` constructor is deprecated. ' +
       'Pass a readable stream in to `Request#attach()` instead.');
    
    /**
     * Inherit from `PassThrough`.
     */
    
    util.inherits(Part, PassThrough);
    
    /**
     * Expose `Part`.
     */
    
    module.exports = Part;
    
    /**
     * Set header `field` to `val`.
     *
     * @param {String} field
     * @param {String} val
     * @return {Part} for chaining
     * @api public
     */
    
    Part.prototype.set = function(field, val){
      //if (!this._header) this._header = {};
      //this._header[field] = val;
      //return this;
      throw new TypeError('setting custom form-data part headers is unsupported');
    };
    
    /**
     * Set _Content-Type_ response header passed through `mime.lookup()`.
     *
     * Examples:
     *
     *     res.type('html');
     *     res.type('.html');
     *
     * @param {String} type
     * @return {Part} for chaining
     * @api public
     */
    
    Part.prototype.type = function(type){
      var lookup = mime.lookup(type);
      this._type = lookup;
      //this.set('Content-Type', lookup);
      return this;
    };
    
    /**
     * Set the "name" portion for the _Content-Disposition_ header field.
     *
     * @param {String} name
     * @return {Part} for chaining
     * @api public
     */
    
    Part.prototype.name = function(name){
      this._name = name;
      return this;
    };
    
    /**
     * Set _Content-Disposition_ header field to _attachment_ with `filename`
     * and field `name`.
     *
     * @param {String} name
     * @param {String} filename
     * @return {Part} for chaining
     * @api public
     */
    
    Part.prototype.attachment = function(name, filename){
      this.name(name);
      if (filename) {
        this.type(filename);
        this._filename = filename;
      }
      return this;
    };
    
    /**
     * Calls `FormData#append()` on the Request instance's FormData object.
     *
     * Gets called implicitly upon the first `write()` call, or the "pipe" event.
     *
     * @api private
     */
    
    Part.prototype._attach = function(){
      if (this._attached) return;
      this._attached = true;
    
      if (!this._name) throw new Error('must call `Part#name()` first!');
    
      // add `this` Stream's readable side as a stream for this Part
      if (!this._req._formData) this._req._formData = new FormData();
      this._req._formData.append(this._name, this, {
        contentType: this._type,
        filename: this._filename
      });
    
      // restore PassThrough's default `write()` function now that we're setup
      this.write = PassThrough.prototype.write;
    };
    
    /**
     * Write `data` with `encoding`.
     *
     * @param {Buffer|String} data
     * @param {String} encoding
     * @return {Boolean}
     * @api public
     */
    
    Part.prototype.write = function(){
      this._attach();
      return this.write.apply(this, arguments);
    };
    
  provide("superagent/lib/node/part", module.exports);
}(global));

// pakmanager:superagent/lib/node/parsers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    exports['application/x-www-form-urlencoded'] =  require('superagent/lib/node/parsers/urlencoded');
    exports['application/json'] =  require('superagent/lib/node/parsers/json');
    exports.text =  require('superagent/lib/node/parsers/text');
    exports.image =  require('superagent/lib/node/parsers/image');
    
  provide("superagent/lib/node/parsers", module.exports);
}(global));

// pakmanager:superagent/lib/node/index
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var debug = require('debug')('superagent');
    var formidable = require('formidable');
    var FormData = require('form-data');
    var Response =  require('superagent/lib/node/response');
    var parse = require('url').parse;
    var format = require('url').format;
    var methods = require('methods');
    var Stream = require('stream');
    var utils =  require('superagent/lib/node/utils');
    var extend = require('extend');
    var Part =  require('superagent/lib/node/part');
    var mime = require('mime');
    var https = require('https');
    var http = require('http');
    var fs = require('fs');
    var qs = require('qs');
    var zlib = require('zlib');
    var util = require('util');
    var pkg = require('../../package.json');
    
    /**
     * Expose the request function.
     */
    
    exports = module.exports = request;
    
    /**
     * Expose the agent function
     */
    
    exports.agent =  require('superagent/lib/node/agent');
    
    /**
     * Expose `Part`.
     */
    
    exports.Part = Part;
    
    /**
     * Noop.
     */
    
    function noop(){};
    
    /**
     * Expose `Response`.
     */
    
    exports.Response = Response;
    
    /**
     * Define "form" mime type.
     */
    
    mime.define({
      'application/x-www-form-urlencoded': ['form', 'urlencoded', 'form-data']
    });
    
    /**
     * Protocol map.
     */
    
    exports.protocols = {
      'http:': http,
      'https:': https
    };
    
    /**
     * Check if `obj` is an object.
     *
     * @param {Object} obj
     * @return {Boolean}
     * @api private
     */
    
    function isObject(obj) {
      return null != obj && 'object' == typeof obj;
    }
    
    /**
     * Default serialization map.
     *
     *     superagent.serialize['application/xml'] = function(obj){
     *       return 'generated xml here';
     *     };
     *
     */
    
    exports.serialize = {
      'application/x-www-form-urlencoded': qs.stringify,
      'application/json': JSON.stringify
    };
    
    /**
     * Default parsers.
     *
     *     superagent.parse['application/xml'] = function(res, fn){
     *       fn(null, result);
     *     };
     *
     */
    
    exports.parse =  require('superagent/lib/node/parsers');
    
    /**
     * Initialize a new `Request` with the given `method` and `url`.
     *
     * @param {String} method
     * @param {String|Object} url
     * @api public
     */
    
    function Request(method, url) {
      Stream.call(this);
      var self = this;
      if ('string' != typeof url) url = format(url);
      this._agent = false;
      this._formData = null;
      this.method = method;
      this.url = url;
      this.header = {};
      this.writable = true;
      this._redirects = 0;
      this.redirects(5);
      this.cookies = '';
      this.qs = {};
      this._redirectList = [];
      this.on('end', this.clearTimeout.bind(this));
      this.on('response', function(res){
        self.callback(null, res);
      });
    }
    
    /**
     * Inherit from `Stream`.
     */
    
    util.inherits(Request, Stream);
    
    /**
     * Write the field `name` and `val` for "multipart/form-data"
     * request bodies.
     *
     * ``` js
     * request.post('http://localhost/upload')
     *   .field('foo', 'bar')
     *   .end(callback);
     * ```
     *
     * @param {String} name
     * @param {String|Buffer|fs.ReadStream} val
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.field = function(name, val){
      debug('field', name, val);
      if (!this._formData) this._formData = new FormData();
      this._formData.append(name, val);
      return this;
    };
    
    /**
     * Queue the given `file` as an attachment to the specified `field`,
     * with optional `filename`.
     *
     * ``` js
     * request.post('http://localhost/upload')
     *   .attach(new Buffer('<b>Hello world</b>'), 'hello.html')
     *   .end(callback);
     * ```
     *
     * A filename may also be used:
     *
     * ``` js
     * request.post('http://localhost/upload')
     *   .attach('files', 'image.jpg')
     *   .end(callback);
     * ```
     *
     * @param {String} field
     * @param {String|fs.ReadStream|Buffer} file
     * @param {String} filename
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.attach = function(field, file, filename){
      if (!this._formData) this._formData = new FormData();
      if ('string' == typeof file) {
        filename = file;
        debug('creating `fs.ReadStream` instance for file: %s', filename);
        file = fs.createReadStream(filename);
      }
      this._formData.append(field, file, filename);
      return this;
    };
    
    /**
     * Set the max redirects to `n`.
     *
     * @param {Number} n
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.redirects = function(n){
      debug('max redirects %s', n);
      this._maxRedirects = n;
      return this;
    };
    
    /**
     * Return a new `Part` for this request.
     *
     * @return {Part}
     * @api public
     * @deprecated pass a readable stream in to `Request#attach()` instead
     */
    
    Request.prototype.part = util.deprecate(function(){
      return new Part(this);
    }, '`Request#part()` is deprecated. ' +
       'Pass a readable stream in to `Request#attach()` instead.');
    
    /**
     * Gets/sets the `Agent` to use for this HTTP request. The default (if this
     * function is not called) is to opt out of connection pooling (`agent: false`).
     *
     * @param {http.Agent} agent
     * @return {http.Agent}
     * @api public
     */
    
    Request.prototype.agent = function(agent){
      if (!arguments.length) return this._agent;
      this._agent = agent;
      return this;
    };
    
    /**
     * Set header `field` to `val`, or multiple fields with one object.
     *
     * Examples:
     *
     *      req.get('/')
     *        .set('Accept', 'application/json')
     *        .set('X-API-Key', 'foobar')
     *        .end(callback);
     *
     *      req.get('/')
     *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
     *        .end(callback);
     *
     * @param {String|Object} field
     * @param {String} val
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.set = function(field, val){
      if (isObject(field)) {
        for (var key in field) {
          this.set(key, field[key]);
        }
        return this;
      }
    
      debug('set %s "%s"', field, val);
      this.request().setHeader(field, val);
      return this;
    };
    
    /**
     * Remove header `field`.
     *
     * Example:
     *
     *      req.get('/')
     *        .unset('User-Agent')
     *        .end(callback);
     *
     * @param {String} field
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.unset = function(field){
      debug('unset %s', field);
      this.request().removeHeader(field);
      return this;
    };
    
    /**
     * Get request header `field`.
     *
     * @param {String} field
     * @return {String}
     * @api public
     */
    
    Request.prototype.get = function(field){
      return this.request().getHeader(field);
    };
    
    /**
     * Set _Content-Type_ response header passed through `mime.lookup()`.
     *
     * Examples:
     *
     *      request.post('/')
     *        .type('xml')
     *        .send(xmlstring)
     *        .end(callback);
     *
     *      request.post('/')
     *        .type('json')
     *        .send(jsonstring)
     *        .end(callback);
     *
     *      request.post('/')
     *        .type('application/json')
     *        .send(jsonstring)
     *        .end(callback);
     *
     * @param {String} type
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.type = function(type){
      return this.set('Content-Type', ~type.indexOf('/')
        ? type
        : mime.lookup(type));
    };
    
    /**
     * Set _Accept_ response header passed through `mime.lookup()`.
     *
     * Examples:
     *
     *      superagent.types.json = 'application/json';
     *
     *      request.get('/agent')
     *        .accept('json')
     *        .end(callback);
     *
     *      request.get('/agent')
     *        .accept('application/json')
     *        .end(callback);
     *
     * @param {String} accept
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.accept = function(type){
      return this.set('Accept', ~type.indexOf('/')
        ? type
        : mime.lookup(type));
    };
    
    /**
     * Add query-string `val`.
     *
     * Examples:
     *
     *   request.get('/shoes')
     *     .query('size=10')
     *     .query({ color: 'blue' })
     *
     * @param {Object|String} val
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.query = function(val){
      var obj = {};
    
      if ('string' == typeof val) {
        var elements = val.split('&');
        for (var i = 0; i < elements.length; i++) {
          var parts = elements[i].split('=');
          obj[parts[0]] = parts[1];
        }
        return this.query(obj);
      }
    
      extend(this.qs, val);
      return this;
    };
    
    /**
     * Send `data`, defaulting the `.type()` to "json" when
     * an object is given.
     *
     * Examples:
     *
     *       // manual json
     *       request.post('/user')
     *         .type('json')
     *         .send('{"name":"tj"}')
     *         .end(callback)
     *
     *       // auto json
     *       request.post('/user')
     *         .send({ name: 'tj' })
     *         .end(callback)
     *
     *       // manual x-www-form-urlencoded
     *       request.post('/user')
     *         .type('form')
     *         .send('name=tj')
     *         .end(callback)
     *
     *       // auto x-www-form-urlencoded
     *       request.post('/user')
     *         .type('form')
     *         .send({ name: 'tj' })
     *         .end(callback)
     *
     *       // string defaults to x-www-form-urlencoded
     *       request.post('/user')
     *         .send('name=tj')
     *         .send('foo=bar')
     *         .send('bar=baz')
     *         .end(callback)
     *
     * @param {String|Object} data
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.send = function(data){
      var obj = isObject(data);
      var req = this.request();
      var type = req.getHeader('Content-Type');
    
      // merge
      if (obj && isObject(this._data)) {
        for (var key in data) {
          this._data[key] = data[key];
        }
      // string
      } else if ('string' == typeof data) {
        // default to x-www-form-urlencoded
        if (!type) this.type('form');
        type = req.getHeader('Content-Type');
    
        // concat &
        if ('application/x-www-form-urlencoded' == type) {
          this._data = this._data
            ? this._data + '&' + data
            : data;
        } else {
          this._data = (this._data || '') + data;
        }
      } else {
        this._data = data;
      }
    
      if (!obj) return this;
    
      // default to json
      if (!type) this.type('json');
      return this;
    };
    
    /**
     * Write raw `data` / `encoding` to the socket.
     *
     * @param {Buffer|String} data
     * @param {String} encoding
     * @return {Boolean}
     * @api public
     */
    
    Request.prototype.write = function(data, encoding){
      return this.request().write(data, encoding);
    };
    
    /**
     * Pipe the request body to `stream`.
     *
     * @param {Stream} stream
     * @param {Object} options
     * @return {Stream}
     * @api public
     */
    
    Request.prototype.pipe = function(stream, options){
      this.piped = true; // HACK...
      this.buffer(false);
      this.end().req.on('response', function(res){
        if (/^(deflate|gzip)$/.test(res.headers['content-encoding'])) {
          res.pipe(zlib.createUnzip()).pipe(stream, options);
        } else {
          res.pipe(stream, options);
        }
      });
      return stream;
    };
    
    /**
     * Enable / disable buffering.
     *
     * @return {Boolean} [val]
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.buffer = function(val){
      this._buffer = false === val
        ? false
        : true;
      return this;
    };
    
    /**
     * Set timeout to `ms`.
     *
     * @param {Number} ms
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.timeout = function(ms){
      this._timeout = ms;
      return this;
    };
    
    /**
     * Clear previous timeout.
     *
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.clearTimeout = function(){
      debug('clear timeout %s %s', this.method, this.url);
      this._timeout = 0;
      clearTimeout(this._timer);
      return this;
    };
    
    /**
     * Abort and clear timeout.
     *
     * @api public
     */
    
    Request.prototype.abort = function(){
      debug('abort %s %s', this.method, this.url);
      this._aborted = true;
      this.clearTimeout();
      this.req.abort();
      this.emit('abort');
    };
    
    /**
     * Define the parser to be used for this response.
     *
     * @param {Function} fn
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.parse = function(fn){
      this._parser = fn;
      return this;
    };
    
    /**
     * Redirect to `url
     *
     * @param {IncomingMessage} res
     * @return {Request} for chaining
     * @api private
     */
    
    Request.prototype.redirect = function(res){
      var url = res.headers.location;
      debug('redirect %s -> %s', this.url, url);
    
      // location
      if (!~url.indexOf('://')) {
        if (0 != url.indexOf('//')) {
          url = '//' + this.host + url;
        }
        url = this.protocol + url;
      }
    
      // ensure the response is being consumed
      // this is required for Node v0.10+
      res.resume();
    
      // strip Content-* related fields
      // in case of POST etc
      var header = utils.cleanHeader(this.req._headers);
      delete this.req;
    
      // force GET
      this.method = 'HEAD' == this.method
        ? 'HEAD'
        : 'GET';
    
      // redirect
      this._data = null;
      this.url = url;
      this._redirectList.push(url);
      this.clearTimeout();
      this.emit('redirect', res);
      this.set(header);
      this.end(this._callback);
      return this;
    };
    
    /**
     * Set Authorization field value with `user` and `pass`.
     *
     * Examples:
     *
     *   .auth('tobi', 'learnboost')
     *   .auth('tobi:learnboost')
     *   .auth('tobi')
     *
     * @param {String} user
     * @param {String} pass
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.auth = function(user, pass){
      if (1 === arguments.length) pass = '';
      if (!~user.indexOf(':')) user = user + ':';
      var str = new Buffer(user + pass).toString('base64');
      return this.set('Authorization', 'Basic ' + str);
    };
    
    /**
     * Set the certificate authority option for https request.
     *
     * @param {Buffer | Array} cert
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.ca = function(cert){
      this._ca = cert;
      return this;
    };
    
    /**
     * Allow for extension
     */
    
    Request.prototype.use = function(fn) {
      fn(this);
      return this;
    };
    
    /**
     * Return an http[s] request.
     *
     * @return {OutgoingMessage}
     * @api private
     */
    
    Request.prototype.request = function(){
      if (this.req) return this.req;
    
      var self = this;
      var options = {};
      var data = this._data;
      var url = this.url;
    
      // default to http://
      if (0 != url.indexOf('http')) url = 'http://' + url;
      url = parse(url, true);
    
      // options
      options.method = this.method;
      options.port = url.port;
      options.path = url.pathname;
      options.host = url.hostname;
      options.ca = this._ca;
      options.agent = this._agent;
    
      // initiate request
      var mod = exports.protocols[url.protocol];
    
      // request
      var req = this.req = mod.request(options);
      if ('HEAD' != options.method) req.setHeader('Accept-Encoding', 'gzip, deflate');
      this.protocol = url.protocol;
      this.host = url.host;
    
      // expose events
      req.on('drain', function(){ self.emit('drain'); });
    
      req.on('error', function(err){
        // flag abortion here for out timeouts
        // because node will emit a faux-error "socket hang up"
        // when request is aborted before a connection is made
        if (self._aborted) return;
        self.callback(err);
      });
    
      // auth
      if (url.auth) {
        var auth = url.auth.split(':');
        this.auth(auth[0], auth[1]);
      }
    
      // query
      this.query(url.query);
    
      // add cookies
      if (this.cookies) req.setHeader('Cookie', this.cookies);
    
      // set default UA
      req.setHeader('User-Agent', 'node-superagent/' + pkg.version);
    
      return req;
    };
    
    /**
     * Invoke the callback with `err` and `res`
     * and handle arity check.
     *
     * @param {Error} err
     * @param {Response} res
     * @api private
     */
    
    Request.prototype.callback = function(err, res){
      var fn = this._callback;
      this.clearTimeout();
      if (this.called) return console.warn('double callback!');
      this.called = true;
      if (2 == fn.length) return fn(err, res);
      if (err) return this.emit('error', err);
      fn(res);
    };
    
    /**
     * Initiate request, invoking callback `fn(err, res)`
     * with an instanceof `Response`.
     *
     * @param {Function} fn
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.end = function(fn){
      var self = this;
      var data = this._data;
      var req = this.request();
      var buffer = this._buffer;
      var method = this.method;
      var timeout = this._timeout;
      debug('%s %s', this.method, this.url);
    
      // store callback
      this._callback = fn || noop;
    
      // querystring
      try {
        var querystring = qs.stringify(this.qs);
        req.path += querystring.length
          ? (~req.path.indexOf('?') ? '&' : '?') + querystring
          : '';
      } catch (e) {
        return this.callback(e);
      }
    
      // timeout
      if (timeout && !this._timer) {
        debug('timeout %sms %s %s', timeout, this.method, this.url);
        this._timer = setTimeout(function(){
          var err = new Error('timeout of ' + timeout + 'ms exceeded');
          err.timeout = timeout;
          self.abort();
          self.callback(err);
        }, timeout);
      }
    
      // body
      if ('HEAD' != method && !req._headerSent) {
        // serialize stuff
        if ('string' != typeof data) {
          var contentType = req.getHeader('Content-Type')
          // Parse out just the content type from the header (ignore the charset)
          if (contentType) contentType = contentType.split(';')[0]
          var serialize = exports.serialize[contentType];
          if (serialize) data = serialize(data);
        }
    
        // content-length
        if (data && !req.getHeader('Content-Length')) {
          this.set('Content-Length', Buffer.byteLength(data));
        }
      }
    
      // response
      req.on('response', function(res){
        debug('%s %s -> %s', self.method, self.url, res.statusCode);
        var max = self._maxRedirects;
        var mime = utils.type(res.headers['content-type'] || '');
        var len = res.headers['content-length'];
        var type = mime.split('/');
        var subtype = type[1];
        var type = type[0];
        var multipart = 'multipart' == type;
        var redirect = isRedirect(res.statusCode);
        var parser = self._parser;
    
        self.res = res;
    
        if ('HEAD' == self.method) {
          var response = new Response(self);
          self.response = response;
          response.redirects = self._redirectList;
          self.emit('response', response);
          self.emit('end');
          return;
        }
    
        if (self.piped) {
          res.on('end', function(){
            self.emit('end');
          });
          return;
        }
    
        // redirect
        if (redirect && self._redirects++ != max) {
          return self.redirect(res);
        }
    
        // zlib support
        if (/^(deflate|gzip)$/.test(res.headers['content-encoding'])) {
          utils.unzip(req, res);
        }
    
        // don't buffer multipart
        if (multipart) buffer = false;
    
        // TODO: make all parsers take callbacks
        if (!parser && multipart) {
          var form = new formidable.IncomingForm;
    
          form.parse(res, function(err, fields, files){
            if (err) return self.callback(err);
            var response = new Response(self);
            self.response = response;
            response.body = fields;
            response.files = files;
            response.redirects = self._redirectList;
            self.emit('end');
            self.callback(null, response);
          });
          return;
        }
    
        // check for images, one more special treatment
        if (!parser && isImage(mime)) {
          exports.parse.image(res, function(err, obj){
            if (err) return self.callback(err);
            var response = new Response(self);
            self.response = response;
            response.body = obj;
            response.redirects = self._redirectList;
            self.emit('end');
            self.callback(null, response);
          });
          return;
        }
    
        // by default only buffer text/*, json
        // and messed up thing from hell
        var text = isText(mime);
        if (null == buffer && text) buffer = true;
    
        // parser
        var parse = 'text' == type
          ? exports.parse.text
          : exports.parse[mime];
    
        // buffered response
        if (buffer) parse = parse || exports.parse.text;
    
        // explicit parser
        if (parser) parse = parser;
    
        // parse
        if (parse) {
          try {
            parse(res, function(err, obj){
              if (err) self.callback(err);
              res.body = obj;
            });
          } catch(err) {
            self.callback(err);
            return;
          }
        }
    
        // unbuffered
        if (!buffer) {
          debug('unbuffered %s %s', self.method, self.url);
          self.res = res;
          var response = new Response(self);
          self.response = response;
          response.redirects = self._redirectList;
          self.emit('response', response);
          if (multipart) return // allow multipart to handle end event
          res.on('end', function(){
            debug('end %s %s', self.method, self.url);
            self.emit('end');
          })
          return;
        }
    
        // end event
        self.res = res;
        res.on('end', function(){
          debug('end %s %s', self.method, self.url);
          // TODO: unless buffering emit earlier to stream
          var response = new Response(self);
          self.response = response;
          response.redirects = self._redirectList;
          self.emit('response', response);
          self.emit('end');
        });
      });
    
      this.emit('request', this);
    
      // if a FormData instance got created, then we send that as the request body
      var formData = this._formData;
      if (formData) {
    
        // set headers
        var headers = formData.getHeaders();
        for (var i in headers) {
          debug('setting FormData header: "%s: %s"', i, headers[i]);
          req.setHeader(i, headers[i]);
        }
    
        // attempt to get "Content-Length" header
        formData.getLength(function(err, length) {
          // TODO: Add chunked encoding when no length (if err)
    
          debug('got FormData Content-Length: %s', length);
          if ('number' == typeof length) {
            req.setHeader('Content-Length', length);
          }
    
          formData.pipe(req);
        });
      } else {
        req.end(data);
      }
    
      return this;
    };
    
    /**
     * To json.
     *
     * @return {Object}
     * @api public
     */
    
    Request.prototype.toJSON = function(){
      return {
        method: this.method,
        url: this.url,
        data: this._data
      };
    };
    
    /**
     * Expose `Request`.
     */
    
    exports.Request = Request;
    
    /**
     * Issue a request:
     *
     * Examples:
     *
     *    request('GET', '/users').end(callback)
     *    request('/users').end(callback)
     *    request('/users', callback)
     *
     * @param {String} method
     * @param {String|Function} url or callback
     * @return {Request}
     * @api public
     */
    
    function request(method, url) {
      // callback
      if ('function' == typeof url) {
        return new Request('GET', method).end(url);
      }
    
      // url first
      if (1 == arguments.length) {
        return new Request('GET', method);
      }
    
      return new Request(method, url);
    }
    
    // generate HTTP verb methods
    
    methods.forEach(function(method){
      var name = 'delete' == method ? 'del' : method;
      method = method.toUpperCase();
      request[name] = function(url, fn){
        var req = request(method, url);
        fn && req.end(fn);
        return req;
      };
    });
    
    /**
     * Check if `mime` is text and should be buffered.
     *
     * @param {String} mime
     * @return {Boolean}
     * @api public
     */
    
    function isText(mime) {
      var parts = mime.split('/');
      var type = parts[0];
      var subtype = parts[1];
    
      return 'text' == type
        || 'json' == subtype
        || 'x-www-form-urlencoded' == subtype;
    }
    
    /**
     * Check if `mime` is image
     *
     * @param {String} mime
     * @return {Boolean}
     * @api public
     */
    
    function isImage(mime) {
      var parts = mime.split('/');
      var type = parts[0];
      var subtype = parts[1];
    
      return 'image' == type;
    }
    
    /**
     * Check if we should follow the redirect `code`.
     *
     * @param {Number} code
     * @return {Boolean}
     * @api private
     */
    
    function isRedirect(code) {
      return ~[301, 302, 303, 305, 307].indexOf(code);
    }
    
  provide("superagent/lib/node/index", module.exports);
}(global));

// pakmanager:superagent/lib/node/agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var CookieJar = require('cookiejar').CookieJar;
    var CookieAccess = require('cookiejar').CookieAccessInfo;
    var parse = require('url').parse;
    var request =  require('superagent/lib/node/index');
    var methods = require('methods');
    
    /**
     * Expose `Agent`.
     */
    
    module.exports = Agent;
    
    /**
     * Initialize a new `Agent`.
     *
     * @api public
     */
    
    function Agent(options) {
      if (!(this instanceof Agent)) return new Agent(options);
      if (options) this._ca = options.ca;
      this.jar = new CookieJar;
    }
    
    /**
     * Save the cookies in the given `res` to
     * the agent's cookie jar for persistence.
     *
     * @param {Response} res
     * @api private
     */
    
    Agent.prototype.saveCookies = function(res){
      var cookies = res.headers['set-cookie'];
      if (cookies) this.jar.setCookies(cookies);
    };
    
    /**
     * Attach cookies when available to the given `req`.
     *
     * @param {Request} req
     * @api private
     */
    
    Agent.prototype.attachCookies = function(req){
      var url = parse(req.url);
      var access = CookieAccess(url.hostname, url.pathname, 'https:' == url.protocol);
      var cookies = this.jar.getCookies(access).toValueString();
      req.cookies = cookies;
    };
    
    // generate HTTP verb methods
    
    methods.forEach(function(method){
      var name = 'delete' == method ? 'del' : method;
    
      method = method.toUpperCase();
      Agent.prototype[name] = function(url, fn){
        var req = request(method, url);
        req.ca(this._ca);
    
        req.on('response', this.saveCookies.bind(this));
        req.on('redirect', this.saveCookies.bind(this));
        req.on('redirect', this.attachCookies.bind(this, req));
        this.attachCookies(req);
    
        fn && req.end(fn);
        return req;
      };
    });
    
  provide("superagent/lib/node/agent", module.exports);
}(global));

// pakmanager:superagent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var debug = require('debug')('superagent');
    var formidable = require('formidable');
    var FormData = require('form-data');
    var Response =  require('superagent/lib/node/response');
    var parse = require('url').parse;
    var format = require('url').format;
    var methods = require('methods');
    var Stream = require('stream');
    var utils =  require('superagent/lib/node/utils');
    var extend = require('extend');
    var Part =  require('superagent/lib/node/part');
    var mime = require('mime');
    var https = require('https');
    var http = require('http');
    var fs = require('fs');
    var qs = require('qs');
    var zlib = require('zlib');
    var util = require('util');
    var pkg = require('../../package.json');
    
    /**
     * Expose the request function.
     */
    
    exports = module.exports = request;
    
    /**
     * Expose the agent function
     */
    
    exports.agent =  require('superagent/lib/node/agent');
    
    /**
     * Expose `Part`.
     */
    
    exports.Part = Part;
    
    /**
     * Noop.
     */
    
    function noop(){};
    
    /**
     * Expose `Response`.
     */
    
    exports.Response = Response;
    
    /**
     * Define "form" mime type.
     */
    
    mime.define({
      'application/x-www-form-urlencoded': ['form', 'urlencoded', 'form-data']
    });
    
    /**
     * Protocol map.
     */
    
    exports.protocols = {
      'http:': http,
      'https:': https
    };
    
    /**
     * Check if `obj` is an object.
     *
     * @param {Object} obj
     * @return {Boolean}
     * @api private
     */
    
    function isObject(obj) {
      return null != obj && 'object' == typeof obj;
    }
    
    /**
     * Default serialization map.
     *
     *     superagent.serialize['application/xml'] = function(obj){
     *       return 'generated xml here';
     *     };
     *
     */
    
    exports.serialize = {
      'application/x-www-form-urlencoded': qs.stringify,
      'application/json': JSON.stringify
    };
    
    /**
     * Default parsers.
     *
     *     superagent.parse['application/xml'] = function(res, fn){
     *       fn(null, result);
     *     };
     *
     */
    
    exports.parse =  require('superagent/lib/node/parsers');
    
    /**
     * Initialize a new `Request` with the given `method` and `url`.
     *
     * @param {String} method
     * @param {String|Object} url
     * @api public
     */
    
    function Request(method, url) {
      Stream.call(this);
      var self = this;
      if ('string' != typeof url) url = format(url);
      this._agent = false;
      this._formData = null;
      this.method = method;
      this.url = url;
      this.header = {};
      this.writable = true;
      this._redirects = 0;
      this.redirects(5);
      this.cookies = '';
      this.qs = {};
      this._redirectList = [];
      this.on('end', this.clearTimeout.bind(this));
      this.on('response', function(res){
        self.callback(null, res);
      });
    }
    
    /**
     * Inherit from `Stream`.
     */
    
    util.inherits(Request, Stream);
    
    /**
     * Write the field `name` and `val` for "multipart/form-data"
     * request bodies.
     *
     * ``` js
     * request.post('http://localhost/upload')
     *   .field('foo', 'bar')
     *   .end(callback);
     * ```
     *
     * @param {String} name
     * @param {String|Buffer|fs.ReadStream} val
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.field = function(name, val){
      debug('field', name, val);
      if (!this._formData) this._formData = new FormData();
      this._formData.append(name, val);
      return this;
    };
    
    /**
     * Queue the given `file` as an attachment to the specified `field`,
     * with optional `filename`.
     *
     * ``` js
     * request.post('http://localhost/upload')
     *   .attach(new Buffer('<b>Hello world</b>'), 'hello.html')
     *   .end(callback);
     * ```
     *
     * A filename may also be used:
     *
     * ``` js
     * request.post('http://localhost/upload')
     *   .attach('files', 'image.jpg')
     *   .end(callback);
     * ```
     *
     * @param {String} field
     * @param {String|fs.ReadStream|Buffer} file
     * @param {String} filename
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.attach = function(field, file, filename){
      if (!this._formData) this._formData = new FormData();
      if ('string' == typeof file) {
        filename = file;
        debug('creating `fs.ReadStream` instance for file: %s', filename);
        file = fs.createReadStream(filename);
      }
      this._formData.append(field, file, filename);
      return this;
    };
    
    /**
     * Set the max redirects to `n`.
     *
     * @param {Number} n
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.redirects = function(n){
      debug('max redirects %s', n);
      this._maxRedirects = n;
      return this;
    };
    
    /**
     * Return a new `Part` for this request.
     *
     * @return {Part}
     * @api public
     * @deprecated pass a readable stream in to `Request#attach()` instead
     */
    
    Request.prototype.part = util.deprecate(function(){
      return new Part(this);
    }, '`Request#part()` is deprecated. ' +
       'Pass a readable stream in to `Request#attach()` instead.');
    
    /**
     * Gets/sets the `Agent` to use for this HTTP request. The default (if this
     * function is not called) is to opt out of connection pooling (`agent: false`).
     *
     * @param {http.Agent} agent
     * @return {http.Agent}
     * @api public
     */
    
    Request.prototype.agent = function(agent){
      if (!arguments.length) return this._agent;
      this._agent = agent;
      return this;
    };
    
    /**
     * Set header `field` to `val`, or multiple fields with one object.
     *
     * Examples:
     *
     *      req.get('/')
     *        .set('Accept', 'application/json')
     *        .set('X-API-Key', 'foobar')
     *        .end(callback);
     *
     *      req.get('/')
     *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
     *        .end(callback);
     *
     * @param {String|Object} field
     * @param {String} val
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.set = function(field, val){
      if (isObject(field)) {
        for (var key in field) {
          this.set(key, field[key]);
        }
        return this;
      }
    
      debug('set %s "%s"', field, val);
      this.request().setHeader(field, val);
      return this;
    };
    
    /**
     * Remove header `field`.
     *
     * Example:
     *
     *      req.get('/')
     *        .unset('User-Agent')
     *        .end(callback);
     *
     * @param {String} field
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.unset = function(field){
      debug('unset %s', field);
      this.request().removeHeader(field);
      return this;
    };
    
    /**
     * Get request header `field`.
     *
     * @param {String} field
     * @return {String}
     * @api public
     */
    
    Request.prototype.get = function(field){
      return this.request().getHeader(field);
    };
    
    /**
     * Set _Content-Type_ response header passed through `mime.lookup()`.
     *
     * Examples:
     *
     *      request.post('/')
     *        .type('xml')
     *        .send(xmlstring)
     *        .end(callback);
     *
     *      request.post('/')
     *        .type('json')
     *        .send(jsonstring)
     *        .end(callback);
     *
     *      request.post('/')
     *        .type('application/json')
     *        .send(jsonstring)
     *        .end(callback);
     *
     * @param {String} type
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.type = function(type){
      return this.set('Content-Type', ~type.indexOf('/')
        ? type
        : mime.lookup(type));
    };
    
    /**
     * Set _Accept_ response header passed through `mime.lookup()`.
     *
     * Examples:
     *
     *      superagent.types.json = 'application/json';
     *
     *      request.get('/agent')
     *        .accept('json')
     *        .end(callback);
     *
     *      request.get('/agent')
     *        .accept('application/json')
     *        .end(callback);
     *
     * @param {String} accept
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.accept = function(type){
      return this.set('Accept', ~type.indexOf('/')
        ? type
        : mime.lookup(type));
    };
    
    /**
     * Add query-string `val`.
     *
     * Examples:
     *
     *   request.get('/shoes')
     *     .query('size=10')
     *     .query({ color: 'blue' })
     *
     * @param {Object|String} val
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.query = function(val){
      var obj = {};
    
      if ('string' == typeof val) {
        var elements = val.split('&');
        for (var i = 0; i < elements.length; i++) {
          var parts = elements[i].split('=');
          obj[parts[0]] = parts[1];
        }
        return this.query(obj);
      }
    
      extend(this.qs, val);
      return this;
    };
    
    /**
     * Send `data`, defaulting the `.type()` to "json" when
     * an object is given.
     *
     * Examples:
     *
     *       // manual json
     *       request.post('/user')
     *         .type('json')
     *         .send('{"name":"tj"}')
     *         .end(callback)
     *
     *       // auto json
     *       request.post('/user')
     *         .send({ name: 'tj' })
     *         .end(callback)
     *
     *       // manual x-www-form-urlencoded
     *       request.post('/user')
     *         .type('form')
     *         .send('name=tj')
     *         .end(callback)
     *
     *       // auto x-www-form-urlencoded
     *       request.post('/user')
     *         .type('form')
     *         .send({ name: 'tj' })
     *         .end(callback)
     *
     *       // string defaults to x-www-form-urlencoded
     *       request.post('/user')
     *         .send('name=tj')
     *         .send('foo=bar')
     *         .send('bar=baz')
     *         .end(callback)
     *
     * @param {String|Object} data
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.send = function(data){
      var obj = isObject(data);
      var req = this.request();
      var type = req.getHeader('Content-Type');
    
      // merge
      if (obj && isObject(this._data)) {
        for (var key in data) {
          this._data[key] = data[key];
        }
      // string
      } else if ('string' == typeof data) {
        // default to x-www-form-urlencoded
        if (!type) this.type('form');
        type = req.getHeader('Content-Type');
    
        // concat &
        if ('application/x-www-form-urlencoded' == type) {
          this._data = this._data
            ? this._data + '&' + data
            : data;
        } else {
          this._data = (this._data || '') + data;
        }
      } else {
        this._data = data;
      }
    
      if (!obj) return this;
    
      // default to json
      if (!type) this.type('json');
      return this;
    };
    
    /**
     * Write raw `data` / `encoding` to the socket.
     *
     * @param {Buffer|String} data
     * @param {String} encoding
     * @return {Boolean}
     * @api public
     */
    
    Request.prototype.write = function(data, encoding){
      return this.request().write(data, encoding);
    };
    
    /**
     * Pipe the request body to `stream`.
     *
     * @param {Stream} stream
     * @param {Object} options
     * @return {Stream}
     * @api public
     */
    
    Request.prototype.pipe = function(stream, options){
      this.piped = true; // HACK...
      this.buffer(false);
      this.end().req.on('response', function(res){
        if (/^(deflate|gzip)$/.test(res.headers['content-encoding'])) {
          res.pipe(zlib.createUnzip()).pipe(stream, options);
        } else {
          res.pipe(stream, options);
        }
      });
      return stream;
    };
    
    /**
     * Enable / disable buffering.
     *
     * @return {Boolean} [val]
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.buffer = function(val){
      this._buffer = false === val
        ? false
        : true;
      return this;
    };
    
    /**
     * Set timeout to `ms`.
     *
     * @param {Number} ms
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.timeout = function(ms){
      this._timeout = ms;
      return this;
    };
    
    /**
     * Clear previous timeout.
     *
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.clearTimeout = function(){
      debug('clear timeout %s %s', this.method, this.url);
      this._timeout = 0;
      clearTimeout(this._timer);
      return this;
    };
    
    /**
     * Abort and clear timeout.
     *
     * @api public
     */
    
    Request.prototype.abort = function(){
      debug('abort %s %s', this.method, this.url);
      this._aborted = true;
      this.clearTimeout();
      this.req.abort();
      this.emit('abort');
    };
    
    /**
     * Define the parser to be used for this response.
     *
     * @param {Function} fn
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.parse = function(fn){
      this._parser = fn;
      return this;
    };
    
    /**
     * Redirect to `url
     *
     * @param {IncomingMessage} res
     * @return {Request} for chaining
     * @api private
     */
    
    Request.prototype.redirect = function(res){
      var url = res.headers.location;
      debug('redirect %s -> %s', this.url, url);
    
      // location
      if (!~url.indexOf('://')) {
        if (0 != url.indexOf('//')) {
          url = '//' + this.host + url;
        }
        url = this.protocol + url;
      }
    
      // ensure the response is being consumed
      // this is required for Node v0.10+
      res.resume();
    
      // strip Content-* related fields
      // in case of POST etc
      var header = utils.cleanHeader(this.req._headers);
      delete this.req;
    
      // force GET
      this.method = 'HEAD' == this.method
        ? 'HEAD'
        : 'GET';
    
      // redirect
      this._data = null;
      this.url = url;
      this._redirectList.push(url);
      this.clearTimeout();
      this.emit('redirect', res);
      this.set(header);
      this.end(this._callback);
      return this;
    };
    
    /**
     * Set Authorization field value with `user` and `pass`.
     *
     * Examples:
     *
     *   .auth('tobi', 'learnboost')
     *   .auth('tobi:learnboost')
     *   .auth('tobi')
     *
     * @param {String} user
     * @param {String} pass
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.auth = function(user, pass){
      if (1 === arguments.length) pass = '';
      if (!~user.indexOf(':')) user = user + ':';
      var str = new Buffer(user + pass).toString('base64');
      return this.set('Authorization', 'Basic ' + str);
    };
    
    /**
     * Set the certificate authority option for https request.
     *
     * @param {Buffer | Array} cert
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.ca = function(cert){
      this._ca = cert;
      return this;
    };
    
    /**
     * Allow for extension
     */
    
    Request.prototype.use = function(fn) {
      fn(this);
      return this;
    };
    
    /**
     * Return an http[s] request.
     *
     * @return {OutgoingMessage}
     * @api private
     */
    
    Request.prototype.request = function(){
      if (this.req) return this.req;
    
      var self = this;
      var options = {};
      var data = this._data;
      var url = this.url;
    
      // default to http://
      if (0 != url.indexOf('http')) url = 'http://' + url;
      url = parse(url, true);
    
      // options
      options.method = this.method;
      options.port = url.port;
      options.path = url.pathname;
      options.host = url.hostname;
      options.ca = this._ca;
      options.agent = this._agent;
    
      // initiate request
      var mod = exports.protocols[url.protocol];
    
      // request
      var req = this.req = mod.request(options);
      if ('HEAD' != options.method) req.setHeader('Accept-Encoding', 'gzip, deflate');
      this.protocol = url.protocol;
      this.host = url.host;
    
      // expose events
      req.on('drain', function(){ self.emit('drain'); });
    
      req.on('error', function(err){
        // flag abortion here for out timeouts
        // because node will emit a faux-error "socket hang up"
        // when request is aborted before a connection is made
        if (self._aborted) return;
        self.callback(err);
      });
    
      // auth
      if (url.auth) {
        var auth = url.auth.split(':');
        this.auth(auth[0], auth[1]);
      }
    
      // query
      this.query(url.query);
    
      // add cookies
      if (this.cookies) req.setHeader('Cookie', this.cookies);
    
      // set default UA
      req.setHeader('User-Agent', 'node-superagent/' + pkg.version);
    
      return req;
    };
    
    /**
     * Invoke the callback with `err` and `res`
     * and handle arity check.
     *
     * @param {Error} err
     * @param {Response} res
     * @api private
     */
    
    Request.prototype.callback = function(err, res){
      var fn = this._callback;
      this.clearTimeout();
      if (this.called) return console.warn('double callback!');
      this.called = true;
      if (2 == fn.length) return fn(err, res);
      if (err) return this.emit('error', err);
      fn(res);
    };
    
    /**
     * Initiate request, invoking callback `fn(err, res)`
     * with an instanceof `Response`.
     *
     * @param {Function} fn
     * @return {Request} for chaining
     * @api public
     */
    
    Request.prototype.end = function(fn){
      var self = this;
      var data = this._data;
      var req = this.request();
      var buffer = this._buffer;
      var method = this.method;
      var timeout = this._timeout;
      debug('%s %s', this.method, this.url);
    
      // store callback
      this._callback = fn || noop;
    
      // querystring
      try {
        var querystring = qs.stringify(this.qs);
        req.path += querystring.length
          ? (~req.path.indexOf('?') ? '&' : '?') + querystring
          : '';
      } catch (e) {
        return this.callback(e);
      }
    
      // timeout
      if (timeout && !this._timer) {
        debug('timeout %sms %s %s', timeout, this.method, this.url);
        this._timer = setTimeout(function(){
          var err = new Error('timeout of ' + timeout + 'ms exceeded');
          err.timeout = timeout;
          self.abort();
          self.callback(err);
        }, timeout);
      }
    
      // body
      if ('HEAD' != method && !req._headerSent) {
        // serialize stuff
        if ('string' != typeof data) {
          var contentType = req.getHeader('Content-Type')
          // Parse out just the content type from the header (ignore the charset)
          if (contentType) contentType = contentType.split(';')[0]
          var serialize = exports.serialize[contentType];
          if (serialize) data = serialize(data);
        }
    
        // content-length
        if (data && !req.getHeader('Content-Length')) {
          this.set('Content-Length', Buffer.byteLength(data));
        }
      }
    
      // response
      req.on('response', function(res){
        debug('%s %s -> %s', self.method, self.url, res.statusCode);
        var max = self._maxRedirects;
        var mime = utils.type(res.headers['content-type'] || '');
        var len = res.headers['content-length'];
        var type = mime.split('/');
        var subtype = type[1];
        var type = type[0];
        var multipart = 'multipart' == type;
        var redirect = isRedirect(res.statusCode);
        var parser = self._parser;
    
        self.res = res;
    
        if ('HEAD' == self.method) {
          var response = new Response(self);
          self.response = response;
          response.redirects = self._redirectList;
          self.emit('response', response);
          self.emit('end');
          return;
        }
    
        if (self.piped) {
          res.on('end', function(){
            self.emit('end');
          });
          return;
        }
    
        // redirect
        if (redirect && self._redirects++ != max) {
          return self.redirect(res);
        }
    
        // zlib support
        if (/^(deflate|gzip)$/.test(res.headers['content-encoding'])) {
          utils.unzip(req, res);
        }
    
        // don't buffer multipart
        if (multipart) buffer = false;
    
        // TODO: make all parsers take callbacks
        if (!parser && multipart) {
          var form = new formidable.IncomingForm;
    
          form.parse(res, function(err, fields, files){
            if (err) return self.callback(err);
            var response = new Response(self);
            self.response = response;
            response.body = fields;
            response.files = files;
            response.redirects = self._redirectList;
            self.emit('end');
            self.callback(null, response);
          });
          return;
        }
    
        // check for images, one more special treatment
        if (!parser && isImage(mime)) {
          exports.parse.image(res, function(err, obj){
            if (err) return self.callback(err);
            var response = new Response(self);
            self.response = response;
            response.body = obj;
            response.redirects = self._redirectList;
            self.emit('end');
            self.callback(null, response);
          });
          return;
        }
    
        // by default only buffer text/*, json
        // and messed up thing from hell
        var text = isText(mime);
        if (null == buffer && text) buffer = true;
    
        // parser
        var parse = 'text' == type
          ? exports.parse.text
          : exports.parse[mime];
    
        // buffered response
        if (buffer) parse = parse || exports.parse.text;
    
        // explicit parser
        if (parser) parse = parser;
    
        // parse
        if (parse) {
          try {
            parse(res, function(err, obj){
              if (err) self.callback(err);
              res.body = obj;
            });
          } catch(err) {
            self.callback(err);
            return;
          }
        }
    
        // unbuffered
        if (!buffer) {
          debug('unbuffered %s %s', self.method, self.url);
          self.res = res;
          var response = new Response(self);
          self.response = response;
          response.redirects = self._redirectList;
          self.emit('response', response);
          if (multipart) return // allow multipart to handle end event
          res.on('end', function(){
            debug('end %s %s', self.method, self.url);
            self.emit('end');
          })
          return;
        }
    
        // end event
        self.res = res;
        res.on('end', function(){
          debug('end %s %s', self.method, self.url);
          // TODO: unless buffering emit earlier to stream
          var response = new Response(self);
          self.response = response;
          response.redirects = self._redirectList;
          self.emit('response', response);
          self.emit('end');
        });
      });
    
      this.emit('request', this);
    
      // if a FormData instance got created, then we send that as the request body
      var formData = this._formData;
      if (formData) {
    
        // set headers
        var headers = formData.getHeaders();
        for (var i in headers) {
          debug('setting FormData header: "%s: %s"', i, headers[i]);
          req.setHeader(i, headers[i]);
        }
    
        // attempt to get "Content-Length" header
        formData.getLength(function(err, length) {
          // TODO: Add chunked encoding when no length (if err)
    
          debug('got FormData Content-Length: %s', length);
          if ('number' == typeof length) {
            req.setHeader('Content-Length', length);
          }
    
          formData.pipe(req);
        });
      } else {
        req.end(data);
      }
    
      return this;
    };
    
    /**
     * To json.
     *
     * @return {Object}
     * @api public
     */
    
    Request.prototype.toJSON = function(){
      return {
        method: this.method,
        url: this.url,
        data: this._data
      };
    };
    
    /**
     * Expose `Request`.
     */
    
    exports.Request = Request;
    
    /**
     * Issue a request:
     *
     * Examples:
     *
     *    request('GET', '/users').end(callback)
     *    request('/users').end(callback)
     *    request('/users', callback)
     *
     * @param {String} method
     * @param {String|Function} url or callback
     * @return {Request}
     * @api public
     */
    
    function request(method, url) {
      // callback
      if ('function' == typeof url) {
        return new Request('GET', method).end(url);
      }
    
      // url first
      if (1 == arguments.length) {
        return new Request('GET', method);
      }
    
      return new Request(method, url);
    }
    
    // generate HTTP verb methods
    
    methods.forEach(function(method){
      var name = 'delete' == method ? 'del' : method;
      method = method.toUpperCase();
      request[name] = function(url, fn){
        var req = request(method, url);
        fn && req.end(fn);
        return req;
      };
    });
    
    /**
     * Check if `mime` is text and should be buffered.
     *
     * @param {String} mime
     * @return {Boolean}
     * @api public
     */
    
    function isText(mime) {
      var parts = mime.split('/');
      var type = parts[0];
      var subtype = parts[1];
    
      return 'text' == type
        || 'json' == subtype
        || 'x-www-form-urlencoded' == subtype;
    }
    
    /**
     * Check if `mime` is image
     *
     * @param {String} mime
     * @return {Boolean}
     * @api public
     */
    
    function isImage(mime) {
      var parts = mime.split('/');
      var type = parts[0];
      var subtype = parts[1];
    
      return 'image' == type;
    }
    
    /**
     * Check if we should follow the redirect `code`.
     *
     * @param {Number} code
     * @return {Boolean}
     * @api private
     */
    
    function isRedirect(code) {
      return ~[301, 302, 303, 305, 307].indexOf(code);
    }
    
  provide("superagent", module.exports);
}(global));

// pakmanager:assert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
    //
    // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
    //
    // Originally from narwhal.js (http://narwhaljs.org)
    // Copyright (c) 2009 Thomas Robinson <280north.com>
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the 'Software'), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // when used in node, this will actually load the util module we depend on
    // versus loading the builtin util module as happens otherwise
    // this is a bug in node module loading as far as I am concerned
    var util = require('util/');
    
    var pSlice = Array.prototype.slice;
    var hasOwn = Object.prototype.hasOwnProperty;
    
    // 1. The assert module provides functions that throw
    // AssertionError's when particular conditions are not met. The
    // assert module must conform to the following interface.
    
    var assert = module.exports = ok;
    
    // 2. The AssertionError is defined in assert.
    // new assert.AssertionError({ message: message,
    //                             actual: actual,
    //                             expected: expected })
    
    assert.AssertionError = function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }
      var stackStartFunction = options.stackStartFunction || fail;
    
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      }
      else {
        // non v8 browsers so we can have a stacktrace
        var err = new Error();
        if (err.stack) {
          var out = err.stack;
    
          // try to strip useless frames
          var fn_name = stackStartFunction.name;
          var idx = out.indexOf('\n' + fn_name);
          if (idx >= 0) {
            // once we have located the function frame
            // we need to strip out everything before it (and its line)
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }
    
          this.stack = out;
        }
      }
    };
    
    // assert.AssertionError instanceof Error
    util.inherits(assert.AssertionError, Error);
    
    function replacer(key, value) {
      if (util.isUndefined(value)) {
        return '' + value;
      }
      if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
        return value.toString();
      }
      if (util.isFunction(value) || util.isRegExp(value)) {
        return value.toString();
      }
      return value;
    }
    
    function truncate(s, n) {
      if (util.isString(s)) {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }
    
    function getMessage(self) {
      return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
             self.operator + ' ' +
             truncate(JSON.stringify(self.expected, replacer), 128);
    }
    
    // At present only the three keys mentioned above are used and
    // understood by the spec. Implementations or sub modules can pass
    // other keys to the AssertionError's constructor - they will be
    // ignored.
    
    // 3. All of the following functions must throw an AssertionError
    // when a corresponding condition is not met, with a message that
    // may be undefined if not provided.  All assertion methods provide
    // both the actual and expected values to the assertion error for
    // display purposes.
    
    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new assert.AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }
    
    // EXTENSION! allows for well behaved errors defined elsewhere.
    assert.fail = fail;
    
    // 4. Pure assertion tests whether a value is truthy, as determined
    // by !!guard.
    // assert.ok(guard, message_opt);
    // This statement is equivalent to assert.equal(true, !!guard,
    // message_opt);. To test strictly for the value true, use
    // assert.strictEqual(true, guard, message_opt);.
    
    function ok(value, message) {
      if (!value) fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;
    
    // 5. The equality assertion tests shallow, coercive equality with
    // ==.
    // assert.equal(actual, expected, message_opt);
    
    assert.equal = function equal(actual, expected, message) {
      if (actual != expected) fail(actual, expected, message, '==', assert.equal);
    };
    
    // 6. The non-equality assertion tests for whether two objects are not equal
    // with != assert.notEqual(actual, expected, message_opt);
    
    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', assert.notEqual);
      }
    };
    
    // 7. The equivalence assertion tests a deep equality relation.
    // assert.deepEqual(actual, expected, message_opt);
    
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected)) {
        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
      }
    };
    
    function _deepEqual(actual, expected) {
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;
    
      } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
        if (actual.length != expected.length) return false;
    
        for (var i = 0; i < actual.length; i++) {
          if (actual[i] !== expected[i]) return false;
        }
    
        return true;
    
      // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
      } else if (util.isDate(actual) && util.isDate(expected)) {
        return actual.getTime() === expected.getTime();
    
      // 7.3 If the expected value is a RegExp object, the actual value is
      // equivalent if it is also a RegExp object with the same source and
      // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
      } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
        return actual.source === expected.source &&
               actual.global === expected.global &&
               actual.multiline === expected.multiline &&
               actual.lastIndex === expected.lastIndex &&
               actual.ignoreCase === expected.ignoreCase;
    
      // 7.4. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (!util.isObject(actual) && !util.isObject(expected)) {
        return actual == expected;
    
      // 7.5 For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected);
      }
    }
    
    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    
    function objEquiv(a, b) {
      if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
        return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (isArguments(a)) {
        if (!isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b);
      }
      try {
        var ka = objectKeys(a),
            kb = objectKeys(b),
            key, i;
      } catch (e) {//happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key])) return false;
      }
      return true;
    }
    
    // 8. The non-equivalence assertion tests for any deep inequality.
    // assert.notDeepEqual(actual, expected, message_opt);
    
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected)) {
        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
      }
    };
    
    // 9. The strict equality assertion tests strict equality, as determined by ===.
    // assert.strictEqual(actual, expected, message_opt);
    
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', assert.strictEqual);
      }
    };
    
    // 10. The strict non-equality assertion tests for strict inequality, as
    // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
    
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', assert.notStrictEqual);
      }
    };
    
    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }
    
      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      } else if (actual instanceof expected) {
        return true;
      } else if (expected.call({}, actual) === true) {
        return true;
      }
    
      return false;
    }
    
    function _throws(shouldThrow, block, expected, message) {
      var actual;
    
      if (util.isString(expected)) {
        message = expected;
        expected = null;
      }
    
      try {
        block();
      } catch (e) {
        actual = e;
      }
    
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
                (message ? ' ' + message : '.');
    
      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }
    
      if (!shouldThrow && expectedException(actual, expected)) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }
    
      if ((shouldThrow && actual && expected &&
          !expectedException(actual, expected)) || (!shouldThrow && actual)) {
        throw actual;
      }
    }
    
    // 11. Expected to throw an error:
    // assert.throws(block, Error_opt, message_opt);
    
    assert.throws = function(block, /*optional*/error, /*optional*/message) {
      _throws.apply(this, [true].concat(pSlice.call(arguments)));
    };
    
    // EXTENSION! This is annoying to write outside this module.
    assert.doesNotThrow = function(block, /*optional*/message) {
      _throws.apply(this, [false].concat(pSlice.call(arguments)));
    };
    
    assert.ifError = function(err) { if (err) {throw err;}};
    
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key)) keys.push(key);
      }
      return keys;
    };
    
  provide("assert", module.exports);
}(global));

// pakmanager:crypto-js/core
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r():"function"==typeof define&&define.amd?define([],r):e.CryptoJS=r()})(this,function(){var e=e||function(e,r){var t={},i=t.lib={},n=i.Base=function(){function e(){}return{extend:function(r){e.prototype=this;var t=new e;return r&&t.mixIn(r),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var r in e)e.hasOwnProperty(r)&&(this[r]=e[r]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}}}(),o=i.WordArray=n.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=t!=r?t:4*e.length},toString:function(e){return(e||s).stringify(this)},concat:function(e){var r=this.words,t=e.words,i=this.sigBytes,n=e.sigBytes;if(this.clamp(),i%4)for(var o=0;n>o;o++){var c=255&t[o>>>2]>>>24-8*(o%4);r[i+o>>>2]|=c<<24-8*((i+o)%4)}else if(t.length>65535)for(var o=0;n>o;o+=4)r[i+o>>>2]=t[o>>>2];else r.push.apply(r,t);return this.sigBytes+=n,this},clamp:function(){var r=this.words,t=this.sigBytes;r[t>>>2]&=4294967295<<32-8*(t%4),r.length=e.ceil(t/4)},clone:function(){var e=n.clone.call(this);return e.words=this.words.slice(0),e},random:function(r){for(var t=[],i=0;r>i;i+=4)t.push(0|4294967296*e.random());return new o.init(t,r)}}),c=t.enc={},s=c.Hex={stringify:function(e){for(var r=e.words,t=e.sigBytes,i=[],n=0;t>n;n++){var o=255&r[n>>>2]>>>24-8*(n%4);i.push((o>>>4).toString(16)),i.push((15&o).toString(16))}return i.join("")},parse:function(e){for(var r=e.length,t=[],i=0;r>i;i+=2)t[i>>>3]|=parseInt(e.substr(i,2),16)<<24-4*(i%8);return new o.init(t,r/2)}},u=c.Latin1={stringify:function(e){for(var r=e.words,t=e.sigBytes,i=[],n=0;t>n;n++){var o=255&r[n>>>2]>>>24-8*(n%4);i.push(String.fromCharCode(o))}return i.join("")},parse:function(e){for(var r=e.length,t=[],i=0;r>i;i++)t[i>>>2]|=(255&e.charCodeAt(i))<<24-8*(i%4);return new o.init(t,r)}},f=c.Utf8={stringify:function(e){try{return decodeURIComponent(escape(u.stringify(e)))}catch(r){throw Error("Malformed UTF-8 data")}},parse:function(e){return u.parse(unescape(encodeURIComponent(e)))}},a=i.BufferedBlockAlgorithm=n.extend({reset:function(){this._data=new o.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=f.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(r){var t=this._data,i=t.words,n=t.sigBytes,c=this.blockSize,s=4*c,u=n/s;u=r?e.ceil(u):e.max((0|u)-this._minBufferSize,0);var f=u*c,a=e.min(4*f,n);if(f){for(var p=0;f>p;p+=c)this._doProcessBlock(i,p);var d=i.splice(0,f);t.sigBytes-=a}return new o.init(d,a)},clone:function(){var e=n.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});i.Hasher=a.extend({cfg:n.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){a.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){e&&this._append(e);var r=this._doFinalize();return r},blockSize:16,_createHelper:function(e){return function(r,t){return new e.init(t).finalize(r)}},_createHmacHelper:function(e){return function(r,t){return new p.HMAC.init(e,t).finalize(r)}}});var p=t.algo={};return t}(Math);return e});
  provide("crypto-js/core", module.exports);
}(global));

// pakmanager:crypto-js/x64-core
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(r){var t=e,i=t.lib,n=i.Base,o=i.WordArray,c=t.x64={};c.Word=n.extend({init:function(e,r){this.high=e,this.low=r}}),c.WordArray=n.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=t!=r?t:8*e.length},toX32:function(){for(var e=this.words,r=e.length,t=[],i=0;r>i;i++){var n=e[i];t.push(n.high),t.push(n.low)}return o.create(t,this.sigBytes)},clone:function(){for(var e=n.clone.call(this),r=e.words=this.words.slice(0),t=r.length,i=0;t>i;i++)r[i]=r[i].clone();return e}})}(),e});
  provide("crypto-js/x64-core", module.exports);
}(global));

// pakmanager:crypto-js/sha1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,n=t.WordArray,i=t.Hasher,o=r.algo,s=[],c=o.SHA1=i.extend({_doReset:function(){this._hash=new n.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,r){for(var t=this._hash.words,n=t[0],i=t[1],o=t[2],c=t[3],a=t[4],f=0;80>f;f++){if(16>f)s[f]=0|e[r+f];else{var u=s[f-3]^s[f-8]^s[f-14]^s[f-16];s[f]=u<<1|u>>>31}var d=(n<<5|n>>>27)+a+s[f];d+=20>f?(i&o|~i&c)+1518500249:40>f?(i^o^c)+1859775393:60>f?(i&o|i&c|o&c)-1894007588:(i^o^c)-899497514,a=c,c=o,o=i<<30|i>>>2,i=n,n=d}t[0]=0|t[0]+n,t[1]=0|t[1]+i,t[2]=0|t[2]+o,t[3]=0|t[3]+c,t[4]=0|t[4]+a},_doFinalize:function(){var e=this._data,r=e.words,t=8*this._nDataBytes,n=8*e.sigBytes;return r[n>>>5]|=128<<24-n%32,r[(n+64>>>9<<4)+14]=Math.floor(t/4294967296),r[(n+64>>>9<<4)+15]=t,e.sigBytes=4*r.length,this._process(),this._hash},clone:function(){var e=i.clone.call(this);return e._hash=this._hash.clone(),e}});r.SHA1=i._createHelper(c),r.HmacSHA1=i._createHmacHelper(c)}(),e.SHA1});
  provide("crypto-js/sha1", module.exports);
}(global));

// pakmanager:crypto-js/hmac
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){(function(){var r=e,t=r.lib,n=t.Base,i=r.enc,o=i.Utf8,s=r.algo;s.HMAC=n.extend({init:function(e,r){e=this._hasher=new e.init,"string"==typeof r&&(r=o.parse(r));var t=e.blockSize,n=4*t;r.sigBytes>n&&(r=e.finalize(r)),r.clamp();for(var i=this._oKey=r.clone(),s=this._iKey=r.clone(),a=i.words,c=s.words,f=0;t>f;f++)a[f]^=1549556828,c[f]^=909522486;i.sigBytes=s.sigBytes=n,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var r=this._hasher,t=r.finalize(e);r.reset();var n=r.finalize(this._oKey.clone().concat(t));return n}})})()});
  provide("crypto-js/hmac", module.exports);
}(global));

// pakmanager:crypto-js/sha256
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(r){var t=e,n=t.lib,i=n.WordArray,o=n.Hasher,s=t.algo,c=[],a=[];(function(){function e(e){for(var t=r.sqrt(e),n=2;t>=n;n++)if(!(e%n))return!1;return!0}function t(e){return 0|4294967296*(e-(0|e))}for(var n=2,i=0;64>i;)e(n)&&(8>i&&(c[i]=t(r.pow(n,.5))),a[i]=t(r.pow(n,1/3)),i++),n++})();var f=[],u=s.SHA256=o.extend({_doReset:function(){this._hash=new i.init(c.slice(0))},_doProcessBlock:function(e,r){for(var t=this._hash.words,n=t[0],i=t[1],o=t[2],s=t[3],c=t[4],u=t[5],d=t[6],p=t[7],h=0;64>h;h++){if(16>h)f[h]=0|e[r+h];else{var y=f[h-15],l=(y<<25|y>>>7)^(y<<14|y>>>18)^y>>>3,m=f[h-2],x=(m<<15|m>>>17)^(m<<13|m>>>19)^m>>>10;f[h]=l+f[h-7]+x+f[h-16]}var v=c&u^~c&d,q=n&i^n&o^i&o,g=(n<<30|n>>>2)^(n<<19|n>>>13)^(n<<10|n>>>22),_=(c<<26|c>>>6)^(c<<21|c>>>11)^(c<<7|c>>>25),b=p+_+v+a[h]+f[h],S=g+q;p=d,d=u,u=c,c=0|s+b,s=o,o=i,i=n,n=0|b+S}t[0]=0|t[0]+n,t[1]=0|t[1]+i,t[2]=0|t[2]+o,t[3]=0|t[3]+s,t[4]=0|t[4]+c,t[5]=0|t[5]+u,t[6]=0|t[6]+d,t[7]=0|t[7]+p},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,i=8*e.sigBytes;return t[i>>>5]|=128<<24-i%32,t[(i+64>>>9<<4)+14]=r.floor(n/4294967296),t[(i+64>>>9<<4)+15]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=o._createHelper(u),t.HmacSHA256=o._createHmacHelper(u)}(Math),e.SHA256});
  provide("crypto-js/sha256", module.exports);
}(global));

// pakmanager:crypto-js/sha512
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/x64-core')):"function"==typeof define&&define.amd?define(["./core","./x64-core"],r):r(e.CryptoJS)})(this,function(e){return function(){function r(){return s.create.apply(s,arguments)}var t=e,n=t.lib,i=n.Hasher,o=t.x64,s=o.Word,a=o.WordArray,c=t.algo,f=[r(1116352408,3609767458),r(1899447441,602891725),r(3049323471,3964484399),r(3921009573,2173295548),r(961987163,4081628472),r(1508970993,3053834265),r(2453635748,2937671579),r(2870763221,3664609560),r(3624381080,2734883394),r(310598401,1164996542),r(607225278,1323610764),r(1426881987,3590304994),r(1925078388,4068182383),r(2162078206,991336113),r(2614888103,633803317),r(3248222580,3479774868),r(3835390401,2666613458),r(4022224774,944711139),r(264347078,2341262773),r(604807628,2007800933),r(770255983,1495990901),r(1249150122,1856431235),r(1555081692,3175218132),r(1996064986,2198950837),r(2554220882,3999719339),r(2821834349,766784016),r(2952996808,2566594879),r(3210313671,3203337956),r(3336571891,1034457026),r(3584528711,2466948901),r(113926993,3758326383),r(338241895,168717936),r(666307205,1188179964),r(773529912,1546045734),r(1294757372,1522805485),r(1396182291,2643833823),r(1695183700,2343527390),r(1986661051,1014477480),r(2177026350,1206759142),r(2456956037,344077627),r(2730485921,1290863460),r(2820302411,3158454273),r(3259730800,3505952657),r(3345764771,106217008),r(3516065817,3606008344),r(3600352804,1432725776),r(4094571909,1467031594),r(275423344,851169720),r(430227734,3100823752),r(506948616,1363258195),r(659060556,3750685593),r(883997877,3785050280),r(958139571,3318307427),r(1322822218,3812723403),r(1537002063,2003034995),r(1747873779,3602036899),r(1955562222,1575990012),r(2024104815,1125592928),r(2227730452,2716904306),r(2361852424,442776044),r(2428436474,593698344),r(2756734187,3733110249),r(3204031479,2999351573),r(3329325298,3815920427),r(3391569614,3928383900),r(3515267271,566280711),r(3940187606,3454069534),r(4118630271,4000239992),r(116418474,1914138554),r(174292421,2731055270),r(289380356,3203993006),r(460393269,320620315),r(685471733,587496836),r(852142971,1086792851),r(1017036298,365543100),r(1126000580,2618297676),r(1288033470,3409855158),r(1501505948,4234509866),r(1607167915,987167468),r(1816402316,1246189591)],u=[];(function(){for(var e=0;80>e;e++)u[e]=r()})();var h=c.SHA512=i.extend({_doReset:function(){this._hash=new a.init([new s.init(1779033703,4089235720),new s.init(3144134277,2227873595),new s.init(1013904242,4271175723),new s.init(2773480762,1595750129),new s.init(1359893119,2917565137),new s.init(2600822924,725511199),new s.init(528734635,4215389547),new s.init(1541459225,327033209)])},_doProcessBlock:function(e,r){for(var t=this._hash.words,n=t[0],i=t[1],o=t[2],s=t[3],a=t[4],c=t[5],h=t[6],d=t[7],p=n.high,l=n.low,y=i.high,m=i.low,x=o.high,g=o.low,v=s.high,w=s.low,_=a.high,q=a.low,H=c.high,S=c.low,b=h.high,A=h.low,B=d.high,C=d.low,j=p,J=l,z=y,W=m,U=x,k=g,M=v,D=w,F=_,P=q,R=H,I=S,O=b,L=A,E=B,X=C,$=0;80>$;$++){var T=u[$];if(16>$)var G=T.high=0|e[r+2*$],K=T.low=0|e[r+2*$+1];else{var N=u[$-15],Q=N.high,V=N.low,Y=(Q>>>1|V<<31)^(Q>>>8|V<<24)^Q>>>7,Z=(V>>>1|Q<<31)^(V>>>8|Q<<24)^(V>>>7|Q<<25),er=u[$-2],rr=er.high,tr=er.low,nr=(rr>>>19|tr<<13)^(rr<<3|tr>>>29)^rr>>>6,ir=(tr>>>19|rr<<13)^(tr<<3|rr>>>29)^(tr>>>6|rr<<26),or=u[$-7],sr=or.high,ar=or.low,cr=u[$-16],fr=cr.high,ur=cr.low,K=Z+ar,G=Y+sr+(Z>>>0>K>>>0?1:0),K=K+ir,G=G+nr+(ir>>>0>K>>>0?1:0),K=K+ur,G=G+fr+(ur>>>0>K>>>0?1:0);T.high=G,T.low=K}var hr=F&R^~F&O,dr=P&I^~P&L,pr=j&z^j&U^z&U,lr=J&W^J&k^W&k,yr=(j>>>28|J<<4)^(j<<30|J>>>2)^(j<<25|J>>>7),mr=(J>>>28|j<<4)^(J<<30|j>>>2)^(J<<25|j>>>7),xr=(F>>>14|P<<18)^(F>>>18|P<<14)^(F<<23|P>>>9),gr=(P>>>14|F<<18)^(P>>>18|F<<14)^(P<<23|F>>>9),vr=f[$],wr=vr.high,_r=vr.low,qr=X+gr,Hr=E+xr+(X>>>0>qr>>>0?1:0),qr=qr+dr,Hr=Hr+hr+(dr>>>0>qr>>>0?1:0),qr=qr+_r,Hr=Hr+wr+(_r>>>0>qr>>>0?1:0),qr=qr+K,Hr=Hr+G+(K>>>0>qr>>>0?1:0),Sr=mr+lr,br=yr+pr+(mr>>>0>Sr>>>0?1:0);E=O,X=L,O=R,L=I,R=F,I=P,P=0|D+qr,F=0|M+Hr+(D>>>0>P>>>0?1:0),M=U,D=k,U=z,k=W,z=j,W=J,J=0|qr+Sr,j=0|Hr+br+(qr>>>0>J>>>0?1:0)}l=n.low=l+J,n.high=p+j+(J>>>0>l>>>0?1:0),m=i.low=m+W,i.high=y+z+(W>>>0>m>>>0?1:0),g=o.low=g+k,o.high=x+U+(k>>>0>g>>>0?1:0),w=s.low=w+D,s.high=v+M+(D>>>0>w>>>0?1:0),q=a.low=q+P,a.high=_+F+(P>>>0>q>>>0?1:0),S=c.low=S+I,c.high=H+R+(I>>>0>S>>>0?1:0),A=h.low=A+L,h.high=b+O+(L>>>0>A>>>0?1:0),C=d.low=C+X,d.high=B+E+(X>>>0>C>>>0?1:0)},_doFinalize:function(){var e=this._data,r=e.words,t=8*this._nDataBytes,n=8*e.sigBytes;r[n>>>5]|=128<<24-n%32,r[(n+128>>>10<<5)+30]=Math.floor(t/4294967296),r[(n+128>>>10<<5)+31]=t,e.sigBytes=4*r.length,this._process();var i=this._hash.toX32();return i},clone:function(){var e=i.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32});t.SHA512=i._createHelper(h),t.HmacSHA512=i._createHmacHelper(h)}(),e.SHA512});
  provide("crypto-js/sha512", module.exports);
}(global));

// pakmanager:crypto-js/cipher-core
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){e.lib.Cipher||function(r){var t=e,i=t.lib,n=i.Base,o=i.WordArray,c=i.BufferedBlockAlgorithm,s=t.enc;s.Utf8;var a=s.Base64,f=t.algo,u=f.EvpKDF,h=i.Cipher=c.extend({cfg:n.extend(),createEncryptor:function(e,r){return this.create(this._ENC_XFORM_MODE,e,r)},createDecryptor:function(e,r){return this.create(this._DEC_XFORM_MODE,e,r)},init:function(e,r,t){this.cfg=this.cfg.extend(t),this._xformMode=e,this._key=r,this.reset()},reset:function(){c.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){e&&this._append(e);var r=this._doFinalize();return r},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function e(e){return"string"==typeof e?B:_}return function(r){return{encrypt:function(t,i,n){return e(i).encrypt(r,t,i,n)},decrypt:function(t,i,n){return e(i).decrypt(r,t,i,n)}}}}()});i.StreamCipher=h.extend({_doFinalize:function(){var e=this._process(true);return e},blockSize:1});var d=t.mode={},p=i.BlockCipherMode=n.extend({createEncryptor:function(e,r){return this.Encryptor.create(e,r)},createDecryptor:function(e,r){return this.Decryptor.create(e,r)},init:function(e,r){this._cipher=e,this._iv=r}}),l=d.CBC=function(){function e(e,t,i){var n=this._iv;if(n){var o=n;this._iv=r}else var o=this._prevBlock;for(var c=0;i>c;c++)e[t+c]^=o[c]}var t=p.extend();return t.Encryptor=t.extend({processBlock:function(r,t){var i=this._cipher,n=i.blockSize;e.call(this,r,t,n),i.encryptBlock(r,t),this._prevBlock=r.slice(t,t+n)}}),t.Decryptor=t.extend({processBlock:function(r,t){var i=this._cipher,n=i.blockSize,o=r.slice(t,t+n);i.decryptBlock(r,t),e.call(this,r,t,n),this._prevBlock=o}}),t}(),y=t.pad={},v=y.Pkcs7={pad:function(e,r){for(var t=4*r,i=t-e.sigBytes%t,n=i<<24|i<<16|i<<8|i,c=[],s=0;i>s;s+=4)c.push(n);var a=o.create(c,i);e.concat(a)},unpad:function(e){var r=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=r}};i.BlockCipher=h.extend({cfg:h.cfg.extend({mode:l,padding:v}),reset:function(){h.reset.call(this);var e=this.cfg,r=e.iv,t=e.mode;if(this._xformMode==this._ENC_XFORM_MODE)var i=t.createEncryptor;else{var i=t.createDecryptor;this._minBufferSize=1}this._mode=i.call(t,this,r&&r.words)},_doProcessBlock:function(e,r){this._mode.processBlock(e,r)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var r=this._process(true)}else{var r=this._process(true);e.unpad(r)}return r},blockSize:4});var m=i.CipherParams=n.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}}),g=t.format={},x=g.OpenSSL={stringify:function(e){var r=e.ciphertext,t=e.salt;if(t)var i=o.create([1398893684,1701076831]).concat(t).concat(r);else var i=r;return i.toString(a)},parse:function(e){var r=a.parse(e),t=r.words;if(1398893684==t[0]&&1701076831==t[1]){var i=o.create(t.slice(2,4));t.splice(0,4),r.sigBytes-=16}return m.create({ciphertext:r,salt:i})}},_=i.SerializableCipher=n.extend({cfg:n.extend({format:x}),encrypt:function(e,r,t,i){i=this.cfg.extend(i);var n=e.createEncryptor(t,i),o=n.finalize(r),c=n.cfg;return m.create({ciphertext:o,key:t,iv:c.iv,algorithm:e,mode:c.mode,padding:c.padding,blockSize:e.blockSize,formatter:i.format})},decrypt:function(e,r,t,i){i=this.cfg.extend(i),r=this._parse(r,i.format);var n=e.createDecryptor(t,i).finalize(r.ciphertext);return n},_parse:function(e,r){return"string"==typeof e?r.parse(e,this):e}}),w=t.kdf={},S=w.OpenSSL={execute:function(e,r,t,i){i||(i=o.random(8));var n=u.create({keySize:r+t}).compute(e,i),c=o.create(n.words.slice(r),4*t);return n.sigBytes=4*r,m.create({key:n,iv:c,salt:i})}},B=i.PasswordBasedCipher=_.extend({cfg:_.cfg.extend({kdf:S}),encrypt:function(e,r,t,i){i=this.cfg.extend(i);var n=i.kdf.execute(t,e.keySize,e.ivSize);i.iv=n.iv;var o=_.encrypt.call(this,e,r,n.key,i);return o.mixIn(n),o},decrypt:function(e,r,t,i){i=this.cfg.extend(i),r=this._parse(r,i.format);var n=i.kdf.execute(t,e.keySize,e.ivSize,r.salt);i.iv=n.iv;var o=_.decrypt.call(this,e,r,n.key,i);return o}})}()});
  provide("crypto-js/cipher-core", module.exports);
}(global));

// pakmanager:crypto-js/enc-base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,n=t.WordArray,i=r.enc;i.Base64={stringify:function(e){var r=e.words,t=e.sigBytes,n=this._map;e.clamp();for(var i=[],o=0;t>o;o+=3)for(var s=255&r[o>>>2]>>>24-8*(o%4),c=255&r[o+1>>>2]>>>24-8*((o+1)%4),a=255&r[o+2>>>2]>>>24-8*((o+2)%4),f=s<<16|c<<8|a,u=0;4>u&&t>o+.75*u;u++)i.push(n.charAt(63&f>>>6*(3-u)));var d=n.charAt(64);if(d)for(;i.length%4;)i.push(d);return i.join("")},parse:function(e){var r=e.length,t=this._map,i=t.charAt(64);if(i){var o=e.indexOf(i);-1!=o&&(r=o)}for(var s=[],c=0,a=0;r>a;a++)if(a%4){var f=t.indexOf(e.charAt(a-1))<<2*(a%4),u=t.indexOf(e.charAt(a))>>>6-2*(a%4);s[c>>>2]|=(f|u)<<24-8*(c%4),c++}return n.create(s,c)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),e.enc.Base64});
  provide("crypto-js/enc-base64", module.exports);
}(global));

// pakmanager:crypto-js/md5
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(r){function t(e,r,t,n,i,o,s){var c=e+(r&t|~r&n)+i+s;return(c<<o|c>>>32-o)+r}function n(e,r,t,n,i,o,s){var c=e+(r&n|t&~n)+i+s;return(c<<o|c>>>32-o)+r}function i(e,r,t,n,i,o,s){var c=e+(r^t^n)+i+s;return(c<<o|c>>>32-o)+r}function o(e,r,t,n,i,o,s){var c=e+(t^(r|~n))+i+s;return(c<<o|c>>>32-o)+r}var s=e,c=s.lib,f=c.WordArray,a=c.Hasher,u=s.algo,p=[];(function(){for(var e=0;64>e;e++)p[e]=0|4294967296*r.abs(r.sin(e+1))})();var d=u.MD5=a.extend({_doReset:function(){this._hash=new f.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,r){for(var s=0;16>s;s++){var c=r+s,f=e[c];e[c]=16711935&(f<<8|f>>>24)|4278255360&(f<<24|f>>>8)}var a=this._hash.words,u=e[r+0],d=e[r+1],h=e[r+2],y=e[r+3],m=e[r+4],l=e[r+5],x=e[r+6],q=e[r+7],g=e[r+8],v=e[r+9],b=e[r+10],S=e[r+11],w=e[r+12],C=e[r+13],_=e[r+14],A=e[r+15],B=a[0],H=a[1],j=a[2],J=a[3];B=t(B,H,j,J,u,7,p[0]),J=t(J,B,H,j,d,12,p[1]),j=t(j,J,B,H,h,17,p[2]),H=t(H,j,J,B,y,22,p[3]),B=t(B,H,j,J,m,7,p[4]),J=t(J,B,H,j,l,12,p[5]),j=t(j,J,B,H,x,17,p[6]),H=t(H,j,J,B,q,22,p[7]),B=t(B,H,j,J,g,7,p[8]),J=t(J,B,H,j,v,12,p[9]),j=t(j,J,B,H,b,17,p[10]),H=t(H,j,J,B,S,22,p[11]),B=t(B,H,j,J,w,7,p[12]),J=t(J,B,H,j,C,12,p[13]),j=t(j,J,B,H,_,17,p[14]),H=t(H,j,J,B,A,22,p[15]),B=n(B,H,j,J,d,5,p[16]),J=n(J,B,H,j,x,9,p[17]),j=n(j,J,B,H,S,14,p[18]),H=n(H,j,J,B,u,20,p[19]),B=n(B,H,j,J,l,5,p[20]),J=n(J,B,H,j,b,9,p[21]),j=n(j,J,B,H,A,14,p[22]),H=n(H,j,J,B,m,20,p[23]),B=n(B,H,j,J,v,5,p[24]),J=n(J,B,H,j,_,9,p[25]),j=n(j,J,B,H,y,14,p[26]),H=n(H,j,J,B,g,20,p[27]),B=n(B,H,j,J,C,5,p[28]),J=n(J,B,H,j,h,9,p[29]),j=n(j,J,B,H,q,14,p[30]),H=n(H,j,J,B,w,20,p[31]),B=i(B,H,j,J,l,4,p[32]),J=i(J,B,H,j,g,11,p[33]),j=i(j,J,B,H,S,16,p[34]),H=i(H,j,J,B,_,23,p[35]),B=i(B,H,j,J,d,4,p[36]),J=i(J,B,H,j,m,11,p[37]),j=i(j,J,B,H,q,16,p[38]),H=i(H,j,J,B,b,23,p[39]),B=i(B,H,j,J,C,4,p[40]),J=i(J,B,H,j,u,11,p[41]),j=i(j,J,B,H,y,16,p[42]),H=i(H,j,J,B,x,23,p[43]),B=i(B,H,j,J,v,4,p[44]),J=i(J,B,H,j,w,11,p[45]),j=i(j,J,B,H,A,16,p[46]),H=i(H,j,J,B,h,23,p[47]),B=o(B,H,j,J,u,6,p[48]),J=o(J,B,H,j,q,10,p[49]),j=o(j,J,B,H,_,15,p[50]),H=o(H,j,J,B,l,21,p[51]),B=o(B,H,j,J,w,6,p[52]),J=o(J,B,H,j,y,10,p[53]),j=o(j,J,B,H,b,15,p[54]),H=o(H,j,J,B,d,21,p[55]),B=o(B,H,j,J,g,6,p[56]),J=o(J,B,H,j,A,10,p[57]),j=o(j,J,B,H,x,15,p[58]),H=o(H,j,J,B,C,21,p[59]),B=o(B,H,j,J,m,6,p[60]),J=o(J,B,H,j,S,10,p[61]),j=o(j,J,B,H,h,15,p[62]),H=o(H,j,J,B,v,21,p[63]),a[0]=0|a[0]+B,a[1]=0|a[1]+H,a[2]=0|a[2]+j,a[3]=0|a[3]+J},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,i=8*e.sigBytes;t[i>>>5]|=128<<24-i%32;var o=r.floor(n/4294967296),s=n;t[(i+64>>>9<<4)+15]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),t[(i+64>>>9<<4)+14]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),e.sigBytes=4*(t.length+1),this._process();for(var c=this._hash,f=c.words,a=0;4>a;a++){var u=f[a];f[a]=16711935&(u<<8|u>>>24)|4278255360&(u<<24|u>>>8)}return c},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});s.MD5=a._createHelper(d),s.HmacMD5=a._createHmacHelper(d)}(Math),e.MD5});
  provide("crypto-js/md5", module.exports);
}(global));

// pakmanager:crypto-js/evpkdf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/sha1'), require('crypto-js/hmac')):"function"==typeof define&&define.amd?define(["./core","./sha1","./hmac"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,i=t.Base,n=t.WordArray,o=r.algo,s=o.MD5,a=o.EvpKDF=i.extend({cfg:i.extend({keySize:4,hasher:s,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,r){for(var t=this.cfg,i=t.hasher.create(),o=n.create(),s=o.words,a=t.keySize,c=t.iterations;a>s.length;){f&&i.update(f);var f=i.update(e).finalize(r);i.reset();for(var u=1;c>u;u++)f=i.finalize(f),i.reset();o.concat(f)}return o.sigBytes=4*a,o}});r.EvpKDF=function(e,r,t){return a.create(t).compute(e,r)}}(),e.EvpKDF});
  provide("crypto-js/evpkdf", module.exports);
}(global));

// pakmanager:crypto-js/lib-typedarrays
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(){if("function"==typeof ArrayBuffer){var r=e,t=r.lib,i=t.WordArray,n=i.init,o=i.init=function(e){if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),(e instanceof Int8Array||e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array)&&(e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),e instanceof Uint8Array){for(var r=e.byteLength,t=[],i=0;r>i;i++)t[i>>>2]|=e[i]<<24-8*(i%4);n.call(this,t,r)}else n.apply(this,arguments)};o.prototype=i}}(),e.lib.WordArray});
  provide("crypto-js/lib-typedarrays", module.exports);
}(global));

// pakmanager:crypto-js/enc-utf16
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(){function r(e){return 4278255360&e<<8|16711935&e>>>8}var t=e,n=t.lib,i=n.WordArray,o=t.enc;o.Utf16=o.Utf16BE={stringify:function(e){for(var r=e.words,t=e.sigBytes,n=[],i=0;t>i;i+=2){var o=65535&r[i>>>2]>>>16-8*(i%4);n.push(String.fromCharCode(o))}return n.join("")},parse:function(e){for(var r=e.length,t=[],n=0;r>n;n++)t[n>>>1]|=e.charCodeAt(n)<<16-16*(n%2);return i.create(t,2*r)}},o.Utf16LE={stringify:function(e){for(var t=e.words,n=e.sigBytes,i=[],o=0;n>o;o+=2){var c=r(65535&t[o>>>2]>>>16-8*(o%4));i.push(String.fromCharCode(c))}return i.join("")},parse:function(e){for(var t=e.length,n=[],o=0;t>o;o++)n[o>>>1]|=r(e.charCodeAt(o)<<16-16*(o%2));return i.create(n,2*t)}}}(),e.enc.Utf16});
  provide("crypto-js/enc-utf16", module.exports);
}(global));

// pakmanager:crypto-js/sha224
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/sha256')):"function"==typeof define&&define.amd?define(["./core","./sha256"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,n=t.WordArray,i=r.algo,o=i.SHA256,s=i.SHA224=o.extend({_doReset:function(){this._hash=new n.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var e=o._doFinalize.call(this);return e.sigBytes-=4,e}});r.SHA224=o._createHelper(s),r.HmacSHA224=o._createHmacHelper(s)}(),e.SHA224});
  provide("crypto-js/sha224", module.exports);
}(global));

// pakmanager:crypto-js/sha384
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/x64-core'), require('crypto-js/sha512')):"function"==typeof define&&define.amd?define(["./core","./x64-core","./sha512"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.x64,n=t.Word,i=t.WordArray,o=r.algo,s=o.SHA512,c=o.SHA384=s.extend({_doReset:function(){this._hash=new i.init([new n.init(3418070365,3238371032),new n.init(1654270250,914150663),new n.init(2438529370,812702999),new n.init(355462360,4144912697),new n.init(1731405415,4290775857),new n.init(2394180231,1750603025),new n.init(3675008525,1694076839),new n.init(1203062813,3204075428)])},_doFinalize:function(){var e=s._doFinalize.call(this);return e.sigBytes-=16,e}});r.SHA384=s._createHelper(c),r.HmacSHA384=s._createHmacHelper(c)}(),e.SHA384});
  provide("crypto-js/sha384", module.exports);
}(global));

// pakmanager:crypto-js/sha3
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/x64-core')):"function"==typeof define&&define.amd?define(["./core","./x64-core"],r):r(e.CryptoJS)})(this,function(e){return function(r){var t=e,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.x64,s=a.Word,c=t.algo,f=[],u=[],h=[];(function(){for(var e=1,r=0,t=0;24>t;t++){f[e+5*r]=(t+1)*(t+2)/2%64;var n=r%5,i=(2*e+3*r)%5;e=n,r=i}for(var e=0;5>e;e++)for(var r=0;5>r;r++)u[e+5*r]=r+5*((2*e+3*r)%5);for(var o=1,a=0;24>a;a++){for(var c=0,d=0,p=0;7>p;p++){if(1&o){var l=(1<<p)-1;32>l?d^=1<<l:c^=1<<l-32}128&o?o=113^o<<1:o<<=1}h[a]=s.create(c,d)}})();var d=[];(function(){for(var e=0;25>e;e++)d[e]=s.create()})();var p=c.SHA3=o.extend({cfg:o.cfg.extend({outputLength:512}),_doReset:function(){for(var e=this._state=[],r=0;25>r;r++)e[r]=new s.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(e,r){for(var t=this._state,n=this.blockSize/2,i=0;n>i;i++){var o=e[r+2*i],a=e[r+2*i+1];o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),a=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8);var s=t[i];s.high^=a,s.low^=o}for(var c=0;24>c;c++){for(var p=0;5>p;p++){for(var l=0,y=0,m=0;5>m;m++){var s=t[p+5*m];l^=s.high,y^=s.low}var v=d[p];v.high=l,v.low=y}for(var p=0;5>p;p++)for(var g=d[(p+4)%5],x=d[(p+1)%5],w=x.high,_=x.low,l=g.high^(w<<1|_>>>31),y=g.low^(_<<1|w>>>31),m=0;5>m;m++){var s=t[p+5*m];s.high^=l,s.low^=y}for(var q=1;25>q;q++){var s=t[q],H=s.high,S=s.low,b=f[q];if(32>b)var l=H<<b|S>>>32-b,y=S<<b|H>>>32-b;else var l=S<<b-32|H>>>64-b,y=H<<b-32|S>>>64-b;var A=d[u[q]];A.high=l,A.low=y}var B=d[0],C=t[0];B.high=C.high,B.low=C.low;for(var p=0;5>p;p++)for(var m=0;5>m;m++){var q=p+5*m,s=t[q],j=d[q],z=d[(p+1)%5+5*m],J=d[(p+2)%5+5*m];s.high=j.high^~z.high&J.high,s.low=j.low^~z.low&J.low}var s=t[0],M=h[c];s.high^=M.high,s.low^=M.low}},_doFinalize:function(){var e=this._data,t=e.words;8*this._nDataBytes;var n=8*e.sigBytes,o=32*this.blockSize;t[n>>>5]|=1<<24-n%32,t[(r.ceil((n+1)/o)*o>>>5)-1]|=128,e.sigBytes=4*t.length,this._process();for(var a=this._state,s=this.cfg.outputLength/8,c=s/8,f=[],u=0;c>u;u++){var h=a[u],d=h.high,p=h.low;d=16711935&(d<<8|d>>>24)|4278255360&(d<<24|d>>>8),p=16711935&(p<<8|p>>>24)|4278255360&(p<<24|p>>>8),f.push(p),f.push(d)}return new i.init(f,s)},clone:function(){for(var e=o.clone.call(this),r=e._state=this._state.slice(0),t=0;25>t;t++)r[t]=r[t].clone();return e}});t.SHA3=o._createHelper(p),t.HmacSHA3=o._createHmacHelper(p)}(Math),e.SHA3});
  provide("crypto-js/sha3", module.exports);
}(global));

// pakmanager:crypto-js/ripemd160
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core')):"function"==typeof define&&define.amd?define(["./core"],r):r(e.CryptoJS)})(this,function(e){return function(){function r(e,r,t){return e^r^t}function t(e,r,t){return e&r|~e&t}function n(e,r,t){return(e|~r)^t}function i(e,r,t){return e&t|r&~t}function o(e,r,t){return e^(r|~t)}function s(e,r){return e<<r|e>>>32-r}var a=e,c=a.lib,f=c.WordArray,u=c.Hasher,h=a.algo,d=f.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),p=f.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),l=f.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),y=f.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),m=f.create([0,1518500249,1859775393,2400959708,2840853838]),x=f.create([1352829926,1548603684,1836072691,2053994217,0]),g=h.RIPEMD160=u.extend({_doReset:function(){this._hash=f.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,a){for(var c=0;16>c;c++){var f=a+c,u=e[f];e[f]=16711935&(u<<8|u>>>24)|4278255360&(u<<24|u>>>8)}var h,g,v,_,w,q,H,S,b,A,B=this._hash.words,C=m.words,j=x.words,J=d.words,z=p.words,M=l.words,W=y.words;q=h=B[0],H=g=B[1],S=v=B[2],b=_=B[3],A=w=B[4];for(var D,c=0;80>c;c+=1)D=0|h+e[a+J[c]],D+=16>c?r(g,v,_)+C[0]:32>c?t(g,v,_)+C[1]:48>c?n(g,v,_)+C[2]:64>c?i(g,v,_)+C[3]:o(g,v,_)+C[4],D=0|D,D=s(D,M[c]),D=0|D+w,h=w,w=_,_=s(v,10),v=g,g=D,D=0|q+e[a+z[c]],D+=16>c?o(H,S,b)+j[0]:32>c?i(H,S,b)+j[1]:48>c?n(H,S,b)+j[2]:64>c?t(H,S,b)+j[3]:r(H,S,b)+j[4],D=0|D,D=s(D,W[c]),D=0|D+A,q=A,A=b,b=s(S,10),S=H,H=D;D=0|B[1]+v+b,B[1]=0|B[2]+_+A,B[2]=0|B[3]+w+q,B[3]=0|B[4]+h+H,B[4]=0|B[0]+g+S,B[0]=D},_doFinalize:function(){var e=this._data,r=e.words,t=8*this._nDataBytes,n=8*e.sigBytes;r[n>>>5]|=128<<24-n%32,r[(n+64>>>9<<4)+14]=16711935&(t<<8|t>>>24)|4278255360&(t<<24|t>>>8),e.sigBytes=4*(r.length+1),this._process();for(var i=this._hash,o=i.words,s=0;5>s;s++){var a=o[s];o[s]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}return i},clone:function(){var e=u.clone.call(this);return e._hash=this._hash.clone(),e}});a.RIPEMD160=u._createHelper(g),a.HmacRIPEMD160=u._createHmacHelper(g)}(Math),e.RIPEMD160});
  provide("crypto-js/ripemd160", module.exports);
}(global));

// pakmanager:crypto-js/pbkdf2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/sha1'), require('crypto-js/hmac')):"function"==typeof define&&define.amd?define(["./core","./sha1","./hmac"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,n=t.Base,i=t.WordArray,o=r.algo,a=o.SHA1,s=o.HMAC,c=o.PBKDF2=n.extend({cfg:n.extend({keySize:4,hasher:a,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,r){for(var t=this.cfg,n=s.create(t.hasher,e),o=i.create(),a=i.create([1]),c=o.words,f=a.words,u=t.keySize,h=t.iterations;u>c.length;){var d=n.update(r).finalize(a);n.reset();for(var p=d.words,l=p.length,y=d,m=1;h>m;m++){y=n.finalize(y),n.reset();for(var g=y.words,v=0;l>v;v++)p[v]^=g[v]}o.concat(d),f[0]++}return o.sigBytes=4*u,o}});r.PBKDF2=function(e,r,t){return c.create(t).compute(e,r)}}(),e.PBKDF2});
  provide("crypto-js/pbkdf2", module.exports);
}(global));

// pakmanager:crypto-js/mode-cfb
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.mode.CFB=function(){function r(e,r,t,i){var o=this._iv;if(o){var n=o.slice(0);this._iv=void 0}else var n=this._prevBlock;i.encryptBlock(n,0);for(var s=0;t>s;s++)e[r+s]^=n[s]}var t=e.lib.BlockCipherMode.extend();return t.Encryptor=t.extend({processBlock:function(e,t){var i=this._cipher,o=i.blockSize;r.call(this,e,t,o,i),this._prevBlock=e.slice(t,t+o)}}),t.Decryptor=t.extend({processBlock:function(e,t){var i=this._cipher,o=i.blockSize,n=e.slice(t,t+o);r.call(this,e,t,o,i),this._prevBlock=n}}),t}(),e.mode.CFB});
  provide("crypto-js/mode-cfb", module.exports);
}(global));

// pakmanager:crypto-js/mode-ctr
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.mode.CTR=function(){var r=e.lib.BlockCipherMode.extend(),t=r.Encryptor=r.extend({processBlock:function(e,r){var t=this._cipher,i=t.blockSize,o=this._iv,n=this._counter;o&&(n=this._counter=o.slice(0),this._iv=void 0);var c=n.slice(0);t.encryptBlock(c,0),n[i-1]=0|n[i-1]+1;for(var s=0;i>s;s++)e[r+s]^=c[s]}});return r.Decryptor=t,r}(),e.mode.CTR});
  provide("crypto-js/mode-ctr", module.exports);
}(global));

// pakmanager:crypto-js/mode-ctr-gladman
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.mode.CTRGladman=function(){function r(e){if(255===(255&e>>24)){var r=255&e>>16,t=255&e>>8,i=255&e;255===r?(r=0,255===t?(t=0,255===i?i=0:++i):++t):++r,e=0,e+=r<<16,e+=t<<8,e+=i}else e+=1<<24;return e}function t(e){return 0===(e[0]=r(e[0]))&&(e[1]=r(e[1])),e}var i=e.lib.BlockCipherMode.extend(),n=i.Encryptor=i.extend({processBlock:function(e,r){var i=this._cipher,n=i.blockSize,o=this._iv,c=this._counter;o&&(c=this._counter=o.slice(0),this._iv=void 0),t(c);var s=c.slice(0);i.encryptBlock(s,0);for(var a=0;n>a;a++)e[r+a]^=s[a]}});return i.Decryptor=n,i}(),e.mode.CTRGladman});
  provide("crypto-js/mode-ctr-gladman", module.exports);
}(global));

// pakmanager:crypto-js/mode-ofb
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.mode.OFB=function(){var r=e.lib.BlockCipherMode.extend(),t=r.Encryptor=r.extend({processBlock:function(e,r){var t=this._cipher,i=t.blockSize,n=this._iv,o=this._keystream;n&&(o=this._keystream=n.slice(0),this._iv=void 0),t.encryptBlock(o,0);for(var c=0;i>c;c++)e[r+c]^=o[c]}});return r.Decryptor=t,r}(),e.mode.OFB});
  provide("crypto-js/mode-ofb", module.exports);
}(global));

// pakmanager:crypto-js/mode-ecb
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.mode.ECB=function(){var r=e.lib.BlockCipherMode.extend();return r.Encryptor=r.extend({processBlock:function(e,r){this._cipher.encryptBlock(e,r)}}),r.Decryptor=r.extend({processBlock:function(e,r){this._cipher.decryptBlock(e,r)}}),r}(),e.mode.ECB});
  provide("crypto-js/mode-ecb", module.exports);
}(global));

// pakmanager:crypto-js/pad-ansix923
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.pad.AnsiX923={pad:function(e,r){var t=e.sigBytes,i=4*r,n=i-t%i,o=t+n-1;e.clamp(),e.words[o>>>2]|=n<<24-8*(o%4),e.sigBytes+=n},unpad:function(e){var r=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=r}},e.pad.Ansix923});
  provide("crypto-js/pad-ansix923", module.exports);
}(global));

// pakmanager:crypto-js/pad-iso10126
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.pad.Iso10126={pad:function(r,t){var i=4*t,o=i-r.sigBytes%i;r.concat(e.lib.WordArray.random(o-1)).concat(e.lib.WordArray.create([o<<24],1))},unpad:function(e){var r=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=r}},e.pad.Iso10126});
  provide("crypto-js/pad-iso10126", module.exports);
}(global));

// pakmanager:crypto-js/pad-iso97971
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.pad.Iso97971={pad:function(r,t){r.concat(e.lib.WordArray.create([2147483648],1)),e.pad.ZeroPadding.pad(r,t)},unpad:function(r){e.pad.ZeroPadding.unpad(r),r.sigBytes--}},e.pad.Iso97971});
  provide("crypto-js/pad-iso97971", module.exports);
}(global));

// pakmanager:crypto-js/pad-zeropadding
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.pad.ZeroPadding={pad:function(e,r){var t=4*r;e.clamp(),e.sigBytes+=t-(e.sigBytes%t||t)},unpad:function(e){for(var r=e.words,t=e.sigBytes-1;!(255&r[t>>>2]>>>24-8*(t%4));)t--;e.sigBytes=t+1}},e.pad.ZeroPadding});
  provide("crypto-js/pad-zeropadding", module.exports);
}(global));

// pakmanager:crypto-js/pad-nopadding
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return e.pad.NoPadding={pad:function(){},unpad:function(){}},e.pad.NoPadding});
  provide("crypto-js/pad-nopadding", module.exports);
}(global));

// pakmanager:crypto-js/format-hex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,i=t.CipherParams,o=r.enc,n=o.Hex,c=r.format;c.Hex={stringify:function(e){return e.ciphertext.toString(n)},parse:function(e){var r=n.parse(e);return i.create({ciphertext:r})}}}(),e.format.Hex});
  provide("crypto-js/format-hex", module.exports);
}(global));

// pakmanager:crypto-js/aes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/enc-base64'), require('crypto-js/md5'), require('crypto-js/evpkdf'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return function(){var r=e,t=r.lib,i=t.BlockCipher,o=r.algo,n=[],c=[],s=[],a=[],f=[],u=[],h=[],p=[],d=[],l=[];(function(){for(var e=[],r=0;256>r;r++)e[r]=128>r?r<<1:283^r<<1;for(var t=0,i=0,r=0;256>r;r++){var o=i^i<<1^i<<2^i<<3^i<<4;o=99^(o>>>8^255&o),n[t]=o,c[o]=t;var y=e[t],v=e[y],m=e[v],x=257*e[o]^16843008*o;s[t]=x<<24|x>>>8,a[t]=x<<16|x>>>16,f[t]=x<<8|x>>>24,u[t]=x;var x=16843009*m^65537*v^257*y^16843008*t;h[o]=x<<24|x>>>8,p[o]=x<<16|x>>>16,d[o]=x<<8|x>>>24,l[o]=x,t?(t=y^e[e[e[m^y]]],i^=e[e[i]]):t=i=1}})();var y=[0,1,2,4,8,16,32,64,128,27,54],v=o.AES=i.extend({_doReset:function(){for(var e=this._key,r=e.words,t=e.sigBytes/4,i=this._nRounds=t+6,o=4*(i+1),c=this._keySchedule=[],s=0;o>s;s++)if(t>s)c[s]=r[s];else{var a=c[s-1];s%t?t>6&&4==s%t&&(a=n[a>>>24]<<24|n[255&a>>>16]<<16|n[255&a>>>8]<<8|n[255&a]):(a=a<<8|a>>>24,a=n[a>>>24]<<24|n[255&a>>>16]<<16|n[255&a>>>8]<<8|n[255&a],a^=y[0|s/t]<<24),c[s]=c[s-t]^a}for(var f=this._invKeySchedule=[],u=0;o>u;u++){var s=o-u;if(u%4)var a=c[s];else var a=c[s-4];f[u]=4>u||4>=s?a:h[n[a>>>24]]^p[n[255&a>>>16]]^d[n[255&a>>>8]]^l[n[255&a]]}},encryptBlock:function(e,r){this._doCryptBlock(e,r,this._keySchedule,s,a,f,u,n)},decryptBlock:function(e,r){var t=e[r+1];e[r+1]=e[r+3],e[r+3]=t,this._doCryptBlock(e,r,this._invKeySchedule,h,p,d,l,c);var t=e[r+1];e[r+1]=e[r+3],e[r+3]=t},_doCryptBlock:function(e,r,t,i,o,n,c,s){for(var a=this._nRounds,f=e[r]^t[0],u=e[r+1]^t[1],h=e[r+2]^t[2],p=e[r+3]^t[3],d=4,l=1;a>l;l++){var y=i[f>>>24]^o[255&u>>>16]^n[255&h>>>8]^c[255&p]^t[d++],v=i[u>>>24]^o[255&h>>>16]^n[255&p>>>8]^c[255&f]^t[d++],m=i[h>>>24]^o[255&p>>>16]^n[255&f>>>8]^c[255&u]^t[d++],x=i[p>>>24]^o[255&f>>>16]^n[255&u>>>8]^c[255&h]^t[d++];f=y,u=v,h=m,p=x}var y=(s[f>>>24]<<24|s[255&u>>>16]<<16|s[255&h>>>8]<<8|s[255&p])^t[d++],v=(s[u>>>24]<<24|s[255&h>>>16]<<16|s[255&p>>>8]<<8|s[255&f])^t[d++],m=(s[h>>>24]<<24|s[255&p>>>16]<<16|s[255&f>>>8]<<8|s[255&u])^t[d++],x=(s[p>>>24]<<24|s[255&f>>>16]<<16|s[255&u>>>8]<<8|s[255&h])^t[d++];e[r]=y,e[r+1]=v,e[r+2]=m,e[r+3]=x},keySize:8});r.AES=i._createHelper(v)}(),e.AES});
  provide("crypto-js/aes", module.exports);
}(global));

// pakmanager:crypto-js/tripledes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/enc-base64'), require('crypto-js/md5'), require('crypto-js/evpkdf'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return function(){function r(e,r){var t=(this._lBlock>>>e^this._rBlock)&r;this._rBlock^=t,this._lBlock^=t<<e}function t(e,r){var t=(this._rBlock>>>e^this._lBlock)&r;this._lBlock^=t,this._rBlock^=t<<e}var i=e,o=i.lib,n=o.WordArray,c=o.BlockCipher,s=i.algo,a=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],f=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],u=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],h=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],p=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],d=s.DES=c.extend({_doReset:function(){for(var e=this._key,r=e.words,t=[],i=0;56>i;i++){var o=a[i]-1;t[i]=1&r[o>>>5]>>>31-o%32}for(var n=this._subKeys=[],c=0;16>c;c++){for(var s=n[c]=[],h=u[c],i=0;24>i;i++)s[0|i/6]|=t[(f[i]-1+h)%28]<<31-i%6,s[4+(0|i/6)]|=t[28+(f[i+24]-1+h)%28]<<31-i%6;s[0]=s[0]<<1|s[0]>>>31;for(var i=1;7>i;i++)s[i]=s[i]>>>4*(i-1)+3;s[7]=s[7]<<5|s[7]>>>27}for(var p=this._invSubKeys=[],i=0;16>i;i++)p[i]=n[15-i]},encryptBlock:function(e,r){this._doCryptBlock(e,r,this._subKeys)},decryptBlock:function(e,r){this._doCryptBlock(e,r,this._invSubKeys)},_doCryptBlock:function(e,i,o){this._lBlock=e[i],this._rBlock=e[i+1],r.call(this,4,252645135),r.call(this,16,65535),t.call(this,2,858993459),t.call(this,8,16711935),r.call(this,1,1431655765);for(var n=0;16>n;n++){for(var c=o[n],s=this._lBlock,a=this._rBlock,f=0,u=0;8>u;u++)f|=h[u][((a^c[u])&p[u])>>>0];this._lBlock=a,this._rBlock=s^f}var d=this._lBlock;this._lBlock=this._rBlock,this._rBlock=d,r.call(this,1,1431655765),t.call(this,8,16711935),t.call(this,2,858993459),r.call(this,16,65535),r.call(this,4,252645135),e[i]=this._lBlock,e[i+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});i.DES=c._createHelper(d);var l=s.TripleDES=c.extend({_doReset:function(){var e=this._key,r=e.words;this._des1=d.createEncryptor(n.create(r.slice(0,2))),this._des2=d.createEncryptor(n.create(r.slice(2,4))),this._des3=d.createEncryptor(n.create(r.slice(4,6)))},encryptBlock:function(e,r){this._des1.encryptBlock(e,r),this._des2.decryptBlock(e,r),this._des3.encryptBlock(e,r)},decryptBlock:function(e,r){this._des3.decryptBlock(e,r),this._des2.encryptBlock(e,r),this._des1.decryptBlock(e,r)},keySize:6,ivSize:2,blockSize:2});i.TripleDES=c._createHelper(l)}(),e.TripleDES});
  provide("crypto-js/tripledes", module.exports);
}(global));

// pakmanager:crypto-js/rc4
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/enc-base64'), require('crypto-js/md5'), require('crypto-js/evpkdf'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return function(){function r(){for(var e=this._S,r=this._i,t=this._j,i=0,o=0;4>o;o++){r=(r+1)%256,t=(t+e[r])%256;var n=e[r];e[r]=e[t],e[t]=n,i|=e[(e[r]+e[t])%256]<<24-8*o}return this._i=r,this._j=t,i}var t=e,i=t.lib,o=i.StreamCipher,n=t.algo,c=n.RC4=o.extend({_doReset:function(){for(var e=this._key,r=e.words,t=e.sigBytes,i=this._S=[],o=0;256>o;o++)i[o]=o;for(var o=0,n=0;256>o;o++){var c=o%t,s=255&r[c>>>2]>>>24-8*(c%4);n=(n+i[o]+s)%256;var a=i[o];i[o]=i[n],i[n]=a}this._i=this._j=0},_doProcessBlock:function(e,t){e[t]^=r.call(this)},keySize:8,ivSize:0});t.RC4=o._createHelper(c);var s=n.RC4Drop=c.extend({cfg:c.cfg.extend({drop:192}),_doReset:function(){c._doReset.call(this);for(var e=this.cfg.drop;e>0;e--)r.call(this)}});t.RC4Drop=o._createHelper(s)}(),e.RC4});
  provide("crypto-js/rc4", module.exports);
}(global));

// pakmanager:crypto-js/rabbit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/enc-base64'), require('crypto-js/md5'), require('crypto-js/evpkdf'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return function(){function r(){for(var e=this._X,r=this._C,t=0;8>t;t++)s[t]=r[t];r[0]=0|r[0]+1295307597+this._b,r[1]=0|r[1]+3545052371+(r[0]>>>0<s[0]>>>0?1:0),r[2]=0|r[2]+886263092+(r[1]>>>0<s[1]>>>0?1:0),r[3]=0|r[3]+1295307597+(r[2]>>>0<s[2]>>>0?1:0),r[4]=0|r[4]+3545052371+(r[3]>>>0<s[3]>>>0?1:0),r[5]=0|r[5]+886263092+(r[4]>>>0<s[4]>>>0?1:0),r[6]=0|r[6]+1295307597+(r[5]>>>0<s[5]>>>0?1:0),r[7]=0|r[7]+3545052371+(r[6]>>>0<s[6]>>>0?1:0),this._b=r[7]>>>0<s[7]>>>0?1:0;for(var t=0;8>t;t++){var i=e[t]+r[t],o=65535&i,n=i>>>16,c=((o*o>>>17)+o*n>>>15)+n*n,f=(0|(4294901760&i)*i)+(0|(65535&i)*i);a[t]=c^f}e[0]=0|a[0]+(a[7]<<16|a[7]>>>16)+(a[6]<<16|a[6]>>>16),e[1]=0|a[1]+(a[0]<<8|a[0]>>>24)+a[7],e[2]=0|a[2]+(a[1]<<16|a[1]>>>16)+(a[0]<<16|a[0]>>>16),e[3]=0|a[3]+(a[2]<<8|a[2]>>>24)+a[1],e[4]=0|a[4]+(a[3]<<16|a[3]>>>16)+(a[2]<<16|a[2]>>>16),e[5]=0|a[5]+(a[4]<<8|a[4]>>>24)+a[3],e[6]=0|a[6]+(a[5]<<16|a[5]>>>16)+(a[4]<<16|a[4]>>>16),e[7]=0|a[7]+(a[6]<<8|a[6]>>>24)+a[5]}var t=e,i=t.lib,o=i.StreamCipher,n=t.algo,c=[],s=[],a=[],f=n.Rabbit=o.extend({_doReset:function(){for(var e=this._key.words,t=this.cfg.iv,i=0;4>i;i++)e[i]=16711935&(e[i]<<8|e[i]>>>24)|4278255360&(e[i]<<24|e[i]>>>8);var o=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],n=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var i=0;4>i;i++)r.call(this);for(var i=0;8>i;i++)n[i]^=o[7&i+4];if(t){var c=t.words,s=c[0],a=c[1],f=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),u=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),h=f>>>16|4294901760&u,d=u<<16|65535&f;n[0]^=f,n[1]^=h,n[2]^=u,n[3]^=d,n[4]^=f,n[5]^=h,n[6]^=u,n[7]^=d;for(var i=0;4>i;i++)r.call(this)}},_doProcessBlock:function(e,t){var i=this._X;r.call(this),c[0]=i[0]^i[5]>>>16^i[3]<<16,c[1]=i[2]^i[7]>>>16^i[5]<<16,c[2]=i[4]^i[1]>>>16^i[7]<<16,c[3]=i[6]^i[3]>>>16^i[1]<<16;for(var o=0;4>o;o++)c[o]=16711935&(c[o]<<8|c[o]>>>24)|4278255360&(c[o]<<24|c[o]>>>8),e[t+o]^=c[o]},blockSize:4,ivSize:2});t.Rabbit=o._createHelper(f)}(),e.Rabbit});
  provide("crypto-js/rabbit", module.exports);
}(global));

// pakmanager:crypto-js/rabbit-legacy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/enc-base64'), require('crypto-js/md5'), require('crypto-js/evpkdf'), require('crypto-js/cipher-core')):"function"==typeof define&&define.amd?define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],r):r(e.CryptoJS)})(this,function(e){return function(){function r(){for(var e=this._X,r=this._C,t=0;8>t;t++)s[t]=r[t];r[0]=0|r[0]+1295307597+this._b,r[1]=0|r[1]+3545052371+(r[0]>>>0<s[0]>>>0?1:0),r[2]=0|r[2]+886263092+(r[1]>>>0<s[1]>>>0?1:0),r[3]=0|r[3]+1295307597+(r[2]>>>0<s[2]>>>0?1:0),r[4]=0|r[4]+3545052371+(r[3]>>>0<s[3]>>>0?1:0),r[5]=0|r[5]+886263092+(r[4]>>>0<s[4]>>>0?1:0),r[6]=0|r[6]+1295307597+(r[5]>>>0<s[5]>>>0?1:0),r[7]=0|r[7]+3545052371+(r[6]>>>0<s[6]>>>0?1:0),this._b=r[7]>>>0<s[7]>>>0?1:0;for(var t=0;8>t;t++){var i=e[t]+r[t],o=65535&i,n=i>>>16,c=((o*o>>>17)+o*n>>>15)+n*n,f=(0|(4294901760&i)*i)+(0|(65535&i)*i);a[t]=c^f}e[0]=0|a[0]+(a[7]<<16|a[7]>>>16)+(a[6]<<16|a[6]>>>16),e[1]=0|a[1]+(a[0]<<8|a[0]>>>24)+a[7],e[2]=0|a[2]+(a[1]<<16|a[1]>>>16)+(a[0]<<16|a[0]>>>16),e[3]=0|a[3]+(a[2]<<8|a[2]>>>24)+a[1],e[4]=0|a[4]+(a[3]<<16|a[3]>>>16)+(a[2]<<16|a[2]>>>16),e[5]=0|a[5]+(a[4]<<8|a[4]>>>24)+a[3],e[6]=0|a[6]+(a[5]<<16|a[5]>>>16)+(a[4]<<16|a[4]>>>16),e[7]=0|a[7]+(a[6]<<8|a[6]>>>24)+a[5]}var t=e,i=t.lib,o=i.StreamCipher,n=t.algo,c=[],s=[],a=[],f=n.RabbitLegacy=o.extend({_doReset:function(){var e=this._key.words,t=this.cfg.iv,i=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],o=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var n=0;4>n;n++)r.call(this);for(var n=0;8>n;n++)o[n]^=i[7&n+4];if(t){var c=t.words,s=c[0],a=c[1],f=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),u=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),h=f>>>16|4294901760&u,d=u<<16|65535&f;o[0]^=f,o[1]^=h,o[2]^=u,o[3]^=d,o[4]^=f,o[5]^=h,o[6]^=u,o[7]^=d;for(var n=0;4>n;n++)r.call(this)}},_doProcessBlock:function(e,t){var i=this._X;r.call(this),c[0]=i[0]^i[5]>>>16^i[3]<<16,c[1]=i[2]^i[7]>>>16^i[5]<<16,c[2]=i[4]^i[1]>>>16^i[7]<<16,c[3]=i[6]^i[3]>>>16^i[1]<<16;for(var o=0;4>o;o++)c[o]=16711935&(c[o]<<8|c[o]>>>24)|4278255360&(c[o]<<24|c[o]>>>8),e[t+o]^=c[o]},blockSize:4,ivSize:2});t.RabbitLegacy=o._createHelper(f)}(),e.RabbitLegacy});
  provide("crypto-js/rabbit-legacy", module.exports);
}(global));

// pakmanager:crypto-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(e,r){"object"==typeof exports?module.exports=exports=r( require('crypto-js/core'), require('crypto-js/x64-core'), require('crypto-js/lib-typedarrays'), require('crypto-js/enc-utf16'), require('crypto-js/enc-base64'), require('crypto-js/md5'), require('crypto-js/sha1'), require('crypto-js/sha256'), require('crypto-js/sha224'), require('crypto-js/sha512'), require('crypto-js/sha384'), require('crypto-js/sha3'), require('crypto-js/ripemd160'), require('crypto-js/hmac'), require('crypto-js/pbkdf2'), require('crypto-js/evpkdf'), require('crypto-js/cipher-core'), require('crypto-js/mode-cfb'), require('crypto-js/mode-ctr'), require('crypto-js/mode-ctr-gladman'), require('crypto-js/mode-ofb'), require('crypto-js/mode-ecb'), require('crypto-js/pad-ansix923'), require('crypto-js/pad-iso10126'), require('crypto-js/pad-iso97971'), require('crypto-js/pad-zeropadding'), require('crypto-js/pad-nopadding'), require('crypto-js/format-hex'), require('crypto-js/aes'), require('crypto-js/tripledes'), require('crypto-js/rc4'), require('crypto-js/rabbit'), require('crypto-js/rabbit-legacy')):"function"==typeof define&&define.amd?define(["./core","./x64-core","./lib-typedarrays","./enc-utf16","./enc-base64","./md5","./sha1","./sha256","./sha224","./sha512","./sha384","./sha3","./ripemd160","./hmac","./pbkdf2","./evpkdf","./cipher-core","./mode-cfb","./mode-ctr","./mode-ctr-gladman","./mode-ofb","./mode-ecb","./pad-ansix923","./pad-iso10126","./pad-iso97971","./pad-zeropadding","./pad-nopadding","./format-hex","./aes","./tripledes","./rc4","./rabbit","./rabbit-legacy"],r):r(e.CryptoJS)})(this,function(e){return e});
  provide("crypto-js", module.exports);
}(global));

// pakmanager:expect.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function (global, module) {
    
      var exports = module.exports;
    
      /**
       * Exports.
       */
    
      module.exports = expect;
      expect.Assertion = Assertion;
    
      /**
       * Exports version.
       */
    
      expect.version = '0.3.1';
    
      /**
       * Possible assertion flags.
       */
    
      var flags = {
          not: ['to', 'be', 'have', 'include', 'only']
        , to: ['be', 'have', 'include', 'only', 'not']
        , only: ['have']
        , have: ['own']
        , be: ['an']
      };
    
      function expect (obj) {
        return new Assertion(obj);
      }
    
      /**
       * Constructor
       *
       * @api private
       */
    
      function Assertion (obj, flag, parent) {
        this.obj = obj;
        this.flags = {};
    
        if (undefined != parent) {
          this.flags[flag] = true;
    
          for (var i in parent.flags) {
            if (parent.flags.hasOwnProperty(i)) {
              this.flags[i] = true;
            }
          }
        }
    
        var $flags = flag ? flags[flag] : keys(flags)
          , self = this;
    
        if ($flags) {
          for (var i = 0, l = $flags.length; i < l; i++) {
            // avoid recursion
            if (this.flags[$flags[i]]) continue;
    
            var name = $flags[i]
              , assertion = new Assertion(this.obj, name, this)
    
            if ('function' == typeof Assertion.prototype[name]) {
              // clone the function, make sure we dont touch the prot reference
              var old = this[name];
              this[name] = function () {
                return old.apply(self, arguments);
              };
    
              for (var fn in Assertion.prototype) {
                if (Assertion.prototype.hasOwnProperty(fn) && fn != name) {
                  this[name][fn] = bind(assertion[fn], assertion);
                }
              }
            } else {
              this[name] = assertion;
            }
          }
        }
      }
    
      /**
       * Performs an assertion
       *
       * @api private
       */
    
      Assertion.prototype.assert = function (truth, msg, error, expected) {
        var msg = this.flags.not ? error : msg
          , ok = this.flags.not ? !truth : truth
          , err;
    
        if (!ok) {
          err = new Error(msg.call(this));
          if (arguments.length > 3) {
            err.actual = this.obj;
            err.expected = expected;
            err.showDiff = true;
          }
          throw err;
        }
    
        this.and = new Assertion(this.obj);
      };
    
      /**
       * Check if the value is truthy
       *
       * @api public
       */
    
      Assertion.prototype.ok = function () {
        this.assert(
            !!this.obj
          , function(){ return 'expected ' + i(this.obj) + ' to be truthy' }
          , function(){ return 'expected ' + i(this.obj) + ' to be falsy' });
      };
    
      /**
       * Creates an anonymous function which calls fn with arguments.
       *
       * @api public
       */
    
      Assertion.prototype.withArgs = function() {
        expect(this.obj).to.be.a('function');
        var fn = this.obj;
        var args = Array.prototype.slice.call(arguments);
        return expect(function() { fn.apply(null, args); });
      };
    
      /**
       * Assert that the function throws.
       *
       * @param {Function|RegExp} callback, or regexp to match error string against
       * @api public
       */
    
      Assertion.prototype.throwError =
      Assertion.prototype.throwException = function (fn) {
        expect(this.obj).to.be.a('function');
    
        var thrown = false
          , not = this.flags.not;
    
        try {
          this.obj();
        } catch (e) {
          if (isRegExp(fn)) {
            var subject = 'string' == typeof e ? e : e.message;
            if (not) {
              expect(subject).to.not.match(fn);
            } else {
              expect(subject).to.match(fn);
            }
          } else if ('function' == typeof fn) {
            fn(e);
          }
          thrown = true;
        }
    
        if (isRegExp(fn) && not) {
          // in the presence of a matcher, ensure the `not` only applies to
          // the matching.
          this.flags.not = false;
        }
    
        var name = this.obj.name || 'fn';
        this.assert(
            thrown
          , function(){ return 'expected ' + name + ' to throw an exception' }
          , function(){ return 'expected ' + name + ' not to throw an exception' });
      };
    
      /**
       * Checks if the array is empty.
       *
       * @api public
       */
    
      Assertion.prototype.empty = function () {
        var expectation;
    
        if ('object' == typeof this.obj && null !== this.obj && !isArray(this.obj)) {
          if ('number' == typeof this.obj.length) {
            expectation = !this.obj.length;
          } else {
            expectation = !keys(this.obj).length;
          }
        } else {
          if ('string' != typeof this.obj) {
            expect(this.obj).to.be.an('object');
          }
    
          expect(this.obj).to.have.property('length');
          expectation = !this.obj.length;
        }
    
        this.assert(
            expectation
          , function(){ return 'expected ' + i(this.obj) + ' to be empty' }
          , function(){ return 'expected ' + i(this.obj) + ' to not be empty' });
        return this;
      };
    
      /**
       * Checks if the obj exactly equals another.
       *
       * @api public
       */
    
      Assertion.prototype.be =
      Assertion.prototype.equal = function (obj) {
        this.assert(
            obj === this.obj
          , function(){ return 'expected ' + i(this.obj) + ' to equal ' + i(obj) }
          , function(){ return 'expected ' + i(this.obj) + ' to not equal ' + i(obj) });
        return this;
      };
    
      /**
       * Checks if the obj sortof equals another.
       *
       * @api public
       */
    
      Assertion.prototype.eql = function (obj) {
        this.assert(
            expect.eql(this.obj, obj)
          , function(){ return 'expected ' + i(this.obj) + ' to sort of equal ' + i(obj) }
          , function(){ return 'expected ' + i(this.obj) + ' to sort of not equal ' + i(obj) }
          , obj);
        return this;
      };
    
      /**
       * Assert within start to finish (inclusive).
       *
       * @param {Number} start
       * @param {Number} finish
       * @api public
       */
    
      Assertion.prototype.within = function (start, finish) {
        var range = start + '..' + finish;
        this.assert(
            this.obj >= start && this.obj <= finish
          , function(){ return 'expected ' + i(this.obj) + ' to be within ' + range }
          , function(){ return 'expected ' + i(this.obj) + ' to not be within ' + range });
        return this;
      };
    
      /**
       * Assert typeof / instance of
       *
       * @api public
       */
    
      Assertion.prototype.a =
      Assertion.prototype.an = function (type) {
        if ('string' == typeof type) {
          // proper english in error msg
          var n = /^[aeiou]/.test(type) ? 'n' : '';
    
          // typeof with support for 'array'
          this.assert(
              'array' == type ? isArray(this.obj) :
                'regexp' == type ? isRegExp(this.obj) :
                  'object' == type
                    ? 'object' == typeof this.obj && null !== this.obj
                    : type == typeof this.obj
            , function(){ return 'expected ' + i(this.obj) + ' to be a' + n + ' ' + type }
            , function(){ return 'expected ' + i(this.obj) + ' not to be a' + n + ' ' + type });
        } else {
          // instanceof
          var name = type.name || 'supplied constructor';
          this.assert(
              this.obj instanceof type
            , function(){ return 'expected ' + i(this.obj) + ' to be an instance of ' + name }
            , function(){ return 'expected ' + i(this.obj) + ' not to be an instance of ' + name });
        }
    
        return this;
      };
    
      /**
       * Assert numeric value above _n_.
       *
       * @param {Number} n
       * @api public
       */
    
      Assertion.prototype.greaterThan =
      Assertion.prototype.above = function (n) {
        this.assert(
            this.obj > n
          , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n }
          , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n });
        return this;
      };
    
      /**
       * Assert numeric value below _n_.
       *
       * @param {Number} n
       * @api public
       */
    
      Assertion.prototype.lessThan =
      Assertion.prototype.below = function (n) {
        this.assert(
            this.obj < n
          , function(){ return 'expected ' + i(this.obj) + ' to be below ' + n }
          , function(){ return 'expected ' + i(this.obj) + ' to be above ' + n });
        return this;
      };
    
      /**
       * Assert string value matches _regexp_.
       *
       * @param {RegExp} regexp
       * @api public
       */
    
      Assertion.prototype.match = function (regexp) {
        this.assert(
            regexp.exec(this.obj)
          , function(){ return 'expected ' + i(this.obj) + ' to match ' + regexp }
          , function(){ return 'expected ' + i(this.obj) + ' not to match ' + regexp });
        return this;
      };
    
      /**
       * Assert property "length" exists and has value of _n_.
       *
       * @param {Number} n
       * @api public
       */
    
      Assertion.prototype.length = function (n) {
        expect(this.obj).to.have.property('length');
        var len = this.obj.length;
        this.assert(
            n == len
          , function(){ return 'expected ' + i(this.obj) + ' to have a length of ' + n + ' but got ' + len }
          , function(){ return 'expected ' + i(this.obj) + ' to not have a length of ' + len });
        return this;
      };
    
      /**
       * Assert property _name_ exists, with optional _val_.
       *
       * @param {String} name
       * @param {Mixed} val
       * @api public
       */
    
      Assertion.prototype.property = function (name, val) {
        if (this.flags.own) {
          this.assert(
              Object.prototype.hasOwnProperty.call(this.obj, name)
            , function(){ return 'expected ' + i(this.obj) + ' to have own property ' + i(name) }
            , function(){ return 'expected ' + i(this.obj) + ' to not have own property ' + i(name) });
          return this;
        }
    
        if (this.flags.not && undefined !== val) {
          if (undefined === this.obj[name]) {
            throw new Error(i(this.obj) + ' has no property ' + i(name));
          }
        } else {
          var hasProp;
          try {
            hasProp = name in this.obj
          } catch (e) {
            hasProp = undefined !== this.obj[name]
          }
    
          this.assert(
              hasProp
            , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name) }
            , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name) });
        }
    
        if (undefined !== val) {
          this.assert(
              val === this.obj[name]
            , function(){ return 'expected ' + i(this.obj) + ' to have a property ' + i(name)
              + ' of ' + i(val) + ', but got ' + i(this.obj[name]) }
            , function(){ return 'expected ' + i(this.obj) + ' to not have a property ' + i(name)
              + ' of ' + i(val) });
        }
    
        this.obj = this.obj[name];
        return this;
      };
    
      /**
       * Assert that the array contains _obj_ or string contains _obj_.
       *
       * @param {Mixed} obj|string
       * @api public
       */
    
      Assertion.prototype.string =
      Assertion.prototype.contain = function (obj) {
        if ('string' == typeof this.obj) {
          this.assert(
              ~this.obj.indexOf(obj)
            , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
            , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
        } else {
          this.assert(
              ~indexOf(this.obj, obj)
            , function(){ return 'expected ' + i(this.obj) + ' to contain ' + i(obj) }
            , function(){ return 'expected ' + i(this.obj) + ' to not contain ' + i(obj) });
        }
        return this;
      };
    
      /**
       * Assert exact keys or inclusion of keys by using
       * the `.own` modifier.
       *
       * @param {Array|String ...} keys
       * @api public
       */
    
      Assertion.prototype.key =
      Assertion.prototype.keys = function ($keys) {
        var str
          , ok = true;
    
        $keys = isArray($keys)
          ? $keys
          : Array.prototype.slice.call(arguments);
    
        if (!$keys.length) throw new Error('keys required');
    
        var actual = keys(this.obj)
          , len = $keys.length;
    
        // Inclusion
        ok = every($keys, function (key) {
          return ~indexOf(actual, key);
        });
    
        // Strict
        if (!this.flags.not && this.flags.only) {
          ok = ok && $keys.length == actual.length;
        }
    
        // Key string
        if (len > 1) {
          $keys = map($keys, function (key) {
            return i(key);
          });
          var last = $keys.pop();
          str = $keys.join(', ') + ', and ' + last;
        } else {
          str = i($keys[0]);
        }
    
        // Form
        str = (len > 1 ? 'keys ' : 'key ') + str;
    
        // Have / include
        str = (!this.flags.only ? 'include ' : 'only have ') + str;
    
        // Assertion
        this.assert(
            ok
          , function(){ return 'expected ' + i(this.obj) + ' to ' + str }
          , function(){ return 'expected ' + i(this.obj) + ' to not ' + str });
    
        return this;
      };
    
      /**
       * Assert a failure.
       *
       * @param {String ...} custom message
       * @api public
       */
      Assertion.prototype.fail = function (msg) {
        var error = function() { return msg || "explicit failure"; }
        this.assert(false, error, error);
        return this;
      };
    
      /**
       * Function bind implementation.
       */
    
      function bind (fn, scope) {
        return function () {
          return fn.apply(scope, arguments);
        }
      }
    
      /**
       * Array every compatibility
       *
       * @see bit.ly/5Fq1N2
       * @api public
       */
    
      function every (arr, fn, thisObj) {
        var scope = thisObj || global;
        for (var i = 0, j = arr.length; i < j; ++i) {
          if (!fn.call(scope, arr[i], i, arr)) {
            return false;
          }
        }
        return true;
      }
    
      /**
       * Array indexOf compatibility.
       *
       * @see bit.ly/a5Dxa2
       * @api public
       */
    
      function indexOf (arr, o, i) {
        if (Array.prototype.indexOf) {
          return Array.prototype.indexOf.call(arr, o, i);
        }
    
        if (arr.length === undefined) {
          return -1;
        }
    
        for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0
            ; i < j && arr[i] !== o; i++);
    
        return j <= i ? -1 : i;
      }
    
      // https://gist.github.com/1044128/
      var getOuterHTML = function(element) {
        if ('outerHTML' in element) return element.outerHTML;
        var ns = "http://www.w3.org/1999/xhtml";
        var container = document.createElementNS(ns, '_');
        var xmlSerializer = new XMLSerializer();
        var html;
        if (document.xmlVersion) {
          return xmlSerializer.serializeToString(element);
        } else {
          container.appendChild(element.cloneNode(false));
          html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      };
    
      // Returns true if object is a DOM element.
      var isDOMElement = function (object) {
        if (typeof HTMLElement === 'object') {
          return object instanceof HTMLElement;
        } else {
          return object &&
            typeof object === 'object' &&
            object.nodeType === 1 &&
            typeof object.nodeName === 'string';
        }
      };
    
      /**
       * Inspects an object.
       *
       * @see taken from node.js `util` module (copyright Joyent, MIT license)
       * @api private
       */
    
      function i (obj, showHidden, depth) {
        var seen = [];
    
        function stylize (str) {
          return str;
        }
    
        function format (value, recurseTimes) {
          // Provide a hook for user-specified inspect functions.
          // Check that value is an object with an inspect function on it
          if (value && typeof value.inspect === 'function' &&
              // Filter out the util module, it's inspect function is special
              value !== exports &&
              // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
            return value.inspect(recurseTimes);
          }
    
          // Primitive types cannot have properties
          switch (typeof value) {
            case 'undefined':
              return stylize('undefined', 'undefined');
    
            case 'string':
              var simple = '\'' + json.stringify(value).replace(/^"|"$/g, '')
                                                       .replace(/'/g, "\\'")
                                                       .replace(/\\"/g, '"') + '\'';
              return stylize(simple, 'string');
    
            case 'number':
              return stylize('' + value, 'number');
    
            case 'boolean':
              return stylize('' + value, 'boolean');
          }
          // For some reason typeof null is "object", so special case here.
          if (value === null) {
            return stylize('null', 'null');
          }
    
          if (isDOMElement(value)) {
            return getOuterHTML(value);
          }
    
          // Look up the keys of the object.
          var visible_keys = keys(value);
          var $keys = showHidden ? Object.getOwnPropertyNames(value) : visible_keys;
    
          // Functions without properties can be shortcutted.
          if (typeof value === 'function' && $keys.length === 0) {
            if (isRegExp(value)) {
              return stylize('' + value, 'regexp');
            } else {
              var name = value.name ? ': ' + value.name : '';
              return stylize('[Function' + name + ']', 'special');
            }
          }
    
          // Dates without properties can be shortcutted
          if (isDate(value) && $keys.length === 0) {
            return stylize(value.toUTCString(), 'date');
          }
          
          // Error objects can be shortcutted
          if (value instanceof Error) {
            return stylize("["+value.toString()+"]", 'Error');
          }
    
          var base, type, braces;
          // Determine the object type
          if (isArray(value)) {
            type = 'Array';
            braces = ['[', ']'];
          } else {
            type = 'Object';
            braces = ['{', '}'];
          }
    
          // Make functions say that they are functions
          if (typeof value === 'function') {
            var n = value.name ? ': ' + value.name : '';
            base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
          } else {
            base = '';
          }
    
          // Make dates with properties first say the date
          if (isDate(value)) {
            base = ' ' + value.toUTCString();
          }
    
          if ($keys.length === 0) {
            return braces[0] + base + braces[1];
          }
    
          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return stylize('' + value, 'regexp');
            } else {
              return stylize('[Object]', 'special');
            }
          }
    
          seen.push(value);
    
          var output = map($keys, function (key) {
            var name, str;
            if (value.__lookupGetter__) {
              if (value.__lookupGetter__(key)) {
                if (value.__lookupSetter__(key)) {
                  str = stylize('[Getter/Setter]', 'special');
                } else {
                  str = stylize('[Getter]', 'special');
                }
              } else {
                if (value.__lookupSetter__(key)) {
                  str = stylize('[Setter]', 'special');
                }
              }
            }
            if (indexOf(visible_keys, key) < 0) {
              name = '[' + key + ']';
            }
            if (!str) {
              if (indexOf(seen, value[key]) < 0) {
                if (recurseTimes === null) {
                  str = format(value[key]);
                } else {
                  str = format(value[key], recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                  if (isArray(value)) {
                    str = map(str.split('\n'), function (line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + map(str.split('\n'), function (line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = stylize('[Circular]', 'special');
              }
            }
            if (typeof name === 'undefined') {
              if (type === 'Array' && key.match(/^\d+$/)) {
                return str;
              }
              name = json.stringify('' + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'")
                           .replace(/\\"/g, '"')
                           .replace(/(^"|"$)/g, "'");
                name = stylize(name, 'string');
              }
            }
    
            return name + ': ' + str;
          });
    
          seen.pop();
    
          var numLinesEst = 0;
          var length = reduce(output, function (prev, cur) {
            numLinesEst++;
            if (indexOf(cur, '\n') >= 0) numLinesEst++;
            return prev + cur.length + 1;
          }, 0);
    
          if (length > 50) {
            output = braces[0] +
                     (base === '' ? '' : base + '\n ') +
                     ' ' +
                     output.join(',\n  ') +
                     ' ' +
                     braces[1];
    
          } else {
            output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          }
    
          return output;
        }
        return format(obj, (typeof depth === 'undefined' ? 2 : depth));
      }
    
      expect.stringify = i;
    
      function isArray (ar) {
        return Object.prototype.toString.call(ar) === '[object Array]';
      }
    
      function isRegExp(re) {
        var s;
        try {
          s = '' + re;
        } catch (e) {
          return false;
        }
    
        return re instanceof RegExp || // easy case
               // duck-type for context-switching evalcx case
               typeof(re) === 'function' &&
               re.constructor.name === 'RegExp' &&
               re.compile &&
               re.test &&
               re.exec &&
               s.match(/^\/.*\/[gim]{0,3}$/);
      }
    
      function isDate(d) {
        return d instanceof Date;
      }
    
      function keys (obj) {
        if (Object.keys) {
          return Object.keys(obj);
        }
    
        var keys = [];
    
        for (var i in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, i)) {
            keys.push(i);
          }
        }
    
        return keys;
      }
    
      function map (arr, mapper, that) {
        if (Array.prototype.map) {
          return Array.prototype.map.call(arr, mapper, that);
        }
    
        var other= new Array(arr.length);
    
        for (var i= 0, n = arr.length; i<n; i++)
          if (i in arr)
            other[i] = mapper.call(that, arr[i], i, arr);
    
        return other;
      }
    
      function reduce (arr, fun) {
        if (Array.prototype.reduce) {
          return Array.prototype.reduce.apply(
              arr
            , Array.prototype.slice.call(arguments, 1)
          );
        }
    
        var len = +this.length;
    
        if (typeof fun !== "function")
          throw new TypeError();
    
        // no value to return if no initial value and an empty array
        if (len === 0 && arguments.length === 1)
          throw new TypeError();
    
        var i = 0;
        if (arguments.length >= 2) {
          var rv = arguments[1];
        } else {
          do {
            if (i in this) {
              rv = this[i++];
              break;
            }
    
            // if array contains no values, no initial value to return
            if (++i >= len)
              throw new TypeError();
          } while (true);
        }
    
        for (; i < len; i++) {
          if (i in this)
            rv = fun.call(null, rv, this[i], i, this);
        }
    
        return rv;
      }
    
      /**
       * Asserts deep equality
       *
       * @see taken from node.js `assert` module (copyright Joyent, MIT license)
       * @api private
       */
    
      expect.eql = function eql(actual, expected) {
        // 7.1. All identical values are equivalent, as determined by ===.
        if (actual === expected) {
          return true;
        } else if ('undefined' != typeof Buffer
          && Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
          if (actual.length != expected.length) return false;
    
          for (var i = 0; i < actual.length; i++) {
            if (actual[i] !== expected[i]) return false;
          }
    
          return true;
    
          // 7.2. If the expected value is a Date object, the actual value is
          // equivalent if it is also a Date object that refers to the same time.
        } else if (actual instanceof Date && expected instanceof Date) {
          return actual.getTime() === expected.getTime();
    
          // 7.3. Other pairs that do not both pass typeof value == "object",
          // equivalence is determined by ==.
        } else if (typeof actual != 'object' && typeof expected != 'object') {
          return actual == expected;
        // If both are regular expression use the special `regExpEquiv` method
        // to determine equivalence.
        } else if (isRegExp(actual) && isRegExp(expected)) {
          return regExpEquiv(actual, expected);
        // 7.4. For all other Object pairs, including Array objects, equivalence is
        // determined by having the same number of owned properties (as verified
        // with Object.prototype.hasOwnProperty.call), the same set of keys
        // (although not necessarily the same order), equivalent values for every
        // corresponding key, and an identical "prototype" property. Note: this
        // accounts for both named and indexed properties on Arrays.
        } else {
          return objEquiv(actual, expected);
        }
      };
    
      function isUndefinedOrNull (value) {
        return value === null || value === undefined;
      }
    
      function isArguments (object) {
        return Object.prototype.toString.call(object) == '[object Arguments]';
      }
    
      function regExpEquiv (a, b) {
        return a.source === b.source && a.global === b.global &&
               a.ignoreCase === b.ignoreCase && a.multiline === b.multiline;
      }
    
      function objEquiv (a, b) {
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
          return false;
        // an identical "prototype" property.
        if (a.prototype !== b.prototype) return false;
        //~~~I've managed to break Object.keys through screwy arguments passing.
        //   Converting to array solves the problem.
        if (isArguments(a)) {
          if (!isArguments(b)) {
            return false;
          }
          a = pSlice.call(a);
          b = pSlice.call(b);
          return expect.eql(a, b);
        }
        try{
          var ka = keys(a),
            kb = keys(b),
            key, i;
        } catch (e) {//happens when one is a string literal and the other isn't
          return false;
        }
        // having the same number of owned properties (keys incorporates hasOwnProperty)
        if (ka.length != kb.length)
          return false;
        //the same set of keys (although not necessarily the same order),
        ka.sort();
        kb.sort();
        //~~~cheap key test
        for (i = ka.length - 1; i >= 0; i--) {
          if (ka[i] != kb[i])
            return false;
        }
        //equivalent values for every corresponding key, and
        //~~~possibly expensive deep test
        for (i = ka.length - 1; i >= 0; i--) {
          key = ka[i];
          if (!expect.eql(a[key], b[key]))
             return false;
        }
        return true;
      }
    
      var json = (function () {
        "use strict";
    
        if ('object' == typeof JSON && JSON.parse && JSON.stringify) {
          return {
              parse: nativeJSON.parse
            , stringify: nativeJSON.stringify
          }
        }
    
        var JSON = {};
    
        function f(n) {
            // Format integers to have at least two digits.
            return n < 10 ? '0' + n : n;
        }
    
        function date(d, key) {
          return isFinite(d.valueOf()) ?
              d.getUTCFullYear()     + '-' +
              f(d.getUTCMonth() + 1) + '-' +
              f(d.getUTCDate())      + 'T' +
              f(d.getUTCHours())     + ':' +
              f(d.getUTCMinutes())   + ':' +
              f(d.getUTCSeconds())   + 'Z' : null;
        }
    
        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            gap,
            indent,
            meta = {    // table of character substitutions
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"' : '\\"',
                '\\': '\\\\'
            },
            rep;
    
    
        function quote(string) {
    
      // If the string contains no control characters, no quote characters, and no
      // backslash characters, then we can safely slap some quotes around it.
      // Otherwise we must also replace the offending characters with safe escape
      // sequences.
    
            escapable.lastIndex = 0;
            return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' : '"' + string + '"';
        }
    
    
        function str(key, holder) {
    
      // Produce a string from holder[key].
    
            var i,          // The loop counter.
                k,          // The member key.
                v,          // The member value.
                length,
                mind = gap,
                partial,
                value = holder[key];
    
      // If the value has a toJSON method, call it to obtain a replacement value.
    
            if (value instanceof Date) {
                value = date(key);
            }
    
      // If we were called with a replacer function, then call the replacer to
      // obtain a replacement value.
    
            if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
            }
    
      // What happens next depends on the value's type.
    
            switch (typeof value) {
            case 'string':
                return quote(value);
    
            case 'number':
    
      // JSON numbers must be finite. Encode non-finite numbers as null.
    
                return isFinite(value) ? String(value) : 'null';
    
            case 'boolean':
            case 'null':
    
      // If the value is a boolean or null, convert it to a string. Note:
      // typeof null does not produce 'null'. The case is included here in
      // the remote chance that this gets fixed someday.
    
                return String(value);
    
      // If the type is 'object', we might be dealing with an object or an array or
      // null.
    
            case 'object':
    
      // Due to a specification blunder in ECMAScript, typeof null is 'object',
      // so watch out for that case.
    
                if (!value) {
                    return 'null';
                }
    
      // Make an array to hold the partial results of stringifying this object value.
    
                gap += indent;
                partial = [];
    
      // Is the value an array?
    
                if (Object.prototype.toString.apply(value) === '[object Array]') {
    
      // The value is an array. Stringify every element. Use null as a placeholder
      // for non-JSON values.
    
                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }
    
      // Join all of the elements together, separated with commas, and wrap them in
      // brackets.
    
                    v = partial.length === 0 ? '[]' : gap ?
                        '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                        '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }
    
      // If the replacer is an array, use it to select the members to be stringified.
    
                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        if (typeof rep[i] === 'string') {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {
    
      // Otherwise, iterate through all of the keys in the object.
    
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                }
    
      // Join all of the member texts together, separated with commas,
      // and wrap them in braces.
    
                v = partial.length === 0 ? '{}' : gap ?
                    '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                    '{' + partial.join(',') + '}';
                gap = mind;
                return v;
            }
        }
    
      // If the JSON object does not yet have a stringify method, give it one.
    
        JSON.stringify = function (value, replacer, space) {
    
      // The stringify method takes a value and an optional replacer, and an optional
      // space parameter, and returns a JSON text. The replacer can be a function
      // that can replace values, or an array of strings that will select the keys.
      // A default replacer method can be provided. Use of the space parameter can
      // produce text that is more easily readable.
    
            var i;
            gap = '';
            indent = '';
    
      // If the space parameter is a number, make an indent string containing that
      // many spaces.
    
            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }
    
      // If the space parameter is a string, it will be used as the indent string.
    
            } else if (typeof space === 'string') {
                indent = space;
            }
    
      // If there is a replacer, it must be a function or an array.
      // Otherwise, throw an error.
    
            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }
    
      // Make a fake root object containing our value under the key of ''.
      // Return the result of stringifying the value.
    
            return str('', {'': value});
        };
    
      // If the JSON object does not yet have a parse method, give it one.
    
        JSON.parse = function (text, reviver) {
        // The parse method takes a text and an optional reviver function, and returns
        // a JavaScript value if the text is a valid JSON text.
    
            var j;
    
            function walk(holder, key) {
    
        // The walk method is used to recursively walk the resulting structure so
        // that modifications can be made.
    
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }
    
    
        // Parsing happens in four stages. In the first stage, we replace certain
        // Unicode characters with escape sequences. JavaScript handles many characters
        // incorrectly, either silently deleting them, or treating them as line endings.
    
            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }
    
        // In the second stage, we run the text against regular expressions that look
        // for non-JSON patterns. We are especially concerned with '()' and 'new'
        // because they can cause invocation, and '=' because it can cause mutation.
        // But just to be safe, we want to reject all unexpected forms.
    
        // We split the second stage into 4 regexp operations in order to work around
        // crippling inefficiencies in IE's and Safari's regexp engines. First we
        // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
        // replace all simple value tokens with ']' characters. Third, we delete all
        // open brackets that follow a colon or comma or that begin the text. Finally,
        // we look to see that the remaining characters are only whitespace or ']' or
        // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.
    
            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
    
        // In the third stage we use the eval function to compile the text into a
        // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
        // in JavaScript: it can begin a block or an object literal. We wrap the text
        // in parens to eliminate the ambiguity.
    
                j = eval('(' + text + ')');
    
        // In the optional fourth stage, we recursively walk the new structure, passing
        // each name/value pair to a reviver function for possible transformation.
    
                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }
    
        // If the text is not JSON parseable, then a SyntaxError is thrown.
    
            throw new SyntaxError('JSON.parse');
        };
    
        return JSON;
      })();
    
      if ('undefined' != typeof window) {
        window.expect = module.exports;
      }
    
    })(
        this
      , 'undefined' != typeof module ? module : {exports: {}}
    );
    
  provide("expect.js", module.exports);
}(global));

// pakmanager:mocha/lib/ms
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options.long ? longFormat(val) : shortFormat(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 's':
          return n * s;
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function shortFormat(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function longFormat(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
  provide("mocha/lib/ms", module.exports);
}(global));

// pakmanager:mocha/lib/runnable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter
      , debug = require('debug')('mocha:runnable')
      , milliseconds =  require('mocha/lib/ms');
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Object#toString().
     */
    
    var toString = Object.prototype.toString;
    
    /**
     * Expose `Runnable`.
     */
    
    module.exports = Runnable;
    
    /**
     * Initialize a new `Runnable` with the given `title` and callback `fn`.
     *
     * @param {String} title
     * @param {Function} fn
     * @api private
     */
    
    function Runnable(title, fn) {
      this.title = title;
      this.fn = fn;
      this.async = fn && fn.length;
      this.sync = ! this.async;
      this._timeout = 2000;
      this._slow = 75;
      this.timedOut = false;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Runnable.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Set & get timeout `ms`.
     *
     * @param {Number|String} ms
     * @return {Runnable|Number} ms or self
     * @api private
     */
    
    Runnable.prototype.timeout = function(ms){
      if (0 == arguments.length) return this._timeout;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('timeout %d', ms);
      this._timeout = ms;
      if (this.timer) this.resetTimeout();
      return this;
    };
    
    /**
     * Set & get slow `ms`.
     *
     * @param {Number|String} ms
     * @return {Runnable|Number} ms or self
     * @api private
     */
    
    Runnable.prototype.slow = function(ms){
      if (0 === arguments.length) return this._slow;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('timeout %d', ms);
      this._slow = ms;
      return this;
    };
    
    /**
     * Return the full title generated by recursively
     * concatenating the parent's full title.
     *
     * @return {String}
     * @api public
     */
    
    Runnable.prototype.fullTitle = function(){
      return this.parent.fullTitle() + ' ' + this.title;
    };
    
    /**
     * Clear the timeout.
     *
     * @api private
     */
    
    Runnable.prototype.clearTimeout = function(){
      clearTimeout(this.timer);
    };
    
    /**
     * Inspect the runnable void of private properties.
     *
     * @return {String}
     * @api private
     */
    
    Runnable.prototype.inspect = function(){
      return JSON.stringify(this, function(key, val){
        if ('_' == key[0]) return;
        if ('parent' == key) return '#<Suite>';
        if ('ctx' == key) return '#<Context>';
        return val;
      }, 2);
    };
    
    /**
     * Reset the timeout.
     *
     * @api private
     */
    
    Runnable.prototype.resetTimeout = function(){
      var self = this;
      var ms = this.timeout() || 1e9;
    
      this.clearTimeout();
      this.timer = setTimeout(function(){
        self.callback(new Error('timeout of ' + ms + 'ms exceeded'));
        self.timedOut = true;
      }, ms);
    };
    
    /**
     * Whitelist these globals for this test run
     *
     * @api private
     */
    Runnable.prototype.globals = function(arr){
      var self = this;
      this._allowedGlobals = arr;
    };
    
    /**
     * Run the test and invoke `fn(err)`.
     *
     * @param {Function} fn
     * @api private
     */
    
    Runnable.prototype.run = function(fn){
      var self = this
        , ms = this.timeout()
        , start = new Date
        , ctx = this.ctx
        , finished
        , emitted;
    
      if (ctx) ctx.runnable(this);
    
      // called multiple times
      function multiple(err) {
        if (emitted) return;
        emitted = true;
        self.emit('error', err || new Error('done() called multiple times'));
      }
    
      // finished
      function done(err) {
        if (self.timedOut) return;
        if (finished) return multiple(err);
        self.clearTimeout();
        self.duration = new Date - start;
        finished = true;
        fn(err);
      }
    
      // for .resetTimeout()
      this.callback = done;
    
      // explicit async with `done` argument
      if (this.async) {
        this.resetTimeout();
    
        try {
          this.fn.call(ctx, function(err){
            if (err instanceof Error || toString.call(err) === "[object Error]") return done(err);
            if (null != err) return done(new Error('done() invoked with non-Error: ' + err));
            done();
          });
        } catch (err) {
          done(err);
        }
        return;
      }
    
      if (this.asyncOnly) {
        return done(new Error('--async-only option in use without declaring `done()`'));
      }
    
      // sync or promise-returning
      try {
        if (this.pending) {
          done();
        } else {
          callFn(this.fn);
        }
      } catch (err) {
        done(err);
      }
    
      function callFn(fn) {
        var result = fn.call(ctx);
        if (result && typeof result.then === 'function') {
          self.resetTimeout();
          result.then(function(){ done() }, done);
        } else {
          done();
        }
      }
    };
    
  provide("mocha/lib/runnable", module.exports);
}(global));

// pakmanager:mocha/lib/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var fs = require('fs')
      , path = require('path')
      , join = path.join
      , debug = require('debug')('mocha:watch');
    
    /**
     * Ignored directories.
     */
    
    var ignore = ['node_modules', '.git'];
    
    /**
     * Escape special characters in the given string of html.
     *
     * @param  {String} html
     * @return {String}
     * @api private
     */
    
    exports.escape = function(html){
      return String(html)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    };
    
    /**
     * Array#forEach (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @param {Object} scope
     * @api private
     */
    
    exports.forEach = function(arr, fn, scope){
      for (var i = 0, l = arr.length; i < l; i++)
        fn.call(scope, arr[i], i);
    };
    
    /**
     * Array#map (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @param {Object} scope
     * @api private
     */
    
    exports.map = function(arr, fn, scope){
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++)
        result.push(fn.call(scope, arr[i], i));
      return result;
    };
    
    /**
     * Array#indexOf (<=IE8)
     *
     * @parma {Array} arr
     * @param {Object} obj to find index of
     * @param {Number} start
     * @api private
     */
    
    exports.indexOf = function(arr, obj, start){
      for (var i = start || 0, l = arr.length; i < l; i++) {
        if (arr[i] === obj)
          return i;
      }
      return -1;
    };
    
    /**
     * Array#reduce (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @param {Object} initial value
     * @api private
     */
    
    exports.reduce = function(arr, fn, val){
      var rval = val;
    
      for (var i = 0, l = arr.length; i < l; i++) {
        rval = fn(rval, arr[i], i, arr);
      }
    
      return rval;
    };
    
    /**
     * Array#filter (<=IE8)
     *
     * @param {Array} array
     * @param {Function} fn
     * @api private
     */
    
    exports.filter = function(arr, fn){
      var ret = [];
    
      for (var i = 0, l = arr.length; i < l; i++) {
        var val = arr[i];
        if (fn(val, i, arr)) ret.push(val);
      }
    
      return ret;
    };
    
    /**
     * Object.keys (<=IE8)
     *
     * @param {Object} obj
     * @return {Array} keys
     * @api private
     */
    
    exports.keys = Object.keys || function(obj) {
      var keys = []
        , has = Object.prototype.hasOwnProperty // for `window` on <=IE8
    
      for (var key in obj) {
        if (has.call(obj, key)) {
          keys.push(key);
        }
      }
    
      return keys;
    };
    
    /**
     * Watch the given `files` for changes
     * and invoke `fn(file)` on modification.
     *
     * @param {Array} files
     * @param {Function} fn
     * @api private
     */
    
    exports.watch = function(files, fn){
      var options = { interval: 100 };
      files.forEach(function(file){
        debug('file %s', file);
        fs.watchFile(file, options, function(curr, prev){
          if (prev.mtime < curr.mtime) fn(file);
        });
      });
    };
    
    /**
     * Ignored files.
     */
    
    function ignored(path){
      return !~ignore.indexOf(path);
    }
    
    /**
     * Lookup files in the given `dir`.
     *
     * @return {Array}
     * @api private
     */
    
    exports.files = function(dir, ret){
      ret = ret || [];
    
      fs.readdirSync(dir)
      .filter(ignored)
      .forEach(function(path){
        path = join(dir, path);
        if (fs.statSync(path).isDirectory()) {
          exports.files(path, ret);
        } else if (path.match(/\.(js|coffee|litcoffee|coffee.md)$/)) {
          ret.push(path);
        }
      });
    
      return ret;
    };
    
    /**
     * Compute a slug from the given `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    exports.slug = function(str){
      return str
        .toLowerCase()
        .replace(/ +/g, '-')
        .replace(/[^-\w]/g, '');
    };
    
    /**
     * Strip the function definition from `str`,
     * and re-indent for pre whitespace.
     */
    
    exports.clean = function(str) {
      str = str
        .replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/^\uFEFF/, '')
        .replace(/^function *\(.*\) *{/, '')
        .replace(/\s+\}$/, '');
    
      var spaces = str.match(/^\n?( *)/)[1].length
        , tabs = str.match(/^\n?(\t*)/)[1].length
        , re = new RegExp('^\n?' + (tabs ? '\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');
    
      str = str.replace(re, '');
    
      return exports.trim(str);
    };
    
    /**
     * Escape regular expression characters in `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    exports.escapeRegexp = function(str){
      return str.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
    };
    
    /**
     * Trim the given `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    exports.trim = function(str){
      return str.replace(/^\s+|\s+$/g, '');
    };
    
    /**
     * Parse the given `qs`.
     *
     * @param {String} qs
     * @return {Object}
     * @api private
     */
    
    exports.parseQuery = function(qs){
      return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair){
        var i = pair.indexOf('=')
          , key = pair.slice(0, i)
          , val = pair.slice(++i);
    
        obj[key] = decodeURIComponent(val);
        return obj;
      }, {});
    };
    
    /**
     * Highlight the given string of `js`.
     *
     * @param {String} js
     * @return {String}
     * @api private
     */
    
    function highlight(js) {
      return js
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>')
        .replace(/('.*?')/gm, '<span class="string">$1</span>')
        .replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>')
        .replace(/(\d+)/gm, '<span class="number">$1</span>')
        .replace(/\bnew[ \t]+(\w+)/gm, '<span class="keyword">new</span> <span class="init">$1</span>')
        .replace(/\b(function|new|throw|return|var|if|else)\b/gm, '<span class="keyword">$1</span>')
    }
    
    /**
     * Highlight the contents of tag `name`.
     *
     * @param {String} name
     * @api private
     */
    
    exports.highlightTags = function(name) {
      var code = document.getElementsByTagName(name);
      for (var i = 0, len = code.length; i < len; ++i) {
        code[i].innerHTML = highlight(code[i].innerHTML);
      }
    };
    
  provide("mocha/lib/utils", module.exports);
}(global));

// pakmanager:mocha/lib/hook
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Runnable =  require('mocha/lib/runnable');
    
    /**
     * Expose `Hook`.
     */
    
    module.exports = Hook;
    
    /**
     * Initialize a new `Hook` with the given `title` and callback `fn`.
     *
     * @param {String} title
     * @param {Function} fn
     * @api private
     */
    
    function Hook(title, fn) {
      Runnable.call(this, title, fn);
      this.type = 'hook';
    }
    
    /**
     * Inherit from `Runnable.prototype`.
     */
    
    Hook.prototype.__proto__ = Runnable.prototype;
    
    /**
     * Get or set the test `err`.
     *
     * @param {Error} err
     * @return {Error}
     * @api public
     */
    
    Hook.prototype.error = function(err){
      if (0 == arguments.length) {
        var err = this._error;
        this._error = null;
        return err;
      }
    
      this._error = err;
    };
    
  provide("mocha/lib/hook", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var tty = require('tty')
      , diff = require('diff')
      , ms =  require('mocha/lib/ms')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Check if both stdio streams are associated with a tty.
     */
    
    var isatty = tty.isatty(1) && tty.isatty(2);
    
    /**
     * Expose `Base`.
     */
    
    exports = module.exports = Base;
    
    /**
     * Enable coloring by default.
     */
    
    exports.useColors = isatty || (process.env.MOCHA_COLORS !== undefined);
    
    /**
     * Inline diffs instead of +/-
     */
    
    exports.inlineDiffs = false;
    
    /**
     * Default color map.
     */
    
    exports.colors = {
        'pass': 90
      , 'fail': 31
      , 'bright pass': 92
      , 'bright fail': 91
      , 'bright yellow': 93
      , 'pending': 36
      , 'suite': 0
      , 'error title': 0
      , 'error message': 31
      , 'error stack': 90
      , 'checkmark': 32
      , 'fast': 90
      , 'medium': 33
      , 'slow': 31
      , 'green': 32
      , 'light': 90
      , 'diff gutter': 90
      , 'diff added': 42
      , 'diff removed': 41
    };
    
    /**
     * Default symbol map.
     */
    
    exports.symbols = {
      ok: '✓',
      err: '✖',
      dot: '․'
    };
    
    // With node.js on Windows: use symbols available in terminal default fonts
    if ('win32' == process.platform) {
      exports.symbols.ok = '\u221A';
      exports.symbols.err = '\u00D7';
      exports.symbols.dot = '.';
    }
    
    /**
     * Color `str` with the given `type`,
     * allowing colors to be disabled,
     * as well as user-defined color
     * schemes.
     *
     * @param {String} type
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    var color = exports.color = function(type, str) {
      if (!exports.useColors) return str;
      return '\u001b[' + exports.colors[type] + 'm' + str + '\u001b[0m';
    };
    
    /**
     * Expose term window size, with some
     * defaults for when stderr is not a tty.
     */
    
    exports.window = {
      width: isatty
        ? process.stdout.getWindowSize
          ? process.stdout.getWindowSize(1)[0]
          : tty.getWindowSize()[1]
        : 75
    };
    
    /**
     * Expose some basic cursor interactions
     * that are common among reporters.
     */
    
    exports.cursor = {
      hide: function(){
        isatty && process.stdout.write('\u001b[?25l');
      },
    
      show: function(){
        isatty && process.stdout.write('\u001b[?25h');
      },
    
      deleteLine: function(){
        isatty && process.stdout.write('\u001b[2K');
      },
    
      beginningOfLine: function(){
        isatty && process.stdout.write('\u001b[0G');
      },
    
      CR: function(){
        if (isatty) {
          exports.cursor.deleteLine();
          exports.cursor.beginningOfLine();
        } else {
          process.stdout.write('\r');
        }
      }
    };
    
    /**
     * Outut the given `failures` as a list.
     *
     * @param {Array} failures
     * @api public
     */
    
    exports.list = function(failures){
      console.error();
      failures.forEach(function(test, i){
        // format
        var fmt = color('error title', '  %s) %s:\n')
          + color('error message', '     %s')
          + color('error stack', '\n%s\n');
    
        // msg
        var err = test.err
          , message = err.message || ''
          , stack = err.stack || message
          , index = stack.indexOf(message) + message.length
          , msg = stack.slice(0, index)
          , actual = err.actual
          , expected = err.expected
          , escape = true;
    
        // uncaught
        if (err.uncaught) {
          msg = 'Uncaught ' + msg;
        }
    
        // explicitly show diff
        if (err.showDiff && sameType(actual, expected)) {
          escape = false;
          err.actual = actual = stringify(canonicalize(actual));
          err.expected = expected = stringify(canonicalize(expected));
        }
    
        // actual / expected diff
        if ('string' == typeof actual && 'string' == typeof expected) {
          fmt = color('error title', '  %s) %s:\n%s') + color('error stack', '\n%s\n');
          var match = message.match(/^([^:]+): expected/);
          msg = '\n      ' + color('error message', match ? match[1] : msg);
    
          if (exports.inlineDiffs) {
            msg += inlineDiff(err, escape);
          } else {
            msg += unifiedDiff(err, escape);
          }
        }
    
        // indent stack trace without msg
        stack = stack.slice(index ? index + 1 : index)
          .replace(/^/gm, '  ');
    
        console.error(fmt, (i + 1), test.fullTitle(), msg, stack);
      });
    };
    
    /**
     * Initialize a new `Base` reporter.
     *
     * All other reporters generally
     * inherit from this reporter, providing
     * stats such as test duration, number
     * of tests passed / failed etc.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Base(runner) {
      var self = this
        , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }
        , failures = this.failures = [];
    
      if (!runner) return;
      this.runner = runner;
    
      runner.stats = stats;
    
      runner.on('start', function(){
        stats.start = new Date;
      });
    
      runner.on('suite', function(suite){
        stats.suites = stats.suites || 0;
        suite.root || stats.suites++;
      });
    
      runner.on('test end', function(test){
        stats.tests = stats.tests || 0;
        stats.tests++;
      });
    
      runner.on('pass', function(test){
        stats.passes = stats.passes || 0;
    
        var medium = test.slow() / 2;
        test.speed = test.duration > test.slow()
          ? 'slow'
          : test.duration > medium
            ? 'medium'
            : 'fast';
    
        stats.passes++;
      });
    
      runner.on('fail', function(test, err){
        stats.failures = stats.failures || 0;
        stats.failures++;
        test.err = err;
        failures.push(test);
      });
    
      runner.on('end', function(){
        stats.end = new Date;
        stats.duration = new Date - stats.start;
      });
    
      runner.on('pending', function(){
        stats.pending++;
      });
    }
    
    /**
     * Output common epilogue used by many of
     * the bundled reporters.
     *
     * @api public
     */
    
    Base.prototype.epilogue = function(){
      var stats = this.stats;
      var tests;
      var fmt;
    
      console.log();
    
      // passes
      fmt = color('bright pass', ' ')
        + color('green', ' %d passing')
        + color('light', ' (%s)');
    
      console.log(fmt,
        stats.passes || 0,
        ms(stats.duration));
    
      // pending
      if (stats.pending) {
        fmt = color('pending', ' ')
          + color('pending', ' %d pending');
    
        console.log(fmt, stats.pending);
      }
    
      // failures
      if (stats.failures) {
        fmt = color('fail', '  %d failing');
    
        console.error(fmt,
          stats.failures);
    
        Base.list(this.failures);
        console.error();
      }
    
      console.log();
    };
    
    /**
     * Pad the given `str` to `len`.
     *
     * @param {String} str
     * @param {String} len
     * @return {String}
     * @api private
     */
    
    function pad(str, len) {
      str = String(str);
      return Array(len - str.length + 1).join(' ') + str;
    }
    
    
    /**
     * Returns an inline diff between 2 strings with coloured ANSI output
     *
     * @param {Error} Error with actual/expected
     * @return {String} Diff
     * @api private
     */
    
    function inlineDiff(err, escape) {
      var msg = errorDiff(err, 'WordsWithSpace', escape);
    
      // linenos
      var lines = msg.split('\n');
      if (lines.length > 4) {
        var width = String(lines.length).length;
        msg = lines.map(function(str, i){
          return pad(++i, width) + ' |' + ' ' + str;
        }).join('\n');
      }
    
      // legend
      msg = '\n'
        + color('diff removed', 'actual')
        + ' '
        + color('diff added', 'expected')
        + '\n\n'
        + msg
        + '\n';
    
      // indent
      msg = msg.replace(/^/gm, '      ');
      return msg;
    }
    
    /**
     * Returns a unified diff between 2 strings
     *
     * @param {Error} Error with actual/expected
     * @return {String} Diff
     * @api private
     */
    
    function unifiedDiff(err, escape) {
      var indent = '      ';
      function cleanUp(line) {
        if (escape) {
          line = escapeInvisibles(line);
        }
        if (line[0] === '+') return indent + colorLines('diff added', line);
        if (line[0] === '-') return indent + colorLines('diff removed', line);
        if (line.match(/\@\@/)) return null;
        if (line.match(/\\ No newline/)) return null;
        else return indent + line;
      }
      function notBlank(line) {
        return line != null;
      }
      msg = diff.createPatch('string', err.actual, err.expected);
      var lines = msg.split('\n').splice(4);
      return '\n      '
             + colorLines('diff added',   '+ expected') + ' '
             + colorLines('diff removed', '- actual')
             + '\n\n'
             + lines.map(cleanUp).filter(notBlank).join('\n');
    }
    
    /**
     * Return a character diff for `err`.
     *
     * @param {Error} err
     * @return {String}
     * @api private
     */
    
    function errorDiff(err, type, escape) {
      var actual   = escape ? escapeInvisibles(err.actual)   : err.actual;
      var expected = escape ? escapeInvisibles(err.expected) : err.expected;
      return diff['diff' + type](actual, expected).map(function(str){
        if (str.added) return colorLines('diff added', str.value);
        if (str.removed) return colorLines('diff removed', str.value);
        return str.value;
      }).join('');
    }
    
    /**
     * Returns a string with all invisible characters in plain text
     *
     * @param {String} line
     * @return {String}
     * @api private
     */
    function escapeInvisibles(line) {
        return line.replace(/\t/g, '<tab>')
                   .replace(/\r/g, '<CR>')
                   .replace(/\n/g, '<LF>\n');
    }
    
    /**
     * Color lines for `str`, using the color `name`.
     *
     * @param {String} name
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    function colorLines(name, str) {
      return str.split('\n').map(function(str){
        return color(name, str);
      }).join('\n');
    }
    
    /**
     * Stringify `obj`.
     *
     * @param {Object} obj
     * @return {String}
     * @api private
     */
    
    function stringify(obj) {
      if (obj instanceof RegExp) return obj.toString();
      return JSON.stringify(obj, null, 2);
    }
    
    /**
     * Return a new object that has the keys in sorted order.
     * @param {Object} obj
     * @return {Object}
     * @api private
     */
    
     function canonicalize(obj, stack) {
       stack = stack || [];
    
       if (utils.indexOf(stack, obj) !== -1) return obj;
    
       var canonicalizedObj;
    
       if ('[object Array]' == {}.toString.call(obj)) {
         stack.push(obj);
         canonicalizedObj = utils.map(obj, function(item) {
           return canonicalize(item, stack);
         });
         stack.pop();
       } else if (typeof obj === 'object' && obj !== null) {
         stack.push(obj);
         canonicalizedObj = {};
         utils.forEach(utils.keys(obj).sort(), function(key) {
           canonicalizedObj[key] = canonicalize(obj[key], stack);
         });
         stack.pop();
       } else {
         canonicalizedObj = obj;
       }
    
       return canonicalizedObj;
     }
    
    /**
     * Check that a / b have the same type.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Boolean}
     * @api private
     */
    
    function sameType(a, b) {
      a = Object.prototype.toString.call(a);
      b = Object.prototype.toString.call(b);
      return a == b;
    }
    
    
  provide("mocha/lib/reporters/base", module.exports);
}(global));

// pakmanager:mocha/lib/suite
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter
      , debug = require('debug')('mocha:suite')
      , milliseconds =  require('mocha/lib/ms')
      , utils =  require('mocha/lib/utils')
      , Hook =  require('mocha/lib/hook');
    
    /**
     * Expose `Suite`.
     */
    
    exports = module.exports = Suite;
    
    /**
     * Create a new `Suite` with the given `title`
     * and parent `Suite`. When a suite with the
     * same title is already present, that suite
     * is returned to provide nicer reporter
     * and more flexible meta-testing.
     *
     * @param {Suite} parent
     * @param {String} title
     * @return {Suite}
     * @api public
     */
    
    exports.create = function(parent, title){
      var suite = new Suite(title, parent.ctx);
      suite.parent = parent;
      if (parent.pending) suite.pending = true;
      title = suite.fullTitle();
      parent.addSuite(suite);
      return suite;
    };
    
    /**
     * Initialize a new `Suite` with the given
     * `title` and `ctx`.
     *
     * @param {String} title
     * @param {Context} ctx
     * @api private
     */
    
    function Suite(title, parentContext) {
      this.title = title;
      var context = function() {};
      context.prototype = parentContext;
      this.ctx = new context();
      this.suites = [];
      this.tests = [];
      this.pending = false;
      this._beforeEach = [];
      this._beforeAll = [];
      this._afterEach = [];
      this._afterAll = [];
      this.root = !title;
      this._timeout = 2000;
      this._slow = 75;
      this._bail = false;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Suite.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Return a clone of this `Suite`.
     *
     * @return {Suite}
     * @api private
     */
    
    Suite.prototype.clone = function(){
      var suite = new Suite(this.title);
      debug('clone');
      suite.ctx = this.ctx;
      suite.timeout(this.timeout());
      suite.slow(this.slow());
      suite.bail(this.bail());
      return suite;
    };
    
    /**
     * Set timeout `ms` or short-hand such as "2s".
     *
     * @param {Number|String} ms
     * @return {Suite|Number} for chaining
     * @api private
     */
    
    Suite.prototype.timeout = function(ms){
      if (0 == arguments.length) return this._timeout;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('timeout %d', ms);
      this._timeout = parseInt(ms, 10);
      return this;
    };
    
    /**
     * Set slow `ms` or short-hand such as "2s".
     *
     * @param {Number|String} ms
     * @return {Suite|Number} for chaining
     * @api private
     */
    
    Suite.prototype.slow = function(ms){
      if (0 === arguments.length) return this._slow;
      if ('string' == typeof ms) ms = milliseconds(ms);
      debug('slow %d', ms);
      this._slow = ms;
      return this;
    };
    
    /**
     * Sets whether to bail after first error.
     *
     * @parma {Boolean} bail
     * @return {Suite|Number} for chaining
     * @api private
     */
    
    Suite.prototype.bail = function(bail){
      if (0 == arguments.length) return this._bail;
      debug('bail %s', bail);
      this._bail = bail;
      return this;
    };
    
    /**
     * Run `fn(test[, done])` before running tests.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.beforeAll = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"before all" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._beforeAll.push(hook);
      this.emit('beforeAll', hook);
      return this;
    };
    
    /**
     * Run `fn(test[, done])` after running tests.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.afterAll = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"after all" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._afterAll.push(hook);
      this.emit('afterAll', hook);
      return this;
    };
    
    /**
     * Run `fn(test[, done])` before each test case.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.beforeEach = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"before each" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._beforeEach.push(hook);
      this.emit('beforeEach', hook);
      return this;
    };
    
    /**
     * Run `fn(test[, done])` after each test case.
     *
     * @param {Function} fn
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.afterEach = function(title, fn){
      if (this.pending) return this;
      if ('function' === typeof title) {
        fn = title;
        title = fn.name;
      }
      title = '"after each" hook' + (title ? ': ' + title : '');
    
      var hook = new Hook(title, fn);
      hook.parent = this;
      hook.timeout(this.timeout());
      hook.slow(this.slow());
      hook.ctx = this.ctx;
      this._afterEach.push(hook);
      this.emit('afterEach', hook);
      return this;
    };
    
    /**
     * Add a test `suite`.
     *
     * @param {Suite} suite
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.addSuite = function(suite){
      suite.parent = this;
      suite.timeout(this.timeout());
      suite.slow(this.slow());
      suite.bail(this.bail());
      this.suites.push(suite);
      this.emit('suite', suite);
      return this;
    };
    
    /**
     * Add a `test` to this suite.
     *
     * @param {Test} test
     * @return {Suite} for chaining
     * @api private
     */
    
    Suite.prototype.addTest = function(test){
      test.parent = this;
      test.timeout(this.timeout());
      test.slow(this.slow());
      test.ctx = this.ctx;
      this.tests.push(test);
      this.emit('test', test);
      return this;
    };
    
    /**
     * Return the full title generated by recursively
     * concatenating the parent's full title.
     *
     * @return {String}
     * @api public
     */
    
    Suite.prototype.fullTitle = function(){
      if (this.parent) {
        var full = this.parent.fullTitle();
        if (full) return full + ' ' + this.title;
      }
      return this.title;
    };
    
    /**
     * Return the total number of tests.
     *
     * @return {Number}
     * @api public
     */
    
    Suite.prototype.total = function(){
      return utils.reduce(this.suites, function(sum, suite){
        return sum + suite.total();
      }, 0) + this.tests.length;
    };
    
    /**
     * Iterates through each suite recursively to find
     * all tests. Applies a function in the format
     * `fn(test)`.
     *
     * @param {Function} fn
     * @return {Suite}
     * @api private
     */
    
    Suite.prototype.eachTest = function(fn){
      utils.forEach(this.tests, fn);
      utils.forEach(this.suites, function(suite){
        suite.eachTest(fn);
      });
      return this;
    };
    
  provide("mocha/lib/suite", module.exports);
}(global));

// pakmanager:mocha/lib/test
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Runnable =  require('mocha/lib/runnable');
    
    /**
     * Expose `Test`.
     */
    
    module.exports = Test;
    
    /**
     * Initialize a new `Test` with the given `title` and callback `fn`.
     *
     * @param {String} title
     * @param {Function} fn
     * @api private
     */
    
    function Test(title, fn) {
      Runnable.call(this, title, fn);
      this.pending = !fn;
      this.type = 'test';
    }
    
    /**
     * Inherit from `Runnable.prototype`.
     */
    
    Test.prototype.__proto__ = Runnable.prototype;
    
  provide("mocha/lib/test", module.exports);
}(global));

// pakmanager:mocha/lib/browser/progress
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Expose `Progress`.
     */
    
    module.exports = Progress;
    
    /**
     * Initialize a new `Progress` indicator.
     */
    
    function Progress() {
      this.percent = 0;
      this.size(0);
      this.fontSize(11);
      this.font('helvetica, arial, sans-serif');
    }
    
    /**
     * Set progress size to `n`.
     *
     * @param {Number} n
     * @return {Progress} for chaining
     * @api public
     */
    
    Progress.prototype.size = function(n){
      this._size = n;
      return this;
    };
    
    /**
     * Set text to `str`.
     *
     * @param {String} str
     * @return {Progress} for chaining
     * @api public
     */
    
    Progress.prototype.text = function(str){
      this._text = str;
      return this;
    };
    
    /**
     * Set font size to `n`.
     *
     * @param {Number} n
     * @return {Progress} for chaining
     * @api public
     */
    
    Progress.prototype.fontSize = function(n){
      this._fontSize = n;
      return this;
    };
    
    /**
     * Set font `family`.
     *
     * @param {String} family
     * @return {Progress} for chaining
     */
    
    Progress.prototype.font = function(family){
      this._font = family;
      return this;
    };
    
    /**
     * Update percentage to `n`.
     *
     * @param {Number} n
     * @return {Progress} for chaining
     */
    
    Progress.prototype.update = function(n){
      this.percent = n;
      return this;
    };
    
    /**
     * Draw on `ctx`.
     *
     * @param {CanvasRenderingContext2d} ctx
     * @return {Progress} for chaining
     */
    
    Progress.prototype.draw = function(ctx){
      try {
        var percent = Math.min(this.percent, 100)
          , size = this._size
          , half = size / 2
          , x = half
          , y = half
          , rad = half - 1
          , fontSize = this._fontSize;
      
        ctx.font = fontSize + 'px ' + this._font;
      
        var angle = Math.PI * 2 * (percent / 100);
        ctx.clearRect(0, 0, size, size);
      
        // outer circle
        ctx.strokeStyle = '#9f9f9f';
        ctx.beginPath();
        ctx.arc(x, y, rad, 0, angle, false);
        ctx.stroke();
      
        // inner circle
        ctx.strokeStyle = '#eee';
        ctx.beginPath();
        ctx.arc(x, y, rad - 1, 0, angle, true);
        ctx.stroke();
      
        // text
        var text = this._text || (percent | 0) + '%'
          , w = ctx.measureText(text).width;
      
        ctx.fillText(
            text
          , x - w / 2 + 1
          , y + fontSize / 2 - 1);
      } catch (ex) {} //don't fail if we can't render progress
      return this;
    };
    
  provide("mocha/lib/browser/progress", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/json-cov
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base');
    
    /**
     * Expose `JSONCov`.
     */
    
    exports = module.exports = JSONCov;
    
    /**
     * Initialize a new `JsCoverage` reporter.
     *
     * @param {Runner} runner
     * @param {Boolean} output
     * @api public
     */
    
    function JSONCov(runner, output) {
      var self = this
        , output = 1 == arguments.length ? true : output;
    
      Base.call(this, runner);
    
      var tests = []
        , failures = []
        , passes = [];
    
      runner.on('test end', function(test){
        tests.push(test);
      });
    
      runner.on('pass', function(test){
        passes.push(test);
      });
    
      runner.on('fail', function(test){
        failures.push(test);
      });
    
      runner.on('end', function(){
        var cov = global._$jscoverage || {};
        var result = self.cov = map(cov);
        result.stats = self.stats;
        result.tests = tests.map(clean);
        result.failures = failures.map(clean);
        result.passes = passes.map(clean);
        if (!output) return;
        process.stdout.write(JSON.stringify(result, null, 2 ));
      });
    }
    
    /**
     * Map jscoverage data to a JSON structure
     * suitable for reporting.
     *
     * @param {Object} cov
     * @return {Object}
     * @api private
     */
    
    function map(cov) {
      var ret = {
          instrumentation: 'node-jscoverage'
        , sloc: 0
        , hits: 0
        , misses: 0
        , coverage: 0
        , files: []
      };
    
      for (var filename in cov) {
        var data = coverage(filename, cov[filename]);
        ret.files.push(data);
        ret.hits += data.hits;
        ret.misses += data.misses;
        ret.sloc += data.sloc;
      }
    
      ret.files.sort(function(a, b) {
        return a.filename.localeCompare(b.filename);
      });
    
      if (ret.sloc > 0) {
        ret.coverage = (ret.hits / ret.sloc) * 100;
      }
    
      return ret;
    };
    
    /**
     * Map jscoverage data for a single source file
     * to a JSON structure suitable for reporting.
     *
     * @param {String} filename name of the source file
     * @param {Object} data jscoverage coverage data
     * @return {Object}
     * @api private
     */
    
    function coverage(filename, data) {
      var ret = {
        filename: filename,
        coverage: 0,
        hits: 0,
        misses: 0,
        sloc: 0,
        source: {}
      };
    
      data.source.forEach(function(line, num){
        num++;
    
        if (data[num] === 0) {
          ret.misses++;
          ret.sloc++;
        } else if (data[num] !== undefined) {
          ret.hits++;
          ret.sloc++;
        }
    
        ret.source[num] = {
            source: line
          , coverage: data[num] === undefined
            ? ''
            : data[num]
        };
      });
    
      ret.coverage = ret.hits / ret.sloc * 100;
    
      return ret;
    }
    
    /**
     * Return a plain-object representation of `test`
     * free of cyclic properties etc.
     *
     * @param {Object} test
     * @return {Object}
     * @api private
     */
    
    function clean(test) {
      return {
          title: test.title
        , fullTitle: test.fullTitle()
        , duration: test.duration
      }
    }
    
  provide("mocha/lib/reporters/json-cov", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/bdd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test')
      , utils =  require('mocha/lib/utils');
    
    /**
     * BDD-style interface:
     *
     *      describe('Array', function(){
     *        describe('#indexOf()', function(){
     *          it('should return -1 when not present', function(){
     *
     *          });
     *
     *          it('should return the index when present', function(){
     *
     *          });
     *        });
     *      });
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('pre-require', function(context, file, mocha){
    
        /**
         * Execute before running tests.
         */
    
        context.before = function(name, fn){
          suites[0].beforeAll(name, fn);
        };
    
        /**
         * Execute after running tests.
         */
    
        context.after = function(name, fn){
          suites[0].afterAll(name, fn);
        };
    
        /**
         * Execute before each test case.
         */
    
        context.beforeEach = function(name, fn){
          suites[0].beforeEach(name, fn);
        };
    
        /**
         * Execute after each test case.
         */
    
        context.afterEach = function(name, fn){
          suites[0].afterEach(name, fn);
        };
    
        /**
         * Describe a "suite" with the given `title`
         * and callback `fn` containing nested suites
         * and/or tests.
         */
    
        context.describe = context.context = function(title, fn){
          var suite = Suite.create(suites[0], title);
          suite.file = file;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
          return suite;
        };
    
        /**
         * Pending describe.
         */
    
        context.xdescribe =
        context.xcontext =
        context.describe.skip = function(title, fn){
          var suite = Suite.create(suites[0], title);
          suite.pending = true;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
        };
    
        /**
         * Exclusive suite.
         */
    
        context.describe.only = function(title, fn){
          var suite = context.describe(title, fn);
          mocha.grep(suite.fullTitle());
          return suite;
        };
    
        /**
         * Describe a specification or test-case
         * with the given `title` and callback `fn`
         * acting as a thunk.
         */
    
        context.it = context.specify = function(title, fn){
          var suite = suites[0];
          if (suite.pending) var fn = null;
          var test = new Test(title, fn);
          test.file = file;
          suite.addTest(test);
          return test;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.it.only = function(title, fn){
          var test = context.it(title, fn);
          var reString = '^' + utils.escapeRegexp(test.fullTitle()) + '$';
          mocha.grep(new RegExp(reString));
          return test;
        };
    
        /**
         * Pending test case.
         */
    
        context.xit =
        context.xspecify =
        context.it.skip = function(title){
          context.it(title);
        };
      });
    };
    
  provide("mocha/lib/interfaces/bdd", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/tdd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test')
      , utils =  require('mocha/lib/utils');;
    
    /**
     * TDD-style interface:
     *
     *      suite('Array', function(){
     *        suite('#indexOf()', function(){
     *          suiteSetup(function(){
     *
     *          });
     *
     *          test('should return -1 when not present', function(){
     *
     *          });
     *
     *          test('should return the index when present', function(){
     *
     *          });
     *
     *          suiteTeardown(function(){
     *
     *          });
     *        });
     *      });
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('pre-require', function(context, file, mocha){
    
        /**
         * Execute before each test case.
         */
    
        context.setup = function(name, fn){
          suites[0].beforeEach(name, fn);
        };
    
        /**
         * Execute after each test case.
         */
    
        context.teardown = function(name, fn){
          suites[0].afterEach(name, fn);
        };
    
        /**
         * Execute before the suite.
         */
    
        context.suiteSetup = function(name, fn){
          suites[0].beforeAll(name, fn);
        };
    
        /**
         * Execute after the suite.
         */
    
        context.suiteTeardown = function(name, fn){
          suites[0].afterAll(name, fn);
        };
    
        /**
         * Describe a "suite" with the given `title`
         * and callback `fn` containing nested suites
         * and/or tests.
         */
    
        context.suite = function(title, fn){
          var suite = Suite.create(suites[0], title);
          suite.file = file;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
          return suite;
        };
    
        /**
         * Pending suite.
         */
        context.suite.skip = function(title, fn) {
          var suite = Suite.create(suites[0], title);
          suite.pending = true;
          suites.unshift(suite);
          fn.call(suite);
          suites.shift();
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.suite.only = function(title, fn){
          var suite = context.suite(title, fn);
          mocha.grep(suite.fullTitle());
        };
    
        /**
         * Describe a specification or test-case
         * with the given `title` and callback `fn`
         * acting as a thunk.
         */
    
        context.test = function(title, fn){
          var suite = suites[0];
          if (suite.pending) var fn = null;
          var test = new Test(title, fn);
          test.file = file;
          suite.addTest(test);
          return test;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.test.only = function(title, fn){
          var test = context.test(title, fn);
          var reString = '^' + utils.escapeRegexp(test.fullTitle()) + '$';
          mocha.grep(new RegExp(reString));
        };
    
        /**
         * Pending test case.
         */
    
        context.test.skip = function(title){
          context.test(title);
        };
      });
    };
    
  provide("mocha/lib/interfaces/tdd", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/qunit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test')
      , utils =  require('mocha/lib/utils');
    
    /**
     * QUnit-style interface:
     *
     *     suite('Array');
     *
     *     test('#length', function(){
     *       var arr = [1,2,3];
     *       ok(arr.length == 3);
     *     });
     *
     *     test('#indexOf()', function(){
     *       var arr = [1,2,3];
     *       ok(arr.indexOf(1) == 0);
     *       ok(arr.indexOf(2) == 1);
     *       ok(arr.indexOf(3) == 2);
     *     });
     *
     *     suite('String');
     *
     *     test('#length', function(){
     *       ok('foo'.length == 3);
     *     });
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('pre-require', function(context, file, mocha){
    
        /**
         * Execute before running tests.
         */
    
        context.before = function(name, fn){
          suites[0].beforeAll(name, fn);
        };
    
        /**
         * Execute after running tests.
         */
    
        context.after = function(name, fn){
          suites[0].afterAll(name, fn);
        };
    
        /**
         * Execute before each test case.
         */
    
        context.beforeEach = function(name, fn){
          suites[0].beforeEach(name, fn);
        };
    
        /**
         * Execute after each test case.
         */
    
        context.afterEach = function(name, fn){
          suites[0].afterEach(name, fn);
        };
    
        /**
         * Describe a "suite" with the given `title`.
         */
    
        context.suite = function(title){
          if (suites.length > 1) suites.shift();
          var suite = Suite.create(suites[0], title);
          suite.file = file;
          suites.unshift(suite);
          return suite;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.suite.only = function(title, fn){
          var suite = context.suite(title, fn);
          mocha.grep(suite.fullTitle());
        };
    
        /**
         * Describe a specification or test-case
         * with the given `title` and callback `fn`
         * acting as a thunk.
         */
    
        context.test = function(title, fn){
          var test = new Test(title, fn);
          test.file = file;
          suites[0].addTest(test);
          return test;
        };
    
        /**
         * Exclusive test-case.
         */
    
        context.test.only = function(title, fn){
          var test = context.test(title, fn);
          var reString = '^' + utils.escapeRegexp(test.fullTitle()) + '$';
          mocha.grep(new RegExp(reString));
        };
    
        /**
         * Pending test case.
         */
    
        context.test.skip = function(title){
          context.test(title);
        };
      });
    };
    
  provide("mocha/lib/interfaces/qunit", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces/exports
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Suite =  require('mocha/lib/suite')
      , Test =  require('mocha/lib/test');
    
    /**
     * TDD-style interface:
     *
     *     exports.Array = {
     *       '#indexOf()': {
     *         'should return -1 when the value is not present': function(){
     *
     *         },
     *
     *         'should return the correct index when the value is present': function(){
     *
     *         }
     *       }
     *     };
     *
     */
    
    module.exports = function(suite){
      var suites = [suite];
    
      suite.on('require', visit);
    
      function visit(obj, file) {
        var suite;
        for (var key in obj) {
          if ('function' == typeof obj[key]) {
            var fn = obj[key];
            switch (key) {
              case 'before':
                suites[0].beforeAll(fn);
                break;
              case 'after':
                suites[0].afterAll(fn);
                break;
              case 'beforeEach':
                suites[0].beforeEach(fn);
                break;
              case 'afterEach':
                suites[0].afterEach(fn);
                break;
              default:
                var test = new Test(key, fn);
                test.file = file;
                suites[0].addTest(test);
            }
          } else {
            var suite = Suite.create(suites[0], key);
            suites.unshift(suite);
            visit(obj[key]);
            suites.shift();
          }
        }
      }
    };
    
  provide("mocha/lib/interfaces/exports", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/dot
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , color = Base.color;
    
    /**
     * Expose `Dot`.
     */
    
    exports = module.exports = Dot;
    
    /**
     * Initialize a new `Dot` matrix test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Dot(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , width = Base.window.width * .75 | 0
        , n = 0;
    
      runner.on('start', function(){
        process.stdout.write('\n  ');
      });
    
      runner.on('pending', function(test){
        process.stdout.write(color('pending', Base.symbols.dot));
      });
    
      runner.on('pass', function(test){
        if (++n % width == 0) process.stdout.write('\n  ');
        if ('slow' == test.speed) {
          process.stdout.write(color('bright yellow', Base.symbols.dot));
        } else {
          process.stdout.write(color(test.speed, Base.symbols.dot));
        }
      });
    
      runner.on('fail', function(test, err){
        if (++n % width == 0) process.stdout.write('\n  ');
        process.stdout.write(color('fail', Base.symbols.dot));
      });
    
      runner.on('end', function(){
        console.log();
        self.epilogue();
      });
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Dot.prototype.__proto__ = Base.prototype;
  provide("mocha/lib/reporters/dot", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/doc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Expose `Doc`.
     */
    
    exports = module.exports = Doc;
    
    /**
     * Initialize a new `Doc` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Doc(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , total = runner.total
        , indents = 2;
    
      function indent() {
        return Array(indents).join('  ');
      }
    
      runner.on('suite', function(suite){
        if (suite.root) return;
        ++indents;
        console.log('%s<section class="suite">', indent());
        ++indents;
        console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));
        console.log('%s<dl>', indent());
      });
    
      runner.on('suite end', function(suite){
        if (suite.root) return;
        console.log('%s</dl>', indent());
        --indents;
        console.log('%s</section>', indent());
        --indents;
      });
    
      runner.on('pass', function(test){
        console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));
        var code = utils.escape(utils.clean(test.fn.toString()));
        console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);
      });
    }
    
  provide("mocha/lib/reporters/doc", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/tap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `TAP`.
     */
    
    exports = module.exports = TAP;
    
    /**
     * Initialize a new `TAP` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function TAP(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , n = 1
        , passes = 0
        , failures = 0;
    
      runner.on('start', function(){
        var total = runner.grepTotal(runner.suite);
        console.log('%d..%d', 1, total);
      });
    
      runner.on('test end', function(){
        ++n;
      });
    
      runner.on('pending', function(test){
        console.log('ok %d %s # SKIP -', n, title(test));
      });
    
      runner.on('pass', function(test){
        passes++;
        console.log('ok %d %s', n, title(test));
      });
    
      runner.on('fail', function(test, err){
        failures++;
        console.log('not ok %d %s', n, title(test));
        if (err.stack) console.log(err.stack.replace(/^/gm, '  '));
      });
    
      runner.on('end', function(){
        console.log('# tests ' + (passes + failures));
        console.log('# pass ' + passes);
        console.log('# fail ' + failures);
      });
    }
    
    /**
     * Return a TAP-safe title of `test`
     *
     * @param {Object} test
     * @return {String}
     * @api private
     */
    
    function title(test) {
      return test.fullTitle().replace(/#/g, '');
    }
    
  provide("mocha/lib/reporters/tap", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/json
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `JSON`.
     */
    
    exports = module.exports = JSONReporter;
    
    /**
     * Initialize a new `JSON` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function JSONReporter(runner) {
      var self = this;
      Base.call(this, runner);
    
      var tests = []
        , failures = []
        , passes = [];
    
      runner.on('test end', function(test){
        tests.push(test);
      });
    
      runner.on('pass', function(test){
        passes.push(test);
      });
    
      runner.on('fail', function(test){
        failures.push(test);
      });
    
      runner.on('end', function(){
        var obj = {
          stats: self.stats,
          tests: tests.map(clean),
          failures: failures.map(clean),
          passes: passes.map(clean)
        };
    
        process.stdout.write(JSON.stringify(obj, null, 2));
      });
    }
    
    /**
     * Return a plain-object representation of `test`
     * free of cyclic properties etc.
     *
     * @param {Object} test
     * @return {Object}
     * @api private
     */
    
    function clean(test) {
      return {
        title: test.title,
        fullTitle: test.fullTitle(),
        duration: test.duration,
        err: test.err
      }
    }
    
  provide("mocha/lib/reporters/json", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/html
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils')
      , Progress =  require('mocha/lib/browser/progress')
      , escape = utils.escape;
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Expose `HTML`.
     */
    
    exports = module.exports = HTML;
    
    /**
     * Stats template.
     */
    
    var statsTemplate = '<ul id="mocha-stats">'
      + '<li class="progress"><canvas width="40" height="40"></canvas></li>'
      + '<li class="passes"><a href="#">passes:</a> <em>0</em></li>'
      + '<li class="failures"><a href="#">failures:</a> <em>0</em></li>'
      + '<li class="duration">duration: <em>0</em>s</li>'
      + '</ul>';
    
    /**
     * Initialize a new `HTML` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function HTML(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , total = runner.total
        , stat = fragment(statsTemplate)
        , items = stat.getElementsByTagName('li')
        , passes = items[1].getElementsByTagName('em')[0]
        , passesLink = items[1].getElementsByTagName('a')[0]
        , failures = items[2].getElementsByTagName('em')[0]
        , failuresLink = items[2].getElementsByTagName('a')[0]
        , duration = items[3].getElementsByTagName('em')[0]
        , canvas = stat.getElementsByTagName('canvas')[0]
        , report = fragment('<ul id="mocha-report"></ul>')
        , stack = [report]
        , progress
        , ctx
        , root = document.getElementById('mocha');
    
      if (canvas.getContext) {
        var ratio = window.devicePixelRatio || 1;
        canvas.style.width = canvas.width;
        canvas.style.height = canvas.height;
        canvas.width *= ratio;
        canvas.height *= ratio;
        ctx = canvas.getContext('2d');
        ctx.scale(ratio, ratio);
        progress = new Progress;
      }
    
      if (!root) return error('#mocha div missing, add it to your document');
    
      // pass toggle
      on(passesLink, 'click', function(){
        unhide();
        var name = /pass/.test(report.className) ? '' : ' pass';
        report.className = report.className.replace(/fail|pass/g, '') + name;
        if (report.className.trim()) hideSuitesWithout('test pass');
      });
    
      // failure toggle
      on(failuresLink, 'click', function(){
        unhide();
        var name = /fail/.test(report.className) ? '' : ' fail';
        report.className = report.className.replace(/fail|pass/g, '') + name;
        if (report.className.trim()) hideSuitesWithout('test fail');
      });
    
      root.appendChild(stat);
      root.appendChild(report);
    
      if (progress) progress.size(40);
    
      runner.on('suite', function(suite){
        if (suite.root) return;
    
        // suite
        var url = self.suiteURL(suite);
        var el = fragment('<li class="suite"><h1><a href="%s">%s</a></h1></li>', url, escape(suite.title));
    
        // container
        stack[0].appendChild(el);
        stack.unshift(document.createElement('ul'));
        el.appendChild(stack[0]);
      });
    
      runner.on('suite end', function(suite){
        if (suite.root) return;
        stack.shift();
      });
    
      runner.on('fail', function(test, err){
        if ('hook' == test.type) runner.emit('test end', test);
      });
    
      runner.on('test end', function(test){
        // TODO: add to stats
        var percent = stats.tests / this.total * 100 | 0;
        if (progress) progress.update(percent).draw(ctx);
    
        // update stats
        var ms = new Date - stats.start;
        text(passes, stats.passes);
        text(failures, stats.failures);
        text(duration, (ms / 1000).toFixed(2));
    
        // test
        if ('passed' == test.state) {
          var url = self.testURL(test);
          var el = fragment('<li class="test pass %e"><h2>%e<span class="duration">%ems</span> <a href="%s" class="replay">‣</a></h2></li>', test.speed, test.title, test.duration, url);
        } else if (test.pending) {
          var el = fragment('<li class="test pass pending"><h2>%e</h2></li>', test.title);
        } else {
          var el = fragment('<li class="test fail"><h2>%e <a href="?grep=%e" class="replay">‣</a></h2></li>', test.title, encodeURIComponent(test.fullTitle()));
          var str = test.err.stack || test.err.toString();
    
          // FF / Opera do not add the message
          if (!~str.indexOf(test.err.message)) {
            str = test.err.message + '\n' + str;
          }
    
          // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we
          // check for the result of the stringifying.
          if ('[object Error]' == str) str = test.err.message;
    
          // Safari doesn't give you a stack. Let's at least provide a source line.
          if (!test.err.stack && test.err.sourceURL && test.err.line !== undefined) {
            str += "\n(" + test.err.sourceURL + ":" + test.err.line + ")";
          }
    
          el.appendChild(fragment('<pre class="error">%e</pre>', str));
        }
    
        // toggle code
        // TODO: defer
        if (!test.pending) {
          var h2 = el.getElementsByTagName('h2')[0];
    
          on(h2, 'click', function(){
            pre.style.display = 'none' == pre.style.display
              ? 'block'
              : 'none';
          });
    
          var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));
          el.appendChild(pre);
          pre.style.display = 'none';
        }
    
        // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.
        if (stack[0]) stack[0].appendChild(el);
      });
    }
    
    /**
     * Provide suite URL
     *
     * @param {Object} [suite]
     */
    
    HTML.prototype.suiteURL = function(suite){
      return '?grep=' + encodeURIComponent(suite.fullTitle());
    };
    
    /**
     * Provide test URL
     *
     * @param {Object} [test]
     */
    
    HTML.prototype.testURL = function(test){
      return '?grep=' + encodeURIComponent(test.fullTitle());
    };
    
    /**
     * Display error `msg`.
     */
    
    function error(msg) {
      document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
    }
    
    /**
     * Return a DOM fragment from `html`.
     */
    
    function fragment(html) {
      var args = arguments
        , div = document.createElement('div')
        , i = 1;
    
      div.innerHTML = html.replace(/%([se])/g, function(_, type){
        switch (type) {
          case 's': return String(args[i++]);
          case 'e': return escape(args[i++]);
        }
      });
    
      return div.firstChild;
    }
    
    /**
     * Check for suites that do not have elements
     * with `classname`, and hide them.
     */
    
    function hideSuitesWithout(classname) {
      var suites = document.getElementsByClassName('suite');
      for (var i = 0; i < suites.length; i++) {
        var els = suites[i].getElementsByClassName(classname);
        if (0 == els.length) suites[i].className += ' hidden';
      }
    }
    
    /**
     * Unhide .hidden suites.
     */
    
    function unhide() {
      var els = document.getElementsByClassName('suite hidden');
      for (var i = 0; i < els.length; ++i) {
        els[i].className = els[i].className.replace('suite hidden', 'suite');
      }
    }
    
    /**
     * Set `el` text to `str`.
     */
    
    function text(el, str) {
      if (el.textContent) {
        el.textContent = str;
      } else {
        el.innerText = str;
      }
    }
    
    /**
     * Listen on `event` with callback `fn`.
     */
    
    function on(el, event, fn) {
      if (el.addEventListener) {
        el.addEventListener(event, fn, false);
      } else {
        el.attachEvent('on' + event, fn);
      }
    }
    
  provide("mocha/lib/reporters/html", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/list
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `List`.
     */
    
    exports = module.exports = List;
    
    /**
     * Initialize a new `List` test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function List(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , n = 0;
    
      runner.on('start', function(){
        console.log();
      });
    
      runner.on('test', function(test){
        process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));
      });
    
      runner.on('pending', function(test){
        var fmt = color('checkmark', '  -')
          + color('pending', ' %s');
        console.log(fmt, test.fullTitle());
      });
    
      runner.on('pass', function(test){
        var fmt = color('checkmark', '  '+Base.symbols.dot)
          + color('pass', ' %s: ')
          + color(test.speed, '%dms');
        cursor.CR();
        console.log(fmt, test.fullTitle(), test.duration);
      });
    
      runner.on('fail', function(test, err){
        cursor.CR();
        console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());
      });
    
      runner.on('end', self.epilogue.bind(self));
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    List.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/list", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/min
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base');
    
    /**
     * Expose `Min`.
     */
    
    exports = module.exports = Min;
    
    /**
     * Initialize a new `Min` minimal test reporter (best used with --watch).
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Min(runner) {
      Base.call(this, runner);
    
      runner.on('start', function(){
        // clear screen
        process.stdout.write('\u001b[2J');
        // set cursor position
        process.stdout.write('\u001b[1;3H');
      });
    
      runner.on('end', this.epilogue.bind(this));
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Min.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/min", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/spec
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `Spec`.
     */
    
    exports = module.exports = Spec;
    
    /**
     * Initialize a new `Spec` test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Spec(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , indents = 0
        , n = 0;
    
      function indent() {
        return Array(indents).join('  ')
      }
    
      runner.on('start', function(){
        console.log();
      });
    
      runner.on('suite', function(suite){
        ++indents;
        console.log(color('suite', '%s%s'), indent(), suite.title);
      });
    
      runner.on('suite end', function(suite){
        --indents;
        if (1 == indents) console.log();
      });
    
      runner.on('pending', function(test){
        var fmt = indent() + color('pending', '  - %s');
        console.log(fmt, test.title);
      });
    
      runner.on('pass', function(test){
        if ('fast' == test.speed) {
          var fmt = indent()
            + color('checkmark', '  ' + Base.symbols.ok)
            + color('pass', ' %s ');
          cursor.CR();
          console.log(fmt, test.title);
        } else {
          var fmt = indent()
            + color('checkmark', '  ' + Base.symbols.ok)
            + color('pass', ' %s ')
            + color(test.speed, '(%dms)');
          cursor.CR();
          console.log(fmt, test.title, test.duration);
        }
      });
    
      runner.on('fail', function(test, err){
        cursor.CR();
        console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);
      });
    
      runner.on('end', self.epilogue.bind(self));
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Spec.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/spec", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/nyan
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , color = Base.color;
    
    /**
     * Expose `Dot`.
     */
    
    exports = module.exports = NyanCat;
    
    /**
     * Initialize a new `Dot` matrix test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function NyanCat(runner) {
      Base.call(this, runner);
      var self = this
        , stats = this.stats
        , width = Base.window.width * .75 | 0
        , rainbowColors = this.rainbowColors = self.generateColors()
        , colorIndex = this.colorIndex = 0
        , numerOfLines = this.numberOfLines = 4
        , trajectories = this.trajectories = [[], [], [], []]
        , nyanCatWidth = this.nyanCatWidth = 11
        , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)
        , scoreboardWidth = this.scoreboardWidth = 5
        , tick = this.tick = 0
        , n = 0;
    
      runner.on('start', function(){
        Base.cursor.hide();
        self.draw();
      });
    
      runner.on('pending', function(test){
        self.draw();
      });
    
      runner.on('pass', function(test){
        self.draw();
      });
    
      runner.on('fail', function(test, err){
        self.draw();
      });
    
      runner.on('end', function(){
        Base.cursor.show();
        for (var i = 0; i < self.numberOfLines; i++) write('\n');
        self.epilogue();
      });
    }
    
    /**
     * Draw the nyan cat
     *
     * @api private
     */
    
    NyanCat.prototype.draw = function(){
      this.appendRainbow();
      this.drawScoreboard();
      this.drawRainbow();
      this.drawNyanCat();
      this.tick = !this.tick;
    };
    
    /**
     * Draw the "scoreboard" showing the number
     * of passes, failures and pending tests.
     *
     * @api private
     */
    
    NyanCat.prototype.drawScoreboard = function(){
      var stats = this.stats;
      var colors = Base.colors;
    
      function draw(color, n) {
        write(' ');
        write('\u001b[' + color + 'm' + n + '\u001b[0m');
        write('\n');
      }
    
      draw(colors.green, stats.passes);
      draw(colors.fail, stats.failures);
      draw(colors.pending, stats.pending);
      write('\n');
    
      this.cursorUp(this.numberOfLines);
    };
    
    /**
     * Append the rainbow.
     *
     * @api private
     */
    
    NyanCat.prototype.appendRainbow = function(){
      var segment = this.tick ? '_' : '-';
      var rainbowified = this.rainbowify(segment);
    
      for (var index = 0; index < this.numberOfLines; index++) {
        var trajectory = this.trajectories[index];
        if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();
        trajectory.push(rainbowified);
      }
    };
    
    /**
     * Draw the rainbow.
     *
     * @api private
     */
    
    NyanCat.prototype.drawRainbow = function(){
      var self = this;
    
      this.trajectories.forEach(function(line, index) {
        write('\u001b[' + self.scoreboardWidth + 'C');
        write(line.join(''));
        write('\n');
      });
    
      this.cursorUp(this.numberOfLines);
    };
    
    /**
     * Draw the nyan cat
     *
     * @api private
     */
    
    NyanCat.prototype.drawNyanCat = function() {
      var self = this;
      var startWidth = this.scoreboardWidth + this.trajectories[0].length;
      var color = '\u001b[' + startWidth + 'C';
      var padding = '';
    
      write(color);
      write('_,------,');
      write('\n');
    
      write(color);
      padding = self.tick ? '  ' : '   ';
      write('_|' + padding + '/\\_/\\ ');
      write('\n');
    
      write(color);
      padding = self.tick ? '_' : '__';
      var tail = self.tick ? '~' : '^';
      var face;
      write(tail + '|' + padding + this.face() + ' ');
      write('\n');
    
      write(color);
      padding = self.tick ? ' ' : '  ';
      write(padding + '""  "" ');
      write('\n');
    
      this.cursorUp(this.numberOfLines);
    };
    
    /**
     * Draw nyan cat face.
     *
     * @return {String}
     * @api private
     */
    
    NyanCat.prototype.face = function() {
      var stats = this.stats;
      if (stats.failures) {
        return '( x .x)';
      } else if (stats.pending) {
        return '( o .o)';
      } else if(stats.passes) {
        return '( ^ .^)';
      } else {
        return '( - .-)';
      }
    }
    
    /**
     * Move cursor up `n`.
     *
     * @param {Number} n
     * @api private
     */
    
    NyanCat.prototype.cursorUp = function(n) {
      write('\u001b[' + n + 'A');
    };
    
    /**
     * Move cursor down `n`.
     *
     * @param {Number} n
     * @api private
     */
    
    NyanCat.prototype.cursorDown = function(n) {
      write('\u001b[' + n + 'B');
    };
    
    /**
     * Generate rainbow colors.
     *
     * @return {Array}
     * @api private
     */
    
    NyanCat.prototype.generateColors = function(){
      var colors = [];
    
      for (var i = 0; i < (6 * 7); i++) {
        var pi3 = Math.floor(Math.PI / 3);
        var n = (i * (1.0 / 6));
        var r = Math.floor(3 * Math.sin(n) + 3);
        var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
        var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
        colors.push(36 * r + 6 * g + b + 16);
      }
    
      return colors;
    };
    
    /**
     * Apply rainbow to the given `str`.
     *
     * @param {String} str
     * @return {String}
     * @api private
     */
    
    NyanCat.prototype.rainbowify = function(str){
      var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
      this.colorIndex += 1;
      return '\u001b[38;5;' + color + 'm' + str + '\u001b[0m';
    };
    
    /**
     * Stdout helper.
     */
    
    function write(string) {
      process.stdout.write(string);
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    NyanCat.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/nyan", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/xunit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils')
      , escape = utils.escape;
    
    /**
     * Save timer references to avoid Sinon interfering (see GH-237).
     */
    
    var Date = global.Date
      , setTimeout = global.setTimeout
      , setInterval = global.setInterval
      , clearTimeout = global.clearTimeout
      , clearInterval = global.clearInterval;
    
    /**
     * Expose `XUnit`.
     */
    
    exports = module.exports = XUnit;
    
    /**
     * Initialize a new `XUnit` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function XUnit(runner) {
      Base.call(this, runner);
      var stats = this.stats
        , tests = []
        , self = this;
    
      runner.on('pending', function(test){
        tests.push(test);
      });
    
      runner.on('pass', function(test){
        tests.push(test);
      });
    
      runner.on('fail', function(test){
        tests.push(test);
      });
    
      runner.on('end', function(){
        console.log(tag('testsuite', {
            name: 'Mocha Tests'
          , tests: stats.tests
          , failures: stats.failures
          , errors: stats.failures
          , skipped: stats.tests - stats.failures - stats.passes
          , timestamp: (new Date).toUTCString()
          , time: (stats.duration / 1000) || 0
        }, false));
    
        tests.forEach(test);
        console.log('</testsuite>');
      });
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    XUnit.prototype.__proto__ = Base.prototype;
    
    /**
     * Output tag for the given `test.`
     */
    
    function test(test) {
      var attrs = {
          classname: test.parent.fullTitle()
        , name: test.title
        , time: (test.duration / 1000) || 0
      };
    
      if ('failed' == test.state) {
        var err = test.err;
        attrs.message = escape(err.message);
        console.log(tag('testcase', attrs, false, tag('failure', attrs, false, cdata(err.stack))));
      } else if (test.pending) {
        console.log(tag('testcase', attrs, false, tag('skipped', {}, true)));
      } else {
        console.log(tag('testcase', attrs, true) );
      }
    }
    
    /**
     * HTML tag helper.
     */
    
    function tag(name, attrs, close, content) {
      var end = close ? '/>' : '>'
        , pairs = []
        , tag;
    
      for (var key in attrs) {
        pairs.push(key + '="' + escape(attrs[key]) + '"');
      }
    
      tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;
      if (content) tag += content + '</' + name + end;
      return tag;
    }
    
    /**
     * Return cdata escaped CDATA `str`.
     */
    
    function cdata(str) {
      return '<![CDATA[' + escape(str) + ']]>';
    }
    
  provide("mocha/lib/reporters/xunit", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/markdown
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Expose `Markdown`.
     */
    
    exports = module.exports = Markdown;
    
    /**
     * Initialize a new `Markdown` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Markdown(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , level = 0
        , buf = '';
    
      function title(str) {
        return Array(level).join('#') + ' ' + str;
      }
    
      function indent() {
        return Array(level).join('  ');
      }
    
      function mapTOC(suite, obj) {
        var ret = obj;
        obj = obj[suite.title] = obj[suite.title] || { suite: suite };
        suite.suites.forEach(function(suite){
          mapTOC(suite, obj);
        });
        return ret;
      }
    
      function stringifyTOC(obj, level) {
        ++level;
        var buf = '';
        var link;
        for (var key in obj) {
          if ('suite' == key) continue;
          if (key) link = ' - [' + key + '](#' + utils.slug(obj[key].suite.fullTitle()) + ')\n';
          if (key) buf += Array(level).join('  ') + link;
          buf += stringifyTOC(obj[key], level);
        }
        --level;
        return buf;
      }
    
      function generateTOC(suite) {
        var obj = mapTOC(suite, {});
        return stringifyTOC(obj, 0);
      }
    
      generateTOC(runner.suite);
    
      runner.on('suite', function(suite){
        ++level;
        var slug = utils.slug(suite.fullTitle());
        buf += '<a name="' + slug + '"></a>' + '\n';
        buf += title(suite.title) + '\n';
      });
    
      runner.on('suite end', function(suite){
        --level;
      });
    
      runner.on('pass', function(test){
        var code = utils.clean(test.fn.toString());
        buf += test.title + '.\n';
        buf += '\n```js\n';
        buf += code + '\n';
        buf += '```\n\n';
      });
    
      runner.on('end', function(){
        process.stdout.write('# TOC\n');
        process.stdout.write(generateTOC(runner.suite));
        process.stdout.write(buf);
      });
    }
  provide("mocha/lib/reporters/markdown", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/progress
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `Progress`.
     */
    
    exports = module.exports = Progress;
    
    /**
     * General progress bar color.
     */
    
    Base.colors.progress = 90;
    
    /**
     * Initialize a new `Progress` bar test reporter.
     *
     * @param {Runner} runner
     * @param {Object} options
     * @api public
     */
    
    function Progress(runner, options) {
      Base.call(this, runner);
    
      var self = this
        , options = options || {}
        , stats = this.stats
        , width = Base.window.width * .50 | 0
        , total = runner.total
        , complete = 0
        , max = Math.max;
    
      // default chars
      options.open = options.open || '[';
      options.complete = options.complete || '▬';
      options.incomplete = options.incomplete || Base.symbols.dot;
      options.close = options.close || ']';
      options.verbose = false;
    
      // tests started
      runner.on('start', function(){
        console.log();
        cursor.hide();
      });
    
      // tests complete
      runner.on('test end', function(){
        complete++;
        var incomplete = total - complete
          , percent = complete / total
          , n = width * percent | 0
          , i = width - n;
    
        cursor.CR();
        process.stdout.write('\u001b[J');
        process.stdout.write(color('progress', '  ' + options.open));
        process.stdout.write(Array(n).join(options.complete));
        process.stdout.write(Array(i).join(options.incomplete));
        process.stdout.write(color('progress', options.close));
        if (options.verbose) {
          process.stdout.write(color('progress', ' ' + complete + ' of ' + total));
        }
      });
    
      // tests are complete, output some stats
      // and the failures if any
      runner.on('end', function(){
        cursor.show();
        console.log();
        self.epilogue();
      });
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Progress.prototype.__proto__ = Base.prototype;
    
  provide("mocha/lib/reporters/progress", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/landing
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , cursor = Base.cursor
      , color = Base.color;
    
    /**
     * Expose `Landing`.
     */
    
    exports = module.exports = Landing;
    
    /**
     * Airplane color.
     */
    
    Base.colors.plane = 0;
    
    /**
     * Airplane crash color.
     */
    
    Base.colors['plane crash'] = 31;
    
    /**
     * Runway color.
     */
    
    Base.colors.runway = 90;
    
    /**
     * Initialize a new `Landing` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function Landing(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , width = Base.window.width * .75 | 0
        , total = runner.total
        , stream = process.stdout
        , plane = color('plane', '✈')
        , crashed = -1
        , n = 0;
    
      function runway() {
        var buf = Array(width).join('-');
        return '  ' + color('runway', buf);
      }
    
      runner.on('start', function(){
        stream.write('\n  ');
        cursor.hide();
      });
    
      runner.on('test end', function(test){
        // check if the plane crashed
        var col = -1 == crashed
          ? width * ++n / total | 0
          : crashed;
    
        // show the crash
        if ('failed' == test.state) {
          plane = color('plane crash', '✈');
          crashed = col;
        }
    
        // render landing strip
        stream.write('\u001b[4F\n\n');
        stream.write(runway());
        stream.write('\n  ');
        stream.write(color('runway', Array(col).join('⋅')));
        stream.write(plane)
        stream.write(color('runway', Array(width - col).join('⋅') + '\n'));
        stream.write(runway());
        stream.write('\u001b[0m');
      });
    
      runner.on('end', function(){
        cursor.show();
        console.log();
        self.epilogue();
      });
    }
    
    /**
     * Inherit from `Base.prototype`.
     */
    
    Landing.prototype.__proto__ = Base.prototype;
  provide("mocha/lib/reporters/landing", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/html-cov
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var JSONCov =  require('mocha/lib/reporters/json-cov')
      , fs = require('fs');
    
    /**
     * Expose `HTMLCov`.
     */
    
    exports = module.exports = HTMLCov;
    
    /**
     * Initialize a new `JsCoverage` reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function HTMLCov(runner) {
      var jade = require('jade')
        , file = __dirname + '/templates/coverage.jade'
        , str = fs.readFileSync(file, 'utf8')
        , fn = jade.compile(str, { filename: file })
        , self = this;
    
      JSONCov.call(this, runner, false);
    
      runner.on('end', function(){
        process.stdout.write(fn({
            cov: self.cov
          , coverageClass: coverageClass
        }));
      });
    }
    
    /**
     * Return coverage class for `n`.
     *
     * @return {String}
     * @api private
     */
    
    function coverageClass(n) {
      if (n >= 75) return 'high';
      if (n >= 50) return 'medium';
      if (n >= 25) return 'low';
      return 'terrible';
    }
  provide("mocha/lib/reporters/html-cov", module.exports);
}(global));

// pakmanager:mocha/lib/reporters/json-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Base =  require('mocha/lib/reporters/base')
      , color = Base.color;
    
    /**
     * Expose `List`.
     */
    
    exports = module.exports = List;
    
    /**
     * Initialize a new `List` test reporter.
     *
     * @param {Runner} runner
     * @api public
     */
    
    function List(runner) {
      Base.call(this, runner);
    
      var self = this
        , stats = this.stats
        , total = runner.total;
    
      runner.on('start', function(){
        console.log(JSON.stringify(['start', { total: total }]));
      });
    
      runner.on('pass', function(test){
        console.log(JSON.stringify(['pass', clean(test)]));
      });
    
      runner.on('fail', function(test, err){
        console.log(JSON.stringify(['fail', clean(test)]));
      });
    
      runner.on('end', function(){
        process.stdout.write(JSON.stringify(['end', self.stats]));
      });
    }
    
    /**
     * Return a plain-object representation of `test`
     * free of cyclic properties etc.
     *
     * @param {Object} test
     * @return {Object}
     * @api private
     */
    
    function clean(test) {
      return {
          title: test.title
        , fullTitle: test.fullTitle()
        , duration: test.duration
      }
    }
  provide("mocha/lib/reporters/json-stream", module.exports);
}(global));

// pakmanager:mocha/lib/interfaces
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    exports.bdd =  require('mocha/lib/interfaces/bdd');
    exports.tdd =  require('mocha/lib/interfaces/tdd');
    exports.qunit =  require('mocha/lib/interfaces/qunit');
    exports.exports =  require('mocha/lib/interfaces/exports');
    
  provide("mocha/lib/interfaces", module.exports);
}(global));

// pakmanager:mocha/lib/reporters
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    exports.Base =  require('mocha/lib/reporters/base');
    exports.Dot =  require('mocha/lib/reporters/dot');
    exports.Doc =  require('mocha/lib/reporters/doc');
    exports.TAP =  require('mocha/lib/reporters/tap');
    exports.JSON =  require('mocha/lib/reporters/json');
    exports.HTML =  require('mocha/lib/reporters/html');
    exports.List =  require('mocha/lib/reporters/list');
    exports.Min =  require('mocha/lib/reporters/min');
    exports.Spec =  require('mocha/lib/reporters/spec');
    exports.Nyan =  require('mocha/lib/reporters/nyan');
    exports.XUnit =  require('mocha/lib/reporters/xunit');
    exports.Markdown =  require('mocha/lib/reporters/markdown');
    exports.Progress =  require('mocha/lib/reporters/progress');
    exports.Landing =  require('mocha/lib/reporters/landing');
    exports.JSONCov =  require('mocha/lib/reporters/json-cov');
    exports.HTMLCov =  require('mocha/lib/reporters/html-cov');
    exports.JSONStream =  require('mocha/lib/reporters/json-stream');
    
  provide("mocha/lib/reporters", module.exports);
}(global));

// pakmanager:mocha/lib/context
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Context`.
     */
    
    module.exports = Context;
    
    /**
     * Initialize a new `Context`.
     *
     * @api private
     */
    
    function Context(){}
    
    /**
     * Set or get the context `Runnable` to `runnable`.
     *
     * @param {Runnable} runnable
     * @return {Context}
     * @api private
     */
    
    Context.prototype.runnable = function(runnable){
      if (0 == arguments.length) return this._runnable;
      this.test = this._runnable = runnable;
      return this;
    };
    
    /**
     * Set test timeout `ms`.
     *
     * @param {Number} ms
     * @return {Context} self
     * @api private
     */
    
    Context.prototype.timeout = function(ms){
      this.runnable().timeout(ms);
      return this;
    };
    
    /**
     * Set test slowness threshold `ms`.
     *
     * @param {Number} ms
     * @return {Context} self
     * @api private
     */
    
    Context.prototype.slow = function(ms){
      this.runnable().slow(ms);
      return this;
    };
    
    /**
     * Inspect the context void of `._runnable`.
     *
     * @return {String}
     * @api private
     */
    
    Context.prototype.inspect = function(){
      return JSON.stringify(this, function(key, val){
        if ('_runnable' == key) return;
        if ('test' == key) return;
        return val;
      }, 2);
    };
    
  provide("mocha/lib/context", module.exports);
}(global));

// pakmanager:mocha/lib/runner
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter
      , debug = require('debug')('mocha:runner')
      , Test =  require('mocha/lib/test')
      , utils =  require('mocha/lib/utils')
      , filter = utils.filter
      , keys = utils.keys;
    
    /**
     * Non-enumerable globals.
     */
    
    var globals = [
      'setTimeout',
      'clearTimeout',
      'setInterval',
      'clearInterval',
      'XMLHttpRequest',
      'Date'
    ];
    
    /**
     * Expose `Runner`.
     */
    
    module.exports = Runner;
    
    /**
     * Initialize a `Runner` for the given `suite`.
     *
     * Events:
     *
     *   - `start`  execution started
     *   - `end`  execution complete
     *   - `suite`  (suite) test suite execution started
     *   - `suite end`  (suite) all tests (and sub-suites) have finished
     *   - `test`  (test) test execution started
     *   - `test end`  (test) test completed
     *   - `hook`  (hook) hook execution started
     *   - `hook end`  (hook) hook complete
     *   - `pass`  (test) test passed
     *   - `fail`  (test, err) test failed
     *   - `pending`  (test) test pending
     *
     * @api public
     */
    
    function Runner(suite) {
      var self = this;
      this._globals = [];
      this._abort = false;
      this.suite = suite;
      this.total = suite.total();
      this.failures = 0;
      this.on('test end', function(test){ self.checkGlobals(test); });
      this.on('hook end', function(hook){ self.checkGlobals(hook); });
      this.grep(/.*/);
      this.globals(this.globalProps().concat(extraGlobals()));
    }
    
    /**
     * Wrapper for setImmediate, process.nextTick, or browser polyfill.
     *
     * @param {Function} fn
     * @api private
     */
    
    Runner.immediately = global.setImmediate || process.nextTick;
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Runner.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Run tests with full titles matching `re`. Updates runner.total
     * with number of tests matched.
     *
     * @param {RegExp} re
     * @param {Boolean} invert
     * @return {Runner} for chaining
     * @api public
     */
    
    Runner.prototype.grep = function(re, invert){
      debug('grep %s', re);
      this._grep = re;
      this._invert = invert;
      this.total = this.grepTotal(this.suite);
      return this;
    };
    
    /**
     * Returns the number of tests matching the grep search for the
     * given suite.
     *
     * @param {Suite} suite
     * @return {Number}
     * @api public
     */
    
    Runner.prototype.grepTotal = function(suite) {
      var self = this;
      var total = 0;
    
      suite.eachTest(function(test){
        var match = self._grep.test(test.fullTitle());
        if (self._invert) match = !match;
        if (match) total++;
      });
    
      return total;
    };
    
    /**
     * Return a list of global properties.
     *
     * @return {Array}
     * @api private
     */
    
    Runner.prototype.globalProps = function() {
      var props = utils.keys(global);
    
      // non-enumerables
      for (var i = 0; i < globals.length; ++i) {
        if (~utils.indexOf(props, globals[i])) continue;
        props.push(globals[i]);
      }
    
      return props;
    };
    
    /**
     * Allow the given `arr` of globals.
     *
     * @param {Array} arr
     * @return {Runner} for chaining
     * @api public
     */
    
    Runner.prototype.globals = function(arr){
      if (0 == arguments.length) return this._globals;
      debug('globals %j', arr);
      this._globals = this._globals.concat(arr);
      return this;
    };
    
    /**
     * Check for global variable leaks.
     *
     * @api private
     */
    
    Runner.prototype.checkGlobals = function(test){
      if (this.ignoreLeaks) return;
      var ok = this._globals;
    
      var globals = this.globalProps();
      var leaks;
    
      if (test) {
        ok = ok.concat(test._allowedGlobals || []);
      }
    
      if(this.prevGlobalsLength == globals.length) return;
      this.prevGlobalsLength = globals.length;
    
      leaks = filterLeaks(ok, globals);
      this._globals = this._globals.concat(leaks);
    
      if (leaks.length > 1) {
        this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));
      } else if (leaks.length) {
        this.fail(test, new Error('global leak detected: ' + leaks[0]));
      }
    };
    
    /**
     * Fail the given `test`.
     *
     * @param {Test} test
     * @param {Error} err
     * @api private
     */
    
    Runner.prototype.fail = function(test, err){
      ++this.failures;
      test.state = 'failed';
    
      if ('string' == typeof err) {
        err = new Error('the string "' + err + '" was thrown, throw an Error :)');
      }
    
      this.emit('fail', test, err);
    };
    
    /**
     * Fail the given `hook` with `err`.
     *
     * Hook failures work in the following pattern:
     * - If bail, then exit
     * - Failed `before` hook skips all tests in a suite and subsuites,
     *   but jumps to corresponding `after` hook
     * - Failed `before each` hook skips remaining tests in a
     *   suite and jumps to corresponding `after each` hook,
     *   which is run only once
     * - Failed `after` hook does not alter
     *   execution order
     * - Failed `after each` hook skips remaining tests in a
     *   suite and subsuites, but executes other `after each`
     *   hooks
     *
     * @param {Hook} hook
     * @param {Error} err
     * @api private
     */
    
    Runner.prototype.failHook = function(hook, err){
      this.fail(hook, err);
      if (this.suite.bail()) {
        this.emit('end');
      }
    };
    
    /**
     * Run hook `name` callbacks and then invoke `fn()`.
     *
     * @param {String} name
     * @param {Function} function
     * @api private
     */
    
    Runner.prototype.hook = function(name, fn){
      var suite = this.suite
        , hooks = suite['_' + name]
        , self = this
        , timer;
    
      function next(i) {
        var hook = hooks[i];
        if (!hook) return fn();
        if (self.failures && suite.bail()) return fn();
        self.currentRunnable = hook;
    
        hook.ctx.currentTest = self.test;
    
        self.emit('hook', hook);
    
        hook.on('error', function(err){
          self.failHook(hook, err);
        });
    
        hook.run(function(err){
          hook.removeAllListeners('error');
          var testError = hook.error();
          if (testError) self.fail(self.test, testError);
          if (err) {
            self.failHook(hook, err);
    
            // stop executing hooks, notify callee of hook err
            return fn(err);
          }
          self.emit('hook end', hook);
          delete hook.ctx.currentTest;
          next(++i);
        });
      }
    
      Runner.immediately(function(){
        next(0);
      });
    };
    
    /**
     * Run hook `name` for the given array of `suites`
     * in order, and callback `fn(err, errSuite)`.
     *
     * @param {String} name
     * @param {Array} suites
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.hooks = function(name, suites, fn){
      var self = this
        , orig = this.suite;
    
      function next(suite) {
        self.suite = suite;
    
        if (!suite) {
          self.suite = orig;
          return fn();
        }
    
        self.hook(name, function(err){
          if (err) {
            var errSuite = self.suite;
            self.suite = orig;
            return fn(err, errSuite);
          }
    
          next(suites.pop());
        });
      }
    
      next(suites.pop());
    };
    
    /**
     * Run hooks from the top level down.
     *
     * @param {String} name
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.hookUp = function(name, fn){
      var suites = [this.suite].concat(this.parents()).reverse();
      this.hooks(name, suites, fn);
    };
    
    /**
     * Run hooks from the bottom up.
     *
     * @param {String} name
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.hookDown = function(name, fn){
      var suites = [this.suite].concat(this.parents());
      this.hooks(name, suites, fn);
    };
    
    /**
     * Return an array of parent Suites from
     * closest to furthest.
     *
     * @return {Array}
     * @api private
     */
    
    Runner.prototype.parents = function(){
      var suite = this.suite
        , suites = [];
      while (suite = suite.parent) suites.push(suite);
      return suites;
    };
    
    /**
     * Run the current test and callback `fn(err)`.
     *
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.runTest = function(fn){
      var test = this.test
        , self = this;
    
      if (this.asyncOnly) test.asyncOnly = true;
    
      try {
        test.on('error', function(err){
          self.fail(test, err);
        });
        test.run(fn);
      } catch (err) {
        fn(err);
      }
    };
    
    /**
     * Run tests in the given `suite` and invoke
     * the callback `fn()` when complete.
     *
     * @param {Suite} suite
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.runTests = function(suite, fn){
      var self = this
        , tests = suite.tests.slice()
        , test;
    
    
      function hookErr(err, errSuite, after) {
        // before/after Each hook for errSuite failed:
        var orig = self.suite;
    
        // for failed 'after each' hook start from errSuite parent,
        // otherwise start from errSuite itself
        self.suite = after ? errSuite.parent : errSuite;
    
        if (self.suite) {
          // call hookUp afterEach
          self.hookUp('afterEach', function(err2, errSuite2) {
            self.suite = orig;
            // some hooks may fail even now
            if (err2) return hookErr(err2, errSuite2, true);
            // report error suite
            fn(errSuite);
          });
        } else {
          // there is no need calling other 'after each' hooks
          self.suite = orig;
          fn(errSuite);
        }
      }
    
      function next(err, errSuite) {
        // if we bail after first err
        if (self.failures && suite._bail) return fn();
    
        if (self._abort) return fn();
    
        if (err) return hookErr(err, errSuite, true);
    
        // next test
        test = tests.shift();
    
        // all done
        if (!test) return fn();
    
        // grep
        var match = self._grep.test(test.fullTitle());
        if (self._invert) match = !match;
        if (!match) return next();
    
        // pending
        if (test.pending) {
          self.emit('pending', test);
          self.emit('test end', test);
          return next();
        }
    
        // execute test and hook(s)
        self.emit('test', self.test = test);
        self.hookDown('beforeEach', function(err, errSuite){
    
          if (err) return hookErr(err, errSuite, false);
    
          self.currentRunnable = self.test;
          self.runTest(function(err){
            test = self.test;
    
            if (err) {
              self.fail(test, err);
              self.emit('test end', test);
              return self.hookUp('afterEach', next);
            }
    
            test.state = 'passed';
            self.emit('pass', test);
            self.emit('test end', test);
            self.hookUp('afterEach', next);
          });
        });
      }
    
      this.next = next;
      next();
    };
    
    /**
     * Run the given `suite` and invoke the
     * callback `fn()` when complete.
     *
     * @param {Suite} suite
     * @param {Function} fn
     * @api private
     */
    
    Runner.prototype.runSuite = function(suite, fn){
      var total = this.grepTotal(suite)
        , self = this
        , i = 0;
    
      debug('run suite %s', suite.fullTitle());
    
      if (!total) return fn();
    
      this.emit('suite', this.suite = suite);
    
      function next(errSuite) {
        if (errSuite) {
          // current suite failed on a hook from errSuite
          if (errSuite == suite) {
            // if errSuite is current suite
            // continue to the next sibling suite
            return done();
          } else {
            // errSuite is among the parents of current suite
            // stop execution of errSuite and all sub-suites
            return done(errSuite);
          }
        }
    
        if (self._abort) return done();
    
        var curr = suite.suites[i++];
        if (!curr) return done();
        self.runSuite(curr, next);
      }
    
      function done(errSuite) {
        self.suite = suite;
        self.hook('afterAll', function(){
          self.emit('suite end', suite);
          fn(errSuite);
        });
      }
    
      this.hook('beforeAll', function(err){
        if (err) return done();
        self.runTests(suite, next);
      });
    };
    
    /**
     * Handle uncaught exceptions.
     *
     * @param {Error} err
     * @api private
     */
    
    Runner.prototype.uncaught = function(err){
      debug('uncaught exception %s', err.message);
      var runnable = this.currentRunnable;
      if (!runnable || 'failed' == runnable.state) return;
      runnable.clearTimeout();
      err.uncaught = true;
      this.fail(runnable, err);
    
      // recover from test
      if ('test' == runnable.type) {
        this.emit('test end', runnable);
        this.hookUp('afterEach', this.next);
        return;
      }
    
      // bail on hooks
      this.emit('end');
    };
    
    /**
     * Run the root suite and invoke `fn(failures)`
     * on completion.
     *
     * @param {Function} fn
     * @return {Runner} for chaining
     * @api public
     */
    
    Runner.prototype.run = function(fn){
      var self = this
        , fn = fn || function(){};
    
      function uncaught(err){
        self.uncaught(err);
      }
    
      debug('start');
    
      // callback
      this.on('end', function(){
        debug('end');
        process.removeListener('uncaughtException', uncaught);
        fn(self.failures);
      });
    
      // run suites
      this.emit('start');
      this.runSuite(this.suite, function(){
        debug('finished running');
        self.emit('end');
      });
    
      // uncaught exception
      process.on('uncaughtException', uncaught);
    
      return this;
    };
    
    /**
     * Cleanly abort execution
     *
     * @return {Runner} for chaining
     * @api public
     */
    Runner.prototype.abort = function(){
      debug('aborting');
      this._abort = true;
    }
    
    /**
     * Filter leaks with the given globals flagged as `ok`.
     *
     * @param {Array} ok
     * @param {Array} globals
     * @return {Array}
     * @api private
     */
    
    function filterLeaks(ok, globals) {
      return filter(globals, function(key){
        // Firefox and Chrome exposes iframes as index inside the window object
        if (/^d+/.test(key)) return false;
    
        // in firefox
        // if runner runs in an iframe, this iframe's window.getInterface method not init at first
        // it is assigned in some seconds
        if (global.navigator && /^getInterface/.test(key)) return false;
    
        // an iframe could be approached by window[iframeIndex]
        // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak
        if (global.navigator && /^\d+/.test(key)) return false;
    
        // Opera and IE expose global variables for HTML element IDs (issue #243)
        if (/^mocha-/.test(key)) return false;
    
        var matched = filter(ok, function(ok){
          if (~ok.indexOf('*')) return 0 == key.indexOf(ok.split('*')[0]);
          return key == ok;
        });
        return matched.length == 0 && (!global.navigator || 'onerror' !== key);
      });
    }
    
    /**
     * Array of globals dependent on the environment.
     *
     * @return {Array}
     * @api private
     */
    
     function extraGlobals() {
      if (typeof(process) === 'object' &&
          typeof(process.version) === 'string') {
    
        var nodeVersion = process.version.split('.').reduce(function(a, v) {
          return a << 8 | v;
        });
    
        // 'errno' was renamed to process._errno in v0.9.11.
    
        if (nodeVersion < 0x00090B) {
          return ['errno'];
        }
      }
    
      return [];
     }
    
  provide("mocha/lib/runner", module.exports);
}(global));

// pakmanager:mocha/lib/mocha
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mocha
     * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var path = require('path')
      , utils =  require('mocha/lib/utils');
    
    /**
     * Expose `Mocha`.
     */
    
    exports = module.exports = Mocha;
    
    /**
     * Expose internals.
     */
    
    exports.utils = utils;
    exports.interfaces =  require('mocha/lib/interfaces');
    exports.reporters =  require('mocha/lib/reporters');
    exports.Runnable =  require('mocha/lib/runnable');
    exports.Context =  require('mocha/lib/context');
    exports.Runner =  require('mocha/lib/runner');
    exports.Suite =  require('mocha/lib/suite');
    exports.Hook =  require('mocha/lib/hook');
    exports.Test =  require('mocha/lib/test');
    
    /**
     * Return image `name` path.
     *
     * @param {String} name
     * @return {String}
     * @api private
     */
    
    function image(name) {
      return __dirname + '/../images/' + name + '.png';
    }
    
    /**
     * Setup mocha with `options`.
     *
     * Options:
     *
     *   - `ui` name "bdd", "tdd", "exports" etc
     *   - `reporter` reporter instance, defaults to `mocha.reporters.Dot`
     *   - `globals` array of accepted globals
     *   - `timeout` timeout in milliseconds
     *   - `bail` bail on the first test failure
     *   - `slow` milliseconds to wait before considering a test slow
     *   - `ignoreLeaks` ignore global leaks
     *   - `grep` string or regexp to filter tests with
     *
     * @param {Object} options
     * @api public
     */
    
    function Mocha(options) {
      options = options || {};
      this.files = [];
      this.options = options;
      this.grep(options.grep);
      this.suite = new exports.Suite('', new exports.Context);
      this.ui(options.ui);
      this.bail(options.bail);
      this.reporter(options.reporter);
      if (null != options.timeout) this.timeout(options.timeout);
      this.useColors(options.useColors)
      if (options.slow) this.slow(options.slow);
    
      this.suite.on('pre-require', function (context) {
        exports.afterEach = context.afterEach || context.teardown;
        exports.after = context.after || context.suiteTeardown;
        exports.beforeEach = context.beforeEach || context.setup;
        exports.before = context.before || context.suiteSetup;
        exports.describe = context.describe || context.suite;
        exports.it = context.it || context.test;
        exports.setup = context.setup || context.beforeEach;
        exports.suiteSetup = context.suiteSetup || context.before;
        exports.suiteTeardown = context.suiteTeardown || context.after;
        exports.suite = context.suite || context.describe;
        exports.teardown = context.teardown || context.afterEach;
        exports.test = context.test || context.it;
      });
    }
    
    /**
     * Enable or disable bailing on the first failure.
     *
     * @param {Boolean} [bail]
     * @api public
     */
    
    Mocha.prototype.bail = function(bail){
      if (0 == arguments.length) bail = true;
      this.suite.bail(bail);
      return this;
    };
    
    /**
     * Add test `file`.
     *
     * @param {String} file
     * @api public
     */
    
    Mocha.prototype.addFile = function(file){
      this.files.push(file);
      return this;
    };
    
    /**
     * Set reporter to `reporter`, defaults to "dot".
     *
     * @param {String|Function} reporter name or constructor
     * @api public
     */
    
    Mocha.prototype.reporter = function(reporter){
      if ('function' == typeof reporter) {
        this._reporter = reporter;
      } else {
        reporter = reporter || 'dot';
        var _reporter;
        try { _reporter = require('./reporters/' + reporter); } catch (err) {};
        if (!_reporter) try { _reporter = require(reporter); } catch (err) {};
        if (!_reporter && reporter === 'teamcity')
          console.warn('The Teamcity reporter was moved to a package named ' +
            'mocha-teamcity-reporter ' +
            '(https://npmjs.org/package/mocha-teamcity-reporter).');
        if (!_reporter) throw new Error('invalid reporter "' + reporter + '"');
        this._reporter = _reporter;
      }
      return this;
    };
    
    /**
     * Set test UI `name`, defaults to "bdd".
     *
     * @param {String} bdd
     * @api public
     */
    
    Mocha.prototype.ui = function(name){
      name = name || 'bdd';
      this._ui = exports.interfaces[name];
      if (!this._ui) try { this._ui = require(name); } catch (err) {};
      if (!this._ui) throw new Error('invalid interface "' + name + '"');
      this._ui = this._ui(this.suite);
      return this;
    };
    
    /**
     * Load registered files.
     *
     * @api private
     */
    
    Mocha.prototype.loadFiles = function(fn){
      var self = this;
      var suite = this.suite;
      var pending = this.files.length;
      this.files.forEach(function(file){
        file = path.resolve(file);
        suite.emit('pre-require', global, file, self);
        suite.emit('require', require(file), file, self);
        suite.emit('post-require', global, file, self);
        --pending || (fn && fn());
      });
    };
    
    /**
     * Enable growl support.
     *
     * @api private
     */
    
    Mocha.prototype._growl = function(runner, reporter) {
      var notify = require('growl');
    
      runner.on('end', function(){
        var stats = reporter.stats;
        if (stats.failures) {
          var msg = stats.failures + ' of ' + runner.total + ' tests failed';
          notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });
        } else {
          notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {
              name: 'mocha'
            , title: 'Passed'
            , image: image('ok')
          });
        }
      });
    };
    
    /**
     * Add regexp to grep, if `re` is a string it is escaped.
     *
     * @param {RegExp|String} re
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.grep = function(re){
      this.options.grep = 'string' == typeof re
        ? new RegExp(utils.escapeRegexp(re))
        : re;
      return this;
    };
    
    /**
     * Invert `.grep()` matches.
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.invert = function(){
      this.options.invert = true;
      return this;
    };
    
    /**
     * Ignore global leaks.
     *
     * @param {Boolean} ignore
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.ignoreLeaks = function(ignore){
      this.options.ignoreLeaks = !!ignore;
      return this;
    };
    
    /**
     * Enable global leak checking.
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.checkLeaks = function(){
      this.options.ignoreLeaks = false;
      return this;
    };
    
    /**
     * Enable growl support.
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.growl = function(){
      this.options.growl = true;
      return this;
    };
    
    /**
     * Ignore `globals` array or string.
     *
     * @param {Array|String} globals
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.globals = function(globals){
      this.options.globals = (this.options.globals || []).concat(globals);
      return this;
    };
    
    /**
     * Emit color output.
     *
     * @param {Boolean} colors
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.useColors = function(colors){
      this.options.useColors = arguments.length && colors != undefined
        ? colors
        : true;
      return this;
    };
    
    /**
     * Use inline diffs rather than +/-.
     *
     * @param {Boolean} inlineDiffs
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.useInlineDiffs = function(inlineDiffs) {
      this.options.useInlineDiffs = arguments.length && inlineDiffs != undefined
      ? inlineDiffs
      : false;
      return this;
    };
    
    /**
     * Set the timeout in milliseconds.
     *
     * @param {Number} timeout
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.timeout = function(timeout){
      this.suite.timeout(timeout);
      return this;
    };
    
    /**
     * Set slowness threshold in milliseconds.
     *
     * @param {Number} slow
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.slow = function(slow){
      this.suite.slow(slow);
      return this;
    };
    
    /**
     * Makes all tests async (accepting a callback)
     *
     * @return {Mocha}
     * @api public
     */
    
    Mocha.prototype.asyncOnly = function(){
      this.options.asyncOnly = true;
      return this;
    };
    
    /**
     * Run tests and invoke `fn()` when complete.
     *
     * @param {Function} fn
     * @return {Runner}
     * @api public
     */
    
    Mocha.prototype.run = function(fn){
      if (this.files.length) this.loadFiles();
      var suite = this.suite;
      var options = this.options;
      options.files = this.files;
      var runner = new exports.Runner(suite);
      var reporter = new this._reporter(runner, options);
      runner.ignoreLeaks = false !== options.ignoreLeaks;
      runner.asyncOnly = options.asyncOnly;
      if (options.grep) runner.grep(options.grep, options.invert);
      if (options.globals) runner.globals(options.globals);
      if (options.growl) this._growl(runner, reporter);
      exports.reporters.Base.useColors = options.useColors;
      exports.reporters.Base.inlineDiffs = options.useInlineDiffs;
      return runner.run(fn);
    };
    
  provide("mocha/lib/mocha", module.exports);
}(global));

// pakmanager:mocha
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = process.env.COV
      ? require('./lib-cov/mocha')
      :  require('mocha/lib/mocha');
  provide("mocha", module.exports);
}(global));

// pakmanager:q
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // vim:ts=4:sts=4:sw=4:
    /*!
     *
     * Copyright 2009-2012 Kris Kowal under the terms of the MIT
     * license found at http://github.com/kriskowal/q/raw/master/LICENSE
     *
     * With parts by Tyler Close
     * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
     * at http://www.opensource.org/licenses/mit-license.html
     * Forked at ref_send.js version: 2009-05-11
     *
     * With parts by Mark Miller
     * Copyright (C) 2011 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     */
    
    (function (definition) {
        // Turn off strict mode for this function so we can assign to global.Q
        /* jshint strict: false */
    
        // This file will function properly as a <script> tag, or a module
        // using CommonJS and NodeJS or RequireJS module formats.  In
        // Common/Node/RequireJS, the module exports the Q API and when
        // executed as a simple <script>, it creates a Q global instead.
    
        // Montage Require
        if (typeof bootstrap === "function") {
            bootstrap("promise", definition);
    
        // CommonJS
        } else if (typeof exports === "object") {
            module.exports = definition();
    
        // RequireJS
        } else if (typeof define === "function" && define.amd) {
            define(definition);
    
        // SES (Secure EcmaScript)
        } else if (typeof ses !== "undefined") {
            if (!ses.ok()) {
                return;
            } else {
                ses.makeQ = definition;
            }
    
        // <script>
        } else {
            Q = definition();
        }
    
    })(function () {
    "use strict";
    
    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }
    
    // All code after this point will be filtered from stack traces reported
    // by Q.
    var qStartingLine = captureLine();
    var qFileName;
    
    // shims
    
    // used for fallback in "allResolved"
    var noop = function () {};
    
    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    var nextTick =(function () {
        // linked list of tasks (single, with head node)
        var head = {task: void 0, next: null};
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
    
        function flush() {
            /* jshint loopfunc: true */
    
            while (head.next) {
                head = head.next;
                var task = head.task;
                head.task = void 0;
                var domain = head.domain;
    
                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }
    
                try {
                    task();
    
                } catch (e) {
                    if (isNodeJS) {
                        // In node, uncaught exceptions are considered fatal errors.
                        // Re-throw them synchronously to interrupt flushing!
    
                        // Ensure continuation if the uncaught exception is suppressed
                        // listening "uncaughtException" events (as domains does).
                        // Continue in next event to avoid tick recursion.
                        if (domain) {
                            domain.exit();
                        }
                        setTimeout(flush, 0);
                        if (domain) {
                            domain.enter();
                        }
    
                        throw e;
    
                    } else {
                        // In browsers, uncaught exceptions are not fatal.
                        // Re-throw them asynchronously to avoid slow-downs.
                        setTimeout(function() {
                           throw e;
                        }, 0);
                    }
                }
    
                if (domain) {
                    domain.exit();
                }
            }
    
            flushing = false;
        }
    
        nextTick = function (task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };
    
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
    
        if (typeof process !== "undefined" && process.nextTick) {
            // Node.js before 0.9. Note that some fake-Node environments, like the
            // Mocha test runner, introduce a `process` global without a `nextTick`.
            isNodeJS = true;
    
            requestTick = function () {
                process.nextTick(flush);
            };
    
        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if (typeof window !== "undefined") {
                requestTick = setImmediate.bind(window, flush);
            } else {
                requestTick = function () {
                    setImmediate(flush);
                };
            }
    
        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function () {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function () {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function () {
                setTimeout(flush, 0);
                requestPortTick();
            };
    
        } else {
            // old browsers
            requestTick = function () {
                setTimeout(flush, 0);
            };
        }
    
        return nextTick;
    })();
    
    // Attempt to make generics safe in the face of downstream
    // modifications.
    // There is no situation where this is necessary.
    // If you need a security guarantee, these primordials need to be
    // deeply frozen anyway, and if you don’t need a security guarantee,
    // this is just plain paranoid.
    // However, this **might** have the nice side-effect of reducing the size of
    // the minified code by reducing x.call() to merely x()
    // See Mark Miller’s explanation of what this does.
    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;
    function uncurryThis(f) {
        return function () {
            return call.apply(f, arguments);
        };
    }
    // This is equivalent, but slower:
    // uncurryThis = Function_bind.bind(Function_bind.call);
    // http://jsperf.com/uncurrythis
    
    var array_slice = uncurryThis(Array.prototype.slice);
    
    var array_reduce = uncurryThis(
        Array.prototype.reduce || function (callback, basis) {
            var index = 0,
                length = this.length;
            // concerning the initial value, if one is not provided
            if (arguments.length === 1) {
                // seek to the first value in the array, accounting
                // for the possibility that is is a sparse array
                do {
                    if (index in this) {
                        basis = this[index++];
                        break;
                    }
                    if (++index >= length) {
                        throw new TypeError();
                    }
                } while (1);
            }
            // reduce
            for (; index < length; index++) {
                // account for the possibility that the array is sparse
                if (index in this) {
                    basis = callback(basis, this[index], index);
                }
            }
            return basis;
        }
    );
    
    var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function (value) {
            // not a very good shim, but good enough for our one use of it
            for (var i = 0; i < this.length; i++) {
                if (this[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    );
    
    var array_map = uncurryThis(
        Array.prototype.map || function (callback, thisp) {
            var self = this;
            var collect = [];
            array_reduce(self, function (undefined, value, index) {
                collect.push(callback.call(thisp, value, index, self));
            }, void 0);
            return collect;
        }
    );
    
    var object_create = Object.create || function (prototype) {
        function Type() { }
        Type.prototype = prototype;
        return new Type();
    };
    
    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    
    var object_keys = Object.keys || function (object) {
        var keys = [];
        for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    
    var object_toString = uncurryThis(Object.prototype.toString);
    
    function isObject(value) {
        return value === Object(value);
    }
    
    // generator related shims
    
    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return (
            object_toString(exception) === "[object StopIteration]" ||
            exception instanceof QReturnValue
        );
    }
    
    // FIXME: Remove this helper and Q.return once ES6 generators are in
    // SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function (value) {
            this.value = value;
        };
    }
    
    // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
    // engine that has a deployed base of browsers that support generators.
    // However, SM's generators use the Python-inspired semantics of
    // outdated ES6 drafts.  We would like to support ES6, but we'd also
    // like to make it possible to use generators in deployed browsers, so
    // we also support Python-style generators.  At some point we can remove
    // this block.
    var hasES6Generators;
    try {
        /* jshint evil: true, nonew: false */
        new Function("(function* (){ yield 1; })");
        hasES6Generators = true;
    } catch (e) {
        hasES6Generators = false;
    }
    
    // long stack traces
    
    var STACK_JUMP_SEPARATOR = "From previous event:";
    
    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks &&
            promise.stack &&
            typeof error === "object" &&
            error !== null &&
            error.stack &&
            error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
        ) {
            var stacks = [];
            for (var p = promise; !!p; p = p.source) {
                if (p.stack) {
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);
    
            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks);
        }
    }
    
    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];
    
            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }
    
    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 ||
               stackLine.indexOf("(node.js:") !== -1;
    }
    
    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
        }
    
        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
        }
    
        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
        }
    }
    
    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
    
        if (!fileNameAndLineNumber) {
            return false;
        }
    
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
    
        return fileName === qFileName &&
            lineNumber >= qStartingLine &&
            lineNumber <= qEndingLine;
    }
    
    // discover own file name and line number range for filtering stack
    // traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }
    
        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }
    
            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }
    
    function deprecate(callback, name, alternative) {
        return function () {
            if (typeof console !== "undefined" &&
                typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative +
                             " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }
    
    // end of shims
    // beginning of real work
    
    /**
     * Constructs a promise for an immediate reference, passes promises through, or
     * coerces promises from different systems.
     * @param value immediate reference or promise
     */
    function Q(value) {
        // If the object is already a Promise, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (isPromise(value)) {
            return value;
        }
    
        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }
    Q.resolve = Q;
    
    /**
     * Performs a task in a future turn of the event loop.
     * @param {Function} task
     */
    Q.nextTick = nextTick;
    
    /**
     * Controls whether or not long stack traces will be on
     */
    Q.longStackSupport = false;
    
    /**
     * Constructs a {promise, resolve, reject} object.
     *
     * `resolve` is a callback to invoke with a more resolved value for the
     * promise. To fulfill the promise, invoke `resolve` with any value that is
     * not a thenable. To reject the promise, invoke `resolve` with a rejected
     * thenable, or invoke `reject` with the reason directly. To resolve the
     * promise to another thenable, thus putting it in the same state, invoke
     * `resolve` with that other thenable.
     */
    Q.defer = defer;
    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [], progressListeners = [], resolvedPromise;
    
        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);
    
        promise.promiseDispatch = function (resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) { // progress operand
                    progressListeners.push(operands[1]);
                }
            } else {
                nextTick(function () {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };
    
        // XXX deprecated
        promise.valueOf = function () {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };
    
        promise.inspect = function () {
            if (!resolvedPromise) {
                return { state: "pending" };
            }
            return resolvedPromise.inspect();
        };
    
        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promise]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
        }
    
        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
    
        function become(newPromise) {
            resolvedPromise = newPromise;
            promise.source = newPromise;
    
            array_reduce(messages, function (undefined, message) {
                nextTick(function () {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);
    
            messages = void 0;
            progressListeners = void 0;
        }
    
        deferred.promise = promise;
        deferred.resolve = function (value) {
            if (resolvedPromise) {
                return;
            }
    
            become(Q(value));
        };
    
        deferred.fulfill = function (value) {
            if (resolvedPromise) {
                return;
            }
    
            become(fulfill(value));
        };
        deferred.reject = function (reason) {
            if (resolvedPromise) {
                return;
            }
    
            become(reject(reason));
        };
        deferred.notify = function (progress) {
            if (resolvedPromise) {
                return;
            }
    
            array_reduce(progressListeners, function (undefined, progressListener) {
                nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        };
    
        return deferred;
    }
    
    /**
     * Creates a Node-style callback that will resolve or reject the deferred
     * promise.
     * @returns a nodeback
     */
    defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };
    
    /**
     * @param resolver {Function} a function that returns nothing and accepts
     * the resolve, reject, and notify functions for a deferred.
     * @returns a promise that may be resolved with the given resolve and reject
     * functions, or rejected by a thrown exception in resolver
     */
    Q.promise = promise;
    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }
    
    // XXX experimental.  This method is a way to denote that a local value is
    // serializable and should be immediately dispatched to a remote upon request,
    // instead of passing a reference.
    Q.passByCopy = function (object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };
    
    Promise.prototype.passByCopy = function () {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };
    
    /**
     * If two promises eventually fulfill to the same value, promises that value,
     * but otherwise rejects.
     * @param x {Any*}
     * @param y {Any*}
     * @returns {Any*} a promise for x and y if they are the same, but a rejection
     * otherwise.
     *
     */
    Q.join = function (x, y) {
        return Q(x).join(y);
    };
    
    Promise.prototype.join = function (that) {
        return Q([this, that]).spread(function (x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Can't join: not the same: " + x + " " + y);
            }
        });
    };
    
    /**
     * Returns a promise for the first of an array of promises to become fulfilled.
     * @param answers {Array[Any*]} promises to race
     * @returns {Any*} the first promise to be fulfilled
     */
    Q.race = race;
    function race(answerPs) {
        return promise(function(resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function(answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for (var i = 0, len = answerPs.length; i < len; i++) {
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }
    
    Promise.prototype.race = function () {
        return this.then(Q.race);
    };
    
    /**
     * Constructs a Promise with a promise descriptor object and optional fallback
     * function.  The descriptor contains methods like when(rejected), get(name),
     * set(name, value), post(name, args), and delete(name), which all
     * return either a value, a promise for a value, or a rejection.  The fallback
     * accepts the operation name, a resolver, and any further arguments that would
     * have been forwarded to the appropriate method above had a method been
     * provided with the proper name.  The API makes no guarantees about the nature
     * of the returned object, apart from that it is usable whereever promises are
     * bought and sold.
     */
    Q.makePromise = Promise;
    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function (op) {
                return reject(new Error(
                    "Promise does not support operation: " + op
                ));
            };
        }
        if (inspect === void 0) {
            inspect = function () {
                return {state: "unknown"};
            };
        }
    
        var promise = object_create(Promise.prototype);
    
        promise.promiseDispatch = function (resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };
    
        promise.inspect = inspect;
    
        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }
    
            promise.valueOf = function () {
                var inspected = inspect();
                if (inspected.state === "pending" ||
                    inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }
    
        return promise;
    }
    
    Promise.prototype.toString = function () {
        return "[object Promise]";
    };
    
    Promise.prototype.then = function (fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false;   // ensure the untrusted promise makes at most a
                            // single call to one of the callbacks
    
        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }
    
        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }
    
        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }
    
        nextTick(function () {
            self.promiseDispatch(function (value) {
                if (done) {
                    return;
                }
                done = true;
    
                deferred.resolve(_fulfilled(value));
            }, "when", [function (exception) {
                if (done) {
                    return;
                }
                done = true;
    
                deferred.resolve(_rejected(exception));
            }]);
        });
    
        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [void 0, function (value) {
            var newValue;
            var threw = false;
            try {
                newValue = _progressed(value);
            } catch (e) {
                threw = true;
                if (Q.onerror) {
                    Q.onerror(e);
                } else {
                    throw e;
                }
            }
    
            if (!threw) {
                deferred.notify(newValue);
            }
        }]);
    
        return deferred.promise;
    };
    
    /**
     * Registers an observer on a promise.
     *
     * Guarantees:
     *
     * 1. that fulfilled and rejected will be called only once.
     * 2. that either the fulfilled callback or the rejected callback will be
     *    called, but not both.
     * 3. that fulfilled and rejected will not be called in this turn.
     *
     * @param value      promise or immediate reference to observe
     * @param fulfilled  function to be called with the fulfilled value
     * @param rejected   function to be called with the rejection exception
     * @param progressed function to be called on any progress notifications
     * @return promise for the return value from the invoked callback
     */
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }
    
    Promise.prototype.thenResolve = function (value) {
        return this.then(function () { return value; });
    };
    
    Q.thenResolve = function (promise, value) {
        return Q(promise).thenResolve(value);
    };
    
    Promise.prototype.thenReject = function (reason) {
        return this.then(function () { throw reason; });
    };
    
    Q.thenReject = function (promise, reason) {
        return Q(promise).thenReject(reason);
    };
    
    /**
     * If an object is not a promise, it is as "near" as possible.
     * If a promise is rejected, it is as "near" as possible too.
     * If it’s a fulfilled promise, the fulfillment value is nearer.
     * If it’s a deferred promise and the deferred has been resolved, the
     * resolution is "nearer".
     * @param object
     * @returns most resolved (nearest) form of the object
     */
    
    // XXX should we re-do this?
    Q.nearer = nearer;
    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }
    
    /**
     * @returns whether the given object is a promise.
     * Otherwise it is a fulfilled value.
     */
    Q.isPromise = isPromise;
    function isPromise(object) {
        return isObject(object) &&
            typeof object.promiseDispatch === "function" &&
            typeof object.inspect === "function";
    }
    
    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }
    
    /**
     * @returns whether the given object is a pending promise, meaning not
     * fulfilled or rejected.
     */
    Q.isPending = isPending;
    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }
    
    Promise.prototype.isPending = function () {
        return this.inspect().state === "pending";
    };
    
    /**
     * @returns whether the given object is a value or fulfilled
     * promise.
     */
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }
    
    Promise.prototype.isFulfilled = function () {
        return this.inspect().state === "fulfilled";
    };
    
    /**
     * @returns whether the given object is a rejected promise.
     */
    Q.isRejected = isRejected;
    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }
    
    Promise.prototype.isRejected = function () {
        return this.inspect().state === "rejected";
    };
    
    //// BEGIN UNHANDLED REJECTION TRACKING
    
    // This promise library consumes exceptions thrown in handlers so they can be
    // handled by a subsequent promise.  The exceptions get added to this array when
    // they are created, and removed when they are handled.  Note that in ES6 or
    // shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var unhandledReasonsDisplayed = false;
    var trackUnhandledRejections = true;
    function displayUnhandledReasons() {
        if (
            !unhandledReasonsDisplayed &&
            typeof window !== "undefined" &&
            window.console
        ) {
            console.warn("[Q] Unhandled rejection reasons (should be empty):",
                         unhandledReasons);
        }
    
        unhandledReasonsDisplayed = true;
    }
    
    function logUnhandledReasons() {
        for (var i = 0; i < unhandledReasons.length; i++) {
            var reason = unhandledReasons[i];
            console.warn("Unhandled rejection reason:", reason);
        }
    }
    
    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
        unhandledReasonsDisplayed = false;
    
        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
    
            // Show unhandled rejection reasons if Node exits without handling an
            // outstanding rejection.  (Note that Browserify presently produces a
            // `process` global without the `EventEmitter` `on` method.)
            if (typeof process !== "undefined" && process.on) {
                process.on("exit", logUnhandledReasons);
            }
        }
    }
    
    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }
    
        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
        displayUnhandledReasons();
    }
    
    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }
    
        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }
    
    Q.resetUnhandledRejections = resetUnhandledRejections;
    
    Q.getUnhandledReasons = function () {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };
    
    Q.stopUnhandledRejectionTracking = function () {
        resetUnhandledRejections();
        if (typeof process !== "undefined" && process.on) {
            process.removeListener("exit", logUnhandledReasons);
        }
        trackUnhandledRejections = false;
    };
    
    resetUnhandledRejections();
    
    //// END UNHANDLED REJECTION TRACKING
    
    /**
     * Constructs a rejected promise.
     * @param reason value describing the failure
     */
    Q.reject = reject;
    function reject(reason) {
        var rejection = Promise({
            "when": function (rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return { state: "rejected", reason: reason };
        });
    
        // Note that the reason has not been handled.
        trackRejection(rejection, reason);
    
        return rejection;
    }
    
    /**
     * Constructs a fulfilled promise for an immediate reference.
     * @param value immediate reference
     */
    Q.fulfill = fulfill;
    function fulfill(value) {
        return Promise({
            "when": function () {
                return value;
            },
            "get": function (name) {
                return value[name];
            },
            "set": function (name, rhs) {
                value[name] = rhs;
            },
            "delete": function (name) {
                delete value[name];
            },
            "post": function (name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function (thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function () {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return { state: "fulfilled", value: value };
        });
    }
    
    /**
     * Converts thenables to Q promises.
     * @param promise thenable promise
     * @returns a Q promise
     */
    function coerce(promise) {
        var deferred = defer();
        nextTick(function () {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }
    
    /**
     * Annotates an object such that it will never be
     * transferred away from this process over any promise
     * communication channel.
     * @param object
     * @returns promise a wrapping of that object that
     * additionally responds to the "isDef" message
     * without a rejection.
     */
    Q.master = master;
    function master(object) {
        return Promise({
            "isDef": function () {}
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function () {
            return Q(object).inspect();
        });
    }
    
    /**
     * Spreads the values of a promised array of arguments into the
     * fulfillment callback.
     * @param fulfilled callback that receives variadic arguments from the
     * promised array
     * @param rejected callback that receives the exception if the promise
     * is rejected.
     * @returns a promise for the return value or thrown exception of
     * either callback.
     */
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }
    
    Promise.prototype.spread = function (fulfilled, rejected) {
        return this.all().then(function (array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };
    
    /**
     * The async function is a decorator for generator functions, turning
     * them into asynchronous generators.  Although generators are only part
     * of the newest ECMAScript 6 drafts, this code does not cause syntax
     * errors in older engines.  This code should continue to work and will
     * in fact improve over time as the language improves.
     *
     * ES6 generators are currently part of V8 version 3.19 with the
     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
     * for longer, but under an older Python-inspired form.  This function
     * works on both kinds of generators.
     *
     * Decorates a generator function such that:
     *  - it may yield promises
     *  - execution will continue when that promise is fulfilled
     *  - the value of the yield expression will be the fulfilled value
     *  - it returns a promise for the return value (when the generator
     *    stops iterating)
     *  - the decorated function returns a promise for the return value
     *    of the generator or the first rejected promise among those
     *    yielded.
     *  - if an error is thrown in the generator, it propagates through
     *    every following yield until it is caught, or until it escapes
     *    the generator function altogether, and is translated into a
     *    rejection for the promise returned by the decorated generator.
     */
    Q.async = async;
    function async(makeGenerator) {
        return function () {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;
                if (hasES6Generators) {
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return result.value;
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return exception.value;
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }
    
    /**
     * The spawn function is a small wrapper around async that immediately
     * calls the generator and also ends the promise chain, so that any
     * unhandled errors are thrown instead of forwarded to the error
     * handler. This is useful because it's extremely common to run
     * generators at the top-level to work with libraries.
     */
    Q.spawn = spawn;
    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }
    
    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
     * Throws a ReturnValue exception to stop an asynchronous generator.
     *
     * This interface is a stop-gap measure to support generator return
     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
     * generators like Chromium 29, just use "return" in your generator
     * functions.
     *
     * @param value the return value for the surrounding generator
     * @throws ReturnValue exception with the value.
     * @example
     * // ES6 style
     * Q.async(function* () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      return foo + bar;
     * })
     * // Older SpiderMonkey style
     * Q.async(function () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      Q.return(foo + bar);
     * })
     */
    Q["return"] = _return;
    function _return(value) {
        throw new QReturnValue(value);
    }
    
    /**
     * The promised function decorator ensures that any promise arguments
     * are settled and passed as values (`this` is also settled and passed
     * as a value).  It will also ensure that the result of a function is
     * always a promise.
     *
     * @example
     * var add = Q.promised(function (a, b) {
     *     return a + b;
     * });
     * add(Q(a), Q(B));
     *
     * @param {function} callback The function to decorate
     * @returns {function} a function that has been decorated.
     */
    Q.promised = promised;
    function promised(callback) {
        return function () {
            return spread([this, all(arguments)], function (self, args) {
                return callback.apply(self, args);
            });
        };
    }
    
    /**
     * sends a message to a value in a future turn
     * @param object* the recipient
     * @param op the name of the message operation, e.g., "when",
     * @param args further arguments to be forwarded to the operation
     * @returns result {Promise} a promise for the result of the operation
     */
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }
    
    Promise.prototype.dispatch = function (op, args) {
        var self = this;
        var deferred = defer();
        nextTick(function () {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };
    
    /**
     * Gets the value of a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to get
     * @return promise for the property value
     */
    Q.get = function (object, key) {
        return Q(object).dispatch("get", [key]);
    };
    
    Promise.prototype.get = function (key) {
        return this.dispatch("get", [key]);
    };
    
    /**
     * Sets the value of a property in a future turn.
     * @param object    promise or immediate reference for object object
     * @param name      name of property to set
     * @param value     new value of property
     * @return promise for the return value
     */
    Q.set = function (object, key, value) {
        return Q(object).dispatch("set", [key, value]);
    };
    
    Promise.prototype.set = function (key, value) {
        return this.dispatch("set", [key, value]);
    };
    
    /**
     * Deletes a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to delete
     * @return promise for the return value
     */
    Q.del = // XXX legacy
    Q["delete"] = function (object, key) {
        return Q(object).dispatch("delete", [key]);
    };
    
    Promise.prototype.del = // XXX legacy
    Promise.prototype["delete"] = function (key) {
        return this.dispatch("delete", [key]);
    };
    
    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param value     a value to post, typically an array of
     *                  invocation arguments for promises that
     *                  are ultimately backed with `resolve` values,
     *                  as opposed to those backed with URLs
     *                  wherein the posted value can be any
     *                  JSON serializable object.
     * @return promise for the return value
     */
    // bound locally because it is used by other methods
    Q.mapply = // XXX As proposed by "Redsandro"
    Q.post = function (object, name, args) {
        return Q(object).dispatch("post", [name, args]);
    };
    
    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
    Promise.prototype.post = function (name, args) {
        return this.dispatch("post", [name, args]);
    };
    
    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param ...args   array of invocation arguments
     * @return promise for the return value
     */
    Q.send = // XXX Mark Miller's proposed parlance
    Q.mcall = // XXX As proposed by "Redsandro"
    Q.invoke = function (object, name /*...args*/) {
        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
    };
    
    Promise.prototype.send = // XXX Mark Miller's proposed parlance
    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
    Promise.prototype.invoke = function (name /*...args*/) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
    };
    
    /**
     * Applies the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param args      array of application arguments
     */
    Q.fapply = function (object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
    };
    
    Promise.prototype.fapply = function (args) {
        return this.dispatch("apply", [void 0, args]);
    };
    
    /**
     * Calls the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q["try"] =
    Q.fcall = function (object /* ...args*/) {
        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
    };
    
    Promise.prototype.fcall = function (/*...args*/) {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };
    
    /**
     * Binds the promised function, transforming return values into a fulfilled
     * promise and thrown errors into a rejected one.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q.fbind = function (object /*...args*/) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function (/*...args*/) {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    
    /**
     * Requests the names of the owned properties of a promised
     * object in a future turn.
     * @param object    promise or immediate reference for target object
     * @return promise for the keys of the eventually settled object
     */
    Q.keys = function (object) {
        return Q(object).dispatch("keys", []);
    };
    
    Promise.prototype.keys = function () {
        return this.dispatch("keys", []);
    };
    
    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     * @param {Array*} an array (or promise for an array) of values (or
     * promises for values)
     * @returns a promise for an array of the corresponding values
     */
    // By Mark Miller
    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;
    function all(promises) {
        return when(promises, function (promises) {
            var countDown = 0;
            var deferred = defer();
            array_reduce(promises, function (undefined, promise, index) {
                var snapshot;
                if (
                    isPromise(promise) &&
                    (snapshot = promise.inspect()).state === "fulfilled"
                ) {
                    promises[index] = snapshot.value;
                } else {
                    ++countDown;
                    when(
                        promise,
                        function (value) {
                            promises[index] = value;
                            if (--countDown === 0) {
                                deferred.resolve(promises);
                            }
                        },
                        deferred.reject,
                        function (progress) {
                            deferred.notify({ index: index, value: progress });
                        }
                    );
                }
            }, void 0);
            if (countDown === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }
    
    Promise.prototype.all = function () {
        return all(this);
    };
    
    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     * @param promises a promise for an array (or an array) of promises
     * (or values)
     * @return a promise for an array of promises
     */
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
        return when(promises, function (promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function (promise) {
                return when(promise, noop, noop);
            })), function () {
                return promises;
            });
        });
    }
    
    Promise.prototype.allResolved = function () {
        return allResolved(this);
    };
    
    /**
     * @see Promise#allSettled
     */
    Q.allSettled = allSettled;
    function allSettled(promises) {
        return Q(promises).allSettled();
    }
    
    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     * @param {Array[Any*]} values an array (or promise for an array) of values (or
     * promises for values)
     * @returns {Array[State]} an array of states for the respective values.
     */
    Promise.prototype.allSettled = function () {
        return this.then(function (promises) {
            return all(array_map(promises, function (promise) {
                promise = Q(promise);
                function regardless() {
                    return promise.inspect();
                }
                return promise.then(regardless, regardless);
            }));
        });
    };
    
    /**
     * Captures the failure of a promise, giving an oportunity to recover
     * with a callback.  If the given promise is fulfilled, the returned
     * promise is fulfilled.
     * @param {Any*} promise for something
     * @param {Function} callback to fulfill the returned promise if the
     * given promise is rejected
     * @returns a promise for the return value of the callback
     */
    Q.fail = // XXX legacy
    Q["catch"] = function (object, rejected) {
        return Q(object).then(void 0, rejected);
    };
    
    Promise.prototype.fail = // XXX legacy
    Promise.prototype["catch"] = function (rejected) {
        return this.then(void 0, rejected);
    };
    
    /**
     * Attaches a listener that can respond to progress notifications from a
     * promise's originating deferred. This listener receives the exact arguments
     * passed to ``deferred.notify``.
     * @param {Any*} promise for something
     * @param {Function} callback to receive any progress notifications
     * @returns the given promise, unchanged
     */
    Q.progress = progress;
    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }
    
    Promise.prototype.progress = function (progressed) {
        return this.then(void 0, void 0, progressed);
    };
    
    /**
     * Provides an opportunity to observe the settling of a promise,
     * regardless of whether the promise is fulfilled or rejected.  Forwards
     * the resolution to the returned promise when the callback is done.
     * The callback can return a promise to defer completion.
     * @param {Any*} promise
     * @param {Function} callback to observe the resolution of the given
     * promise, takes no arguments.
     * @returns a promise for the resolution of the given promise when
     * ``fin`` is done.
     */
    Q.fin = // XXX legacy
    Q["finally"] = function (object, callback) {
        return Q(object)["finally"](callback);
    };
    
    Promise.prototype.fin = // XXX legacy
    Promise.prototype["finally"] = function (callback) {
        callback = Q(callback);
        return this.then(function (value) {
            return callback.fcall().then(function () {
                return value;
            });
        }, function (reason) {
            // TODO attempt to recycle the rejection with "this".
            return callback.fcall().then(function () {
                throw reason;
            });
        });
    };
    
    /**
     * Terminates a chain of promises, forcing rejections to be
     * thrown as exceptions.
     * @param {Any*} promise at the end of a chain of promises
     * @returns nothing
     */
    Q.done = function (object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };
    
    Promise.prototype.done = function (fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            nextTick(function () {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };
    
        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ?
            this.then(fulfilled, rejected, progress) :
            this;
    
        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }
    
        promise.then(void 0, onUnhandledError);
    };
    
    /**
     * Causes a promise to be rejected if it does not get fulfilled before
     * some milliseconds time out.
     * @param {Any*} promise
     * @param {Number} milliseconds timeout
     * @param {String} custom error message (optional)
     * @returns a promise for the resolution of the given promise if it is
     * fulfilled before the timeout, otherwise rejected.
     */
    Q.timeout = function (object, ms, message) {
        return Q(object).timeout(ms, message);
    };
    
    Promise.prototype.timeout = function (ms, message) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
        }, ms);
    
        this.then(function (value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function (exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);
    
        return deferred.promise;
    };
    
    /**
     * Returns a promise for the given value (or promised value), some
     * milliseconds after it resolved. Passes rejections immediately.
     * @param {Any*} promise
     * @param {Number} milliseconds
     * @returns a promise for the resolution of the given promise after milliseconds
     * time has elapsed since the resolution of the given promise.
     * If the given promise rejects, that is passed immediately.
     */
    Q.delay = function (object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };
    
    Promise.prototype.delay = function (timeout) {
        return this.then(function (value) {
            var deferred = defer();
            setTimeout(function () {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };
    
    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided as an array, and returns a promise.
     *
     *      Q.nfapply(FS.readFile, [__filename])
     *      .then(function (content) {
     *      })
     *
     */
    Q.nfapply = function (callback, args) {
        return Q(callback).nfapply(args);
    };
    
    Promise.prototype.nfapply = function (args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided individually, and returns a promise.
     * @example
     * Q.nfcall(FS.readFile, __filename)
     * .then(function (content) {
     * })
     *
     */
    Q.nfcall = function (callback /*...args*/) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };
    
    Promise.prototype.nfcall = function (/*...args*/) {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Wraps a NodeJS continuation passing function and returns an equivalent
     * version that returns a promise.
     * @example
     * Q.nfbind(FS.readFile, __filename)("utf-8")
     * .then(console.log)
     * .done()
     */
    Q.nfbind =
    Q.denodeify = function (callback /*...args*/) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(callback).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    
    Promise.prototype.nfbind =
    Promise.prototype.denodeify = function (/*...args*/) {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
    };
    
    Q.nbind = function (callback, thisp /*...args*/) {
        var baseArgs = array_slice(arguments, 2);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
                return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    
    Promise.prototype.nbind = function (/*thisp, ...args*/) {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };
    
    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback with a given array of arguments, plus a provided callback.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param {Array} args arguments to pass to the method; the callback
     * will be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nmapply = // XXX As proposed by "Redsandro"
    Q.npost = function (object, name, args) {
        return Q(object).npost(name, args);
    };
    
    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
    Promise.prototype.npost = function (name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback, forwarding the given variadic arguments, plus a provided
     * callback argument.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param ...args arguments to pass to the method; the callback will
     * be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nsend = // XXX Based on Mark Miller's proposed "send"
    Q.nmcall = // XXX Based on "Redsandro's" proposal
    Q.ninvoke = function (object, name /*...args*/) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
    Promise.prototype.ninvoke = function (name /*...args*/) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * If a function would like to support both Node continuation-passing-style and
     * promise-returning-style, it can end its internal promise chain with
     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
     * elects to use a nodeback, the result will be sent there.  If they do not
     * pass a nodeback, they will receive the result promise.
     * @param object a result (or a promise for a result)
     * @param {Function} nodeback a Node.js-style callback
     * @returns either the promise or nothing
     */
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }
    
    Promise.prototype.nodeify = function (nodeback) {
        if (nodeback) {
            this.then(function (value) {
                nextTick(function () {
                    nodeback(null, value);
                });
            }, function (error) {
                nextTick(function () {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };
    
    // All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();
    
    return Q;
    
    });
    
  provide("q", module.exports);
}(global));

// pakmanager:restler/multipartform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs');
    var sys = require('util')
    exports.defaultBoundary = '48940923NODERESLTER3890457293';
    
    
    // This little object allows us hijack the write method via duck-typing
    // and write to strings or regular streams that support the write method.
    function Stream(stream) {
    	//If the user pases a string for stream,we initalize one to write to
    	if (this._isString(stream)) {
    		this.string = "";
    	}
    	this.stream = stream;
    	
    }
    
    Stream.prototype = {
      //write to an internal String or to the Stream
      write: function(data) {
    	if (this.string != undefined) {
    		this.string += data;
    	} else {
    		this.stream.write(data, "binary");
    	}
      },
    
      //stolen from underscore.js
      _isString: function(obj) {
        return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
      }
    }
    
    function File(path, filename, fileSize, encoding, contentType) {
      this.path = path;
      this.filename = filename || this._basename(path);
      this.fileSize = fileSize;
      this.encoding = encoding || "binary";
      this.contentType = contentType || 'application/octet-stream';
    }
    
    File.prototype = {
      _basename: function(path) {
        var parts = path.split(/\/|\\/);
        return parts[parts.length - 1];
      }
    };
    
    function Data(filename, contentType, data) {
      this.filename = filename;
      this.contentType = contentType || 'application/octet-stream';
      this.data = data;
    }
    
    function Part(name, value, boundary) {
      this.name = name;
      this.value = value;
      this.boundary = boundary;
    }
    
    
    Part.prototype = {
    	
      //returns the Content-Disposition header		
      header: function() {
    	  var header;
    	  
        if (this.value.data) {
    	    header = "Content-Disposition: form-data; name=\"" + this.name + 
      	            "\"; filename=\"" + this.value.filename + "\"\r\n" +
      	            "Content-Type: " + this.value.contentType;
     	  } if (this.value instanceof File) {
      	  header = "Content-Disposition: form-data; name=\"" + this.name + 
      	            "\"; filename=\"" + this.value.filename + "\"\r\n" +
      	            "Content-Length: " + this.value.fileSize + "\r\n" +	
      	            "Content-Type: " + this.value.contentType;	
      	} else {
          header = "Content-Disposition: form-data; name=\"" + this.name + "\"";
      	}
      	
    	  return "--" + this.boundary + "\r\n" + header + "\r\n\r\n";
      },
    
      //calculates the size of the Part
      sizeOf: function() {
    	  var valueSize;
      	if (this.value instanceof File) {
      	  valueSize = this.value.fileSize;
      	} else if (this.value.data) {
      	  valueSize = this.value.data.length;
            } else if (typeof this.value === 'number') {
              valueSize = this.value.toString().length;
      	} else {
      	  valueSize = this.value.length;
      	}
      	return valueSize + this.header().length + 2; 
      },
    
      // Writes the Part out to a writable stream that supports the write(data) method
      // You can also pass in a String and a String will be returned to the callback
      // with the whole Part
      // Calls the callback when complete
      write: function(stream, callback) {
    	
        var self = this;
    	
    	  //first write the Content-Disposition
    	  stream.write(this.header());
    	
      	//Now write out the body of the Part
        if (this.value instanceof File) {
      	  fs.open(this.value.path, "r", 0666, function (err, fd) { 
        	  if (err) throw err; 
        	  
      		  var position = 0;
      		  
      	    (function reader () {
      	      fs.read(fd, 1024 * 4, position, "binary", function (er, chunk) {
      	        if (er) callback(err);
      	        stream.write(chunk); 
      	        position += 1024 * 4;
      	        if (chunk) reader();
      	        else {
      			      stream.write("\r\n")
          			  callback();
          			  fs.close(fd);
          			}
      	      }); 
      	    })(); // reader() 
      	  });
         } else {
      	  stream.write(this.value + "\r\n");
      	  callback();
      	}
      }
    }
    
    //Renamed to MultiPartRequest from Request
    function MultiPartRequest(data, boundary) {
      this.encoding = 'binary';
      this.boundary = boundary || exports.defaultBoundary;
      this.data = data;
      this.partNames = this._partNames();
    }
    
    MultiPartRequest.prototype = {
      _partNames: function() {
        var partNames = [];
        for (var name in this.data) {
          partNames.push(name)
      	}
      	return partNames;
      },
      
      write: function(stream, callback) {
        var partCount = 0, self = this;
        
    	  // wrap the stream in our own Stream object
      	// See the Stream function above for the benefits of this
      	var stream = new Stream(stream);
      	
      	// Let each part write itself out to the stream
      	(function writePart() {
      	  var partName = self.partNames[partCount];
      	  var part = new Part(partName, self.data[partName], self.boundary);
      	  part.write(stream, function (err) {
      		  if (err) {
        			callback(err);
        			return;
        		}
         		partCount += 1;
        	  if (partCount < self.partNames.length)
        	    writePart();
        		else {
        		  stream.write('--' + self.boundary + '--' + "\r\n");
    
              if (callback) callback(stream.string || "");
        		}
      	  });
        })(); 
      }
    }
    
    var exportMethods = {
      file: function(path, filename, fileSize, encoding, contentType) { 
        return new File(path, filename, fileSize, encoding, contentType)
      },
      data: function(filename, contentType, data) {
        return new Data(filename, contentType, data);
      },
      sizeOf: function(parts, boundary) {
        var totalSize = 0;
    	  boundary = boundary || exports.defaultBoundary;
      	for (var name in parts) totalSize += new Part(name, parts[name], boundary).sizeOf();
      	return totalSize + boundary.length + 6;
      },
      write: function(stream, data, callback, boundary) {
        var r = new MultiPartRequest(data, boundary);
        r.write(stream, callback);
        return r;
      }
    }
    
    Object.keys(exportMethods).forEach(function(exportMethod) {
      exports[exportMethod] = exportMethods[exportMethod]
    })
    
  provide("restler/multipartform", module.exports);
}(global));

// pakmanager:restler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util      = require('util'),
        events    = require("events"),
        http      = require('http'),
        https     = require('https'),
        url       = require('url'),
        qs        = require('qs'),
        multipart =  require('restler/multipartform'),
        zlib      = require('zlib'),
        iconv     = require('iconv-lite');
    
    function mixin(target, source) {
      source = source || {};
      Object.keys(source).forEach(function(key) {
        target[key] = source[key];
      });
    
      return target;
    }
    
    function Request(uri, options) {
      events.EventEmitter.call(this);
      this.url = url.parse(uri);
      this.options = options;
      this.headers = {
        'Accept': '*/*',
        'User-Agent': 'Restler for node.js',
        'Host': this.url.host
      };
    
      this.headers['Accept-Encoding'] = 'gzip, deflate';
    
      mixin(this.headers, options.headers || {});
    
      // set port and method defaults
      if (!this.url.port) this.url.port = (this.url.protocol == 'https:') ? '443' : '80';
      if (!this.options.method) this.options.method = (this.options.data) ? 'POST' : 'GET';
      if (typeof this.options.followRedirects == 'undefined') this.options.followRedirects = true;
    
      // stringify query given in options of not given in URL
      if (this.options.query && !this.url.query) {
        if (typeof this.options.query == 'object')
          this.url.query = qs.stringify(this.options.query);
        else this.url.query = this.options.query;
      }
    
      this._applyBasicAuth();
    
      if (this.options.multipart) {
        this.headers['Content-Type'] = 'multipart/form-data; boundary=' + multipart.defaultBoundary;
        var multipart_size = multipart.sizeOf(this.options.data, multipart.defaultBoundary);
        if (typeof multipart_size === 'number' && multipart_size === multipart_size) {
            this.headers['Content-Length'] = multipart_size;
        }
        else {
            console.log("Building multipart request without Content-Length header, please specify all file sizes");
        }
      } else {
        if (typeof this.options.data == 'object') {
          this.options.data = qs.stringify(this.options.data);
          this.headers['Content-Type'] = 'application/x-www-form-urlencoded';
          this.headers['Content-Length'] = this.options.data.length;
        }
        if (typeof this.options.data == 'string') {
          var buffer = new Buffer(this.options.data, this.options.encoding || 'utf8');
          this.options.data = buffer;
          this.headers['Content-Length'] = buffer.length;
        }
        if (!this.options.data) {
          this.headers['Content-Length'] = 0;
        }
      }
    
      var proto = (this.url.protocol == 'https:') ? https : http;
    
        var tunnel = require('tunnel');
        var tunnelingAgent = tunnel.httpOverHttp({
            proxy: {
                host: 'localhost',
                port: 8888 // default Charles proxy port
            }
        });
    
      this.request = proto.request({
        host: this.url.hostname,
        port: this.url.port,
    //    agent: tunnelingAgent,
        path: this._fullPath(),
        method: this.options.method,
        headers: this.headers,
        rejectUnauthorized: this.options.rejectUnauthorized
      });
    
      this._makeRequest();
    }
    
    util.inherits(Request, events.EventEmitter);
    
    mixin(Request.prototype, {
      _isRedirect: function(response) {
        return ([301, 302, 303, 307].indexOf(response.statusCode) >= 0);
      },
      _fullPath: function() {
        var path = this.url.pathname || '/';
        if (this.url.hash) path += this.url.hash;
        if (this.url.query) path += '?' + this.url.query;
        return path;
      },
      _applyBasicAuth: function() {
        var authParts;
    
        if (this.url.auth) {
          authParts = this.url.auth.split(':');
          this.options.username = authParts[0];
          this.options.password = authParts[1];
        }
    
        if (this.options.username && this.options.password !== undefined) {
          var b = new Buffer([this.options.username, this.options.password].join(':'));
          this.headers['Authorization'] = "Basic " + b.toString('base64');
        }
      },
      _responseHandler: function(response) {
        var self = this;
    
        if (self._isRedirect(response) && self.options.followRedirects) {
          try {
            // 303 should redirect and retrieve content with the GET method
            // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4
            if (response.statusCode === 303) {
                self.url    = url.parse(url.resolve(self.url.href, response.headers['location']));
                self.options.method = 'GET';
                delete self.options.data;
                self._retry();
            } else {
                self.url = url.parse(url.resolve(self.url.href, response.headers['location']));
                self._retry();
                // todo handle somehow infinite redirects
            }
          } catch(err) {
            err.message = 'Failed to follow redirect: ' + err.message;
            self._fireError(err, response);
          }
        } else {
          var body = '';
    
          response.setEncoding('binary');
    
          response.on('data', function(chunk) {
            body += chunk;
          });
    
          response.on('end', function() {
            response.rawEncoded = body;
            self._decode(new Buffer(body, 'binary'), response, function(err, body) {
              if (err) {
                self._fireError(err, response);
                return;
              }
              response.raw = body;
              body = self._iconv(body, response);
              self._encode(body, response, function(err, body) {
                if (err) {
                  self._fireError(err, response);
                } else {
                  self._fireSuccess(body, response);
                }
              });
            });
          });
        }
      },
      _decode: function(body, response, callback) {
        var decoder = response.headers['content-encoding'];
        if (decoder in decoders) {
          decoders[decoder].call(response, body, callback);
        } else {
          callback(null, body);
        }
      },
      _iconv: function(body, response) {
        var charset = response.headers['content-type'];
        if (charset) {
          charset = /\bcharset=(.+)(?:;|$)/i.exec(charset);
          if (charset) {
            charset = charset[1].trim().toUpperCase();
            if (charset != 'UTF-8') {
              try {
                return iconv.decode(body, charset);
              } catch (err) {}
            }
          }
        }
        return body;
      },
      _encode: function(body, response, callback) {
        var self = this;
        if (self.options.decoding == 'buffer') {
          callback(null, body);
        } else {
          body = body.toString(self.options.decoding);
          if (self.options.parser) {
            self.options.parser.call(response, body, callback);
          } else {
            callback(null, body);
          }
        }
      },
      _fireError: function(err, response) {
        this._fireCancelTimeout();
        this.emit('error', err, response);
        this.emit('complete', err, response);
      },
      _fireCancelTimeout: function(){
        var self = this;
        if(self.options.timeout){
          clearTimeout(self.options.timeoutFn);
        }
      },
      _fireTimeout: function(err){
        this.emit('timeout', err);
        this.aborted = true;
        this.timedout = true;
        this.request.abort();
      },
      _fireSuccess: function(body, response) {
        if (parseInt(response.statusCode) >= 400) {
          this.emit('fail', body, response);
        } else {
          this.emit('success', body, response);
        }
        this.emit(response.statusCode.toString().replace(/\d{2}$/, 'XX'), body, response);
        this.emit(response.statusCode.toString(), body, response);
        this.emit('complete', body, response);
      },
      _makeRequest: function() {
        var self = this;
        var timeoutMs = self.options.timeout;
        if(timeoutMs){
          self.options.timeoutFn = setTimeout(function(){
            self._fireTimeout(timeoutMs);
          },timeoutMs);
        }
        this.request.on('response', function(response) {
          self._fireCancelTimeout();
          self.emit('response', response);
          self._responseHandler(response);
        }).on('error', function(err) {
          self._fireCancelTimeout();
          if (!self.aborted) {
            self._fireError(err, null);
          }
        });
      },
      _retry: function() {
        this.request.removeAllListeners().on('error', function() {});
        if (this.request.finished) {
          this.request.abort();
        }
        Request.call(this, this.url.href, this.options); // reusing request object to handle recursive calls and remember listeners
        this.run();
      },
      run: function() {
        var self = this;
    //      console.log(this.request);
        if (this.options.multipart) {
          multipart.write(this.request, this.options.data, function() {
            self.request.end();
          });
        } else {
          if (this.options.data) {
            this.request.write(this.options.data.toString(), this.options.encoding || 'utf8');
          }
          this.request.end();
        }
    
        return this;
      },
      abort: function(err) {
        var self = this;
    
        if (err) {
          if (typeof err == 'string') {
            err = new Error(err);
          } else if (!(err instanceof Error)) {
            err = new Error('AbortError');
          }
          err.type = 'abort';
        } else {
          err = null;
        }
    
        self.request.on('close', function() {
          if (err) {
            self._fireError(err, null);
          } else {
            self.emit('complete', null, null);
          }
        });
    
        self.aborted = true;
        self.request.abort();
        self.emit('abort', err);
        return this;
      },
      retry: function(timeout) {
        var self = this;
        timeout = parseInt(timeout);
        var fn = self._retry.bind(self);
        if (!isFinite(timeout) || timeout <= 0) {
          process.nextTick(fn, timeout);
        } else {
          setTimeout(fn, timeout);
        }
        return this;
      }
    });
    
    function shortcutOptions(options, method) {
      options = options || {};
      options.method = method;
      options.parser = (typeof options.parser !== "undefined") ? options.parser : parsers.auto;
      return options;
    }
    
    function request(url, options) {
      var request = new Request(url, options);
      request.on('error', function() {});
      process.nextTick(request.run.bind(request));
      return request;
    }
    
    function get(url, options) {
     return request(url, shortcutOptions(options, 'GET'));
    }
    
    function patch(url, options) {
      return request(url, shortcutOptions(options, 'PATCH'));
    }
    
    function post(url, options) {
      return request(url, shortcutOptions(options, 'POST'));
    }
    
    function put(url, options) {
      return request(url, shortcutOptions(options, 'PUT'));
    }
    
    function del(url, options) {
      return request(url, shortcutOptions(options, 'DELETE'));
    }
    
    function head(url, options) {
      return request(url, shortcutOptions(options, 'HEAD'));
    }
    
    function json(url, data, options, method) {
      options = options || {};
      options.parser = (typeof options.parser !== "undefined") ? options.parser : parsers.auto;
      options.headers = options.headers || {};
      options.headers['content-type'] = 'application/json';
      options.data = JSON.stringify(data || {});
      options.method = method || 'GET';
      return request(url, options);
    }
    
    function postJson(url, data, options) {
      return json(url, data, options, 'POST');
    }
    
    function putJson(url, data, options) {
      return json(url, data, options, 'PUT');
    }
    
    var parsers = {
      auto: function(data, callback) {
        var contentType = this.headers['content-type'];
        var contentParser;
        if (contentType) {
          contentType = contentType.replace(/;.+/, ''); // remove all except mime type (eg. text/html; charset=UTF-8)
          if (contentType in parsers.auto.matchers) {
            contentParser = parsers.auto.matchers[contentType];
          } else {
            // custom (vendor) mime types
            var parts = contentType.match(/^([\w-]+)\/vnd((?:\.(?:[\w-]+))+)\+([\w-]+)$/i);
            if (parts) {
              var type = parts[1];
              var vendors = parts[2].substr(1).split('.');
              var subtype = parts[3];
              var vendorType;
              while (vendors.pop() && !(vendorType in parsers.auto.matchers)) {
                vendorType = vendors.length
                  ? type + '/vnd.' + vendors.join('.') + '+' + subtype
                  : vendorType = type + '/' + subtype;
              }
              contentParser = parsers.auto.matchers[vendorType];
            }
          }
        }
        if (typeof contentParser == 'function') {
          contentParser.call(this, data, callback);
        } else {
          callback(null, data);
        }
      },
      json: function(data, callback) {
        if (data && data.length) {
          var parsedData;
          try {
            parsedData = JSON.parse(data);
          } catch (err) {
            err.message = 'Failed to parse JSON body: ' + err.message;
            callback(err, null);
          }
          if (parsedData !== undefined) {
            callback(null, parsedData);
          }
        } else {
          callback(null, null);
        }
      }
    };
    
    parsers.auto.matchers = {
      'application/json': parsers.json
    };
    
    try {
      var yaml = require('yaml');
    
      parsers.yaml = function(data, callback) {
        if (data) {
          try {
            callback(null, yaml.eval(data));
          } catch (err) {
            err.message = 'Failed to parse YAML body: ' + err.message;
            callback(err, null);
          }
        } else {
          callback(null, null);
        }
      };
    
      parsers.auto.matchers['application/yaml'] = parsers.yaml;
    } catch(e) {}
    
    try {
      var xml2js = require('xml2js');
    
      parsers.xml = function(data, callback) {
        if (data) {
          var parser = new xml2js.Parser();
          parser.parseString(data, function(err, data) {
            if (err) {
              err.message = 'Failed to parse XML body: ' + err.message;
            }
            callback(err, data);
          });
        } else {
          callback(null, null);
        }
      };
    
      parsers.auto.matchers['application/xml'] = parsers.xml;
    } catch(e) { }
    
    var decoders = {
      gzip: function(buf, callback) {
        zlib.gunzip(buf, callback);
      },
      deflate: function(buf, callback) {
        zlib.inflate(buf, callback);
      }
    };
    
    
    function Service(defaults) {
      if (defaults.baseURL) {
       this.baseURL = defaults.baseURL;
       delete defaults.baseURL;
      }
    
      this.defaults = defaults;
    }
    
    mixin(Service.prototype, {
      request: function(path, options) {
        return request(this._url(path), this._withDefaults(options));
      },
      get: function(path, options) {
        return get(this._url(path), this._withDefaults(options));
      },
      patch: function(path, options) {
        return patch(this._url(path), this._withDefaults(options));
      },
      put: function(path, options) {
        return put(this._url(path), this._withDefaults(options));
      },
      post: function(path, options) {
        return post(this._url(path), this._withDefaults(options));
      },
      json: function(method, path, data, options) {
        return json(this._url(path), data, this._withDefaults(options), method);
      },
      del: function(path, options) {
        return del(this._url(path), this._withDefaults(options));
      },
      _url: function(path) {
        if (this.baseURL) return url.resolve(this.baseURL, path);
        else return path;
      },
      _withDefaults: function(options) {
        var o = mixin({}, this.defaults);
        return mixin(o, options);
      }
    });
    
    function service(constructor, defaults, methods) {
      constructor.prototype = new Service(defaults || {});
      mixin(constructor.prototype, methods);
      return constructor;
    }
    
    mixin(exports, {
      Request: Request,
      Service: Service,
      request: request,
      service: service,
      get: get,
      patch: patch,
      post: post,
      put: put,
      del: del,
      head: head,
      json: json,
      postJson: postJson,
      putJson: putJson,
      parsers: parsers,
      file: multipart.file,
      data: multipart.data
    });
    
    
  provide("restler", module.exports);
}(global));

// pakmanager:should/lib/inspect
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var util =  require('should/lib/util');
    var isBoolean = util.isBoolean;
    var isObject = util.isObject;
    var isUndefined = util.isUndefined;
    var isFunction = util.isFunction;
    var isString = util.isString;
    var isNumber = util.isNumber;
    var isNull = util.isNull;
    var isRegExp = util.isRegExp;
    var isDate = util.isDate;
    var isError = util.isError;
    var isArray = util.isArray;
    
    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    
    
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };
    
    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };
    
    
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
    
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
          '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    
    
    function stylizeNoColor(str, styleType) {
      return str;
    }
    
    
    function arrayToHash(array) {
      var hash = {};
    
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
    
      return hash;
    }
    
    
    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
    
      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
    
      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
    
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
    
      // This could be a boxed primitive (new String(), etc.), check valueOf()
      // NOTE: Avoid calling `valueOf` on `Date` instance because it will return
      // a number which, when object has some additional user-stored `keys`,
      // will be printed out.
      var formatted;
      var raw = value;
      try {
        // the .valueOf() call can fail for a multitude of reasons
        if (!isDate(value))
          raw = value.valueOf();
      } catch (e) {
        // ignore...
      }
    
      if (isString(raw)) {
        // for boxed Strings, we have to remove the 0-n indexed entries,
        // since they just noisey up the output and are redundant
        keys = keys.filter(function(key) {
          return !(key >= 0 && key < raw.length);
        });
      }
    
      if (isError(value)) {
        return formatError(value);
      }
    
      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        // now check the `raw` value to handle boxed primitives
        if (isString(raw)) {
          formatted = formatPrimitiveNoColor(ctx, raw);
          return ctx.stylize('[String: ' + formatted + ']', 'string');
        }
        if (isNumber(raw)) {
          formatted = formatPrimitiveNoColor(ctx, raw);
          return ctx.stylize('[Number: ' + formatted + ']', 'number');
        }
        if (isBoolean(raw)) {
          formatted = formatPrimitiveNoColor(ctx, raw);
          return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');
        }
      }
    
      var base = '', array = false, braces = ['{', '}'];
    
      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
    
      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
    
      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
    
      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
    
      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
    
      // Make boxed primitive Strings look like such
      if (isString(raw)) {
        formatted = formatPrimitiveNoColor(ctx, raw);
        base = ' ' + '[String: ' + formatted + ']';
      }
    
      // Make boxed primitive Numbers look like such
      if (isNumber(raw)) {
        formatted = formatPrimitiveNoColor(ctx, raw);
        base = ' ' + '[Number: ' + formatted + ']';
      }
    
      // Make boxed primitive Booleans look like such
      if (isBoolean(raw)) {
        formatted = formatPrimitiveNoColor(ctx, raw);
        base = ' ' + '[Boolean: ' + formatted + ']';
      }
    
      if (keys.length === 0 && (!array || value.length === 0)) {
        return braces[0] + base + braces[1];
      }
    
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
    
      ctx.seen.push(value);
    
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
    
      ctx.seen.pop();
    
      return reduceToSingleString(output, base, braces);
    }
    
    
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) {
        // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,
        // so instead we use the fact that 1 / -0 < 0 whereas 1 / 0 > 0 .
        if (value === 0 && 1 / value < 0)
          return ctx.stylize('-0', 'number');
        return ctx.stylize('' + value, 'number');
      }
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    
    
    function formatPrimitiveNoColor(ctx, value) {
      var stylize = ctx.stylize;
      ctx.stylize = stylizeNoColor;
      var str = formatPrimitive(ctx, value);
      ctx.stylize = stylize;
      return str;
    }
    
    
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    
    
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
        }
      });
      return output;
    }
    
    
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return ' ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return ' ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
            .replace(/(^"|"$)/g, "'")
            .replace(/\\\\/g, '\\');
          name = ctx.stylize(name, 'string');
        }
      }
    
      return name + ': ' + str;
    }
    
    
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
    
      if (length > 60) {
        return braces[0] +
          (base === '' ? '' : base + '\n ') +
          ' ' +
          output.join(',\n ') +
          ' ' +
          braces[1];
      }
    
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    
    exports._extend = function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;
    
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    
  provide("should/lib/inspect", module.exports);
}(global));

// pakmanager:should/lib/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    /**
     * Check if given obj just a primitive type wrapper
     * @param {Object} obj
     * @returns {boolean}
     * @api private
     */
    exports.isWrapperType = function(obj) {
        return isNumber(obj) || isString(obj) || isBoolean(obj);
    };
    
    /**
     * Merge object b with object a.
     *
     *     var a = { foo: 'bar' }
     *       , b = { bar: 'baz' };
     *
     *     utils.merge(a, b);
     *     // => { foo: 'bar', bar: 'baz' }
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @api private
     */
    
    exports.merge = function(a, b){
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
    
    function isArray(arr) {
      return isObject(arr) && (arr.__ArrayLike || Array.isArray(arr));
    }
    
    exports.isArray = isArray;
    
    function isNumber(arg) {
      return typeof arg === 'number' || arg instanceof Number;
    }
    
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string' || arg instanceof String;
    }
    
    function isBoolean(arg) {
      return typeof arg === 'boolean' || arg instanceof Boolean;
    }
    exports.isBoolean = isBoolean;
    
    exports.isString = isString;
    
    function isBuffer(arg) {
      return typeof Buffer !== 'undefined' && arg instanceof Buffer;
    }
    
    exports.isBuffer = isBuffer;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    
    exports.isDate = isDate;
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    
    exports.isObject = isObject;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    
    exports.isRegExp = isRegExp;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isArguments(object) {
      return objectToString(object) === '[object Arguments]';
    }
    
    exports.isArguments = isArguments;
    
    exports.isFunction = function(arg) {
      return typeof arg === 'function' || arg instanceof Function;
    };
    
    function isError(e) {
      return (isObject(e) && objectToString(e) === '[object Error]') || (e instanceof Error);
    }
    exports.isError = isError;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    
    exports.isUndefined = isUndefined;
    
    exports.inspect =  require('should/lib/inspect').inspect;
    
    exports.AssertionError = require('assert').AssertionError;
    
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    
    exports.forOwn = function(obj, f, context) {
      for(var prop in obj) {
        if(hasOwnProperty.call(obj, prop)) {
          f.call(context, obj[prop], prop);
        }
      }
    };
    
    var functionNameRE = /^\s*function\s*(\S*)\s*\(/;
    
    exports.functionName = function(f) {
      if(f.name) {
        return f.name;
      }
      var name = f.toString().match(functionNameRE)[1];
      return name;
    };
    
    exports.formatProp = function(name) {
      name = JSON.stringify('' + name);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
      } else {
        name = name.replace(/'/g, "\\'")
          .replace(/\\"/g, '"')
          .replace(/(^"|"$)/g, "'")
          .replace(/\\\\/g, '\\');
      }
      return name;
    }
  provide("should/lib/util", module.exports);
}(global));

// pakmanager:should/lib/eql
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    // Taken from node's assert module, because it sucks
    // and exposes next to nothing useful.
    var util =  require('should/lib/util');
    
    module.exports = _deepEqual;
    
    var pSlice = Array.prototype.slice;
    
    function _deepEqual(actual, expected) {
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;
    
      } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
        if (actual.length != expected.length) return false;
    
        for (var i = 0; i < actual.length; i++) {
          if (actual[i] !== expected[i]) return false;
        }
    
        return true;
    
      // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
      } else if (util.isDate(actual) && util.isDate(expected)) {
        return actual.getTime() === expected.getTime();
    
      // 7.3 If the expected value is a RegExp object, the actual value is
      // equivalent if it is also a RegExp object with the same source and
      // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
      } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
        return actual.source === expected.source &&
               actual.global === expected.global &&
               actual.multiline === expected.multiline &&
               actual.lastIndex === expected.lastIndex &&
               actual.ignoreCase === expected.ignoreCase;
    
      // 7.4. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (!util.isObject(actual) && !util.isObject(expected)) {
        return actual == expected;
    
      // 7.5 For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected);
      }
    }
    
    
    function objEquiv (a, b) {
      if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
        return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (util.isArguments(a)) {
        if (!util.isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b);
      }
      try{
        var ka = Object.keys(a),
          kb = Object.keys(b),
          key, i;
      } catch (e) {//happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key])) return false;
      }
      return true;
    }
    
  provide("should/lib/eql", module.exports);
}(global));

// pakmanager:should/lib/ext/assert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    var util =  require('should/lib/util')
      , assert = require('assert')
      , AssertionError = assert.AssertionError;
    
    module.exports = function(should) {
      var i = should.format;
    
      /**
       * Expose assert to should
       *
       * This allows you to do things like below
       * without require()ing the assert module.
       *
       *    should.equal(foo.bar, undefined);
       *
       */
      util.merge(should, assert);
    
      /**
       * Assert _obj_ exists, with optional message.
       *
       * @param {*} obj
       * @param {String} [msg]
       * @api public
       */
      should.exist = should.exists = function(obj, msg) {
        if(null == obj) {
          throw new AssertionError({
            message: msg || ('expected ' + i(obj) + ' to exist'), stackStartFunction: should.exist
          });
        }
      };
    
      /**
       * Asserts _obj_ does not exist, with optional message.
       *
       * @param {*} obj
       * @param {String} [msg]
       * @api public
       */
    
      should.not = {};
      should.not.exist = should.not.exists = function(obj, msg) {
        if(null != obj) {
          throw new AssertionError({
            message: msg || ('expected ' + i(obj) + ' to not exist'), stackStartFunction: should.not.exist
          });
        }
      };
    };
  provide("should/lib/ext/assert", module.exports);
}(global));

// pakmanager:should/lib/ext/chain
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    module.exports = function(should, Assertion) {
    
      function addLink(name) {
        Object.defineProperty(Assertion.prototype, name, {
          get: function() {
            return this;
          },
          enumerable: true
        });
      }
    
      ['an', 'of', 'a', 'and', 'be', 'have', 'with', 'is', 'which', 'the'].forEach(addLink);
    };
  provide("should/lib/ext/chain", module.exports);
}(global));

// pakmanager:should/lib/ext/bool
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    module.exports = function(should, Assertion) {
      Assertion.add('true', function() {
        this.is.exactly(true);
      }, true);
    
      Assertion.alias('true', 'True');
    
      Assertion.add('false', function() {
        this.is.exactly(false);
      }, true);
    
      Assertion.alias('false', 'False');
    
      Assertion.add('ok', function() {
        this.params = { operator: 'to be truthy' };
    
        this.assert(this.obj);
      }, true);
    };
  provide("should/lib/ext/bool", module.exports);
}(global));

// pakmanager:should/lib/ext/number
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    module.exports = function(should, Assertion) {
      Assertion.add('NaN', function() {
        this.params = { operator: 'to be NaN' };
    
        this.assert(this.obj !== this.obj);
      }, true);
    
      Assertion.add('Infinity', function() {
        this.params = { operator: 'to be Infinity' };
    
        this.is.a.Number
          .and.not.a.NaN
          .and.assert(!isFinite(this.obj));
      }, true);
    
      Assertion.add('within', function(start, finish, description) {
        this.params = { operator: 'to be within ' + start + '..' + finish, message: description };
    
        this.assert(this.obj >= start && this.obj <= finish);
      });
    
      Assertion.add('approximately', function(value, delta, description) {
        this.params = { operator: 'to be approximately ' + value + " ±" + delta, message: description };
    
        this.assert(Math.abs(this.obj - value) <= delta);
      });
    
      Assertion.add('above', function(n, description) {
        this.params = { operator: 'to be above ' + n, message: description };
    
        this.assert(this.obj > n);
      });
    
      Assertion.add('below', function(n, description) {
        this.params = { operator: 'to be below ' + n, message: description };
    
        this.assert(this.obj < n);
      });
    
      Assertion.alias('above', 'greaterThan');
      Assertion.alias('below', 'lessThan');
    
    };
    
  provide("should/lib/ext/number", module.exports);
}(global));

// pakmanager:should/lib/ext/eql
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    var eql =  require('should/lib/eql');
    
    module.exports = function(should, Assertion) {
      Assertion.add('eql', function(val, description) {
        this.params = { operator: 'to equal', expected: val, showDiff: true, message: description };
    
        this.assert(eql(val, this.obj));
      });
    
      Assertion.add('equal', function(val, description) {
        this.params = { operator: 'to be', expected: val, showDiff: true, message: description };
    
        this.assert(val === this.obj);
      });
    
      Assertion.alias('equal', 'exactly');
    };
  provide("should/lib/ext/eql", module.exports);
}(global));

// pakmanager:should/lib/ext/type
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    var util =  require('should/lib/util');
    
    module.exports = function(should, Assertion) {
      Assertion.add('Number', function() {
        this.params = { operator: 'to be a number' };
    
        this.assert(util.isNumber(this.obj));
      }, true);
    
      Assertion.add('arguments', function() {
        this.params = { operator: 'to be arguments' };
    
        this.assert(util.isArguments(this.obj));
      }, true);
    
      Assertion.add('type', function(type, description) {
        this.params = { operator: 'to have type ' + type, message: description };
    
        (typeof this.obj).should.be.exactly(type, description);
      });
    
      Assertion.add('instanceof', function(constructor, description) {
        this.params = { operator: 'to be an instance of ' + util.functionName(constructor), message: description };
    
        this.assert(Object(this.obj) instanceof constructor);
      });
    
      Assertion.add('Function', function() {
        this.params = { operator: 'to be a function' };
    
        this.assert(util.isFunction(this.obj));
      }, true);
    
      Assertion.add('Object', function() {
        this.params = { operator: 'to be an object' };
    
        this.assert(util.isObject(this.obj));
      }, true);
    
      Assertion.add('String', function() {
        this.params = { operator: 'to be a string' };
    
        this.assert(util.isString(this.obj));
      }, true);
    
      Assertion.add('Array', function() {
        this.params = { operator: 'to be an array' };
    
        this.assert(util.isArray(this.obj));
      }, true);
    
      Assertion.add('Boolean', function() {
        this.params = { operator: 'to be a boolean' };
    
        this.assert(util.isBoolean(this.obj));
      }, true);
    
      Assertion.add('Error', function() {
        this.params = { operator: 'to be an error' };
    
        this.assert(util.isError(this.obj));
      }, true);
    
      Assertion.add('null', function() {
        this.params = { operator: 'to be null' };
    
        this.assert(this.obj === null);
      }, true);
    
      Assertion.alias('null', 'Null');
    
      Assertion.alias('instanceof', 'instanceOf');
    };
    
  provide("should/lib/ext/type", module.exports);
}(global));

// pakmanager:should/lib/ext/string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    module.exports = function(should, Assertion) {
      Assertion.add('startWith', function(str, description) {
        this.params = { operator: 'to start with ' + should.format(str), message: description };
    
        this.assert(0 === this.obj.indexOf(str));
      });
    
      Assertion.add('endWith', function(str, description) {
        this.params = { operator: 'to end with ' + should.format(str), message: description };
    
        this.assert(this.obj.indexOf(str, this.obj.length - str.length) >= 0);
      });
    };
  provide("should/lib/ext/string", module.exports);
}(global));

// pakmanager:should/lib/ext/property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    var util =  require('should/lib/util'),
      eql =  require('should/lib/eql');
    
    var aSlice = Array.prototype.slice;
    
    module.exports = function(should, Assertion) {
      var i = should.format;
    
      Assertion.add('enumerable', function(name, val) {
        name = String(name);
    
        this.params = {
          operator:"to have enumerable property " + util.formatProp(name)
        };
    
        this.assert(this.obj.propertyIsEnumerable(name));
    
        if(arguments.length > 1){
          this.params.operator += " equal to "+i(val);
          this.assert(eql(val, this.obj[name]));
        }
      });
    
      Assertion.add('property', function(name, val) {
        name = String(name);
        if(arguments.length > 1) {
          var p = {};
          p[name] = val;
          this.have.properties(p);
        } else {
          this.have.properties(name);
        }
        this.obj = this.obj[name];
      });
    
      Assertion.add('properties', function(names) {
        var values = {};
        if(arguments.length > 1) {
          names = aSlice.call(arguments);
        } else if(!util.isArray(names)) {
          if(util.isString(names)) {
            names = [names];
          } else {
            values = names;
            names = Object.keys(names);
          }
        }
    
        var obj = Object(this.obj), missingProperties = [];
    
        //just enumerate properties and check if they all present
        names.forEach(function(name) {
          if(!(name in obj)) missingProperties.push(util.formatProp(name));
        });
    
        var props = missingProperties;
        if(props.length === 0) {
          props = names.map(util.formatProp);
        } else if(this.anyOne) {
          props = names.filter(function(name) {
            return missingProperties.indexOf(util.formatProp(name)) < 0;
          }).map(util.formatProp);
        }
    
        var operator = (props.length === 1 ?
          'to have property ' : 'to have '+(this.anyOne? 'any of ' : '')+'properties ') + props.join(', ');
    
        this.params = { operator: operator };
    
        //check that all properties presented
        //or if we request one of them that at least one them presented
        this.assert(missingProperties.length === 0 || (this.anyOne && missingProperties.length != names.length));
    
        // check if values in object matched expected
        var valueCheckNames = Object.keys(values);
        if(valueCheckNames.length) {
          var wrongValues = [];
          props = [];
    
          // now check values, as there we have all properties
          valueCheckNames.forEach(function(name) {
            var value = values[name];
            if(!eql(obj[name], value)) {
              wrongValues.push(util.formatProp(name) + ' of ' + i(value) + ' (got ' + i(obj[name]) + ')');
            } else {
              props.push(util.formatProp(name) + ' of ' + i(value));
            }
          });
    
          if((wrongValues.length !== 0 && !this.anyOne) || (this.anyOne && props.length === 0)) {
            props = wrongValues;
          }
    
          operator = (props.length === 1 ?
            'to have property ' : 'to have '+(this.anyOne? 'any of ' : '')+'properties ') + props.join(', ');
    
          this.params = { operator: operator };
    
          //if there is no not matched values
          //or there is at least one matched
          this.assert(wrongValues.length === 0 || (this.anyOne && wrongValues.length != valueCheckNames.length));
        }
      });
    
      Assertion.add('length', function(n, description) {
        this.have.property('length', n, description);
      });
    
      Assertion.alias('length', 'lengthOf');
    
      var hasOwnProperty = Object.prototype.hasOwnProperty;
    
      Assertion.add('ownProperty', function(name, description) {
        name = String(name);
        this.params = { operator: 'to have own property ' + util.formatProp(name), message: description };
    
        this.assert(hasOwnProperty.call(this.obj, name));
    
        this.obj = this.obj[name];
      });
    
      Assertion.alias('ownProperty', 'hasOwnProperty');
    
      Assertion.add('empty', function() {
        this.params = { operator: 'to be empty' };
    
        if(util.isString(this.obj) || util.isArray(this.obj) || util.isArguments(this.obj)) {
          this.have.property('length', 0);
        } else {
          var obj = Object(this.obj); // wrap to reference for booleans and numbers
          for(var prop in obj) {
            this.have.not.ownProperty(prop);
          }
        }
      }, true);
    
      Assertion.add('keys', function(keys) {
        if(arguments.length > 1) keys = aSlice.call(arguments);
        else if(arguments.length === 1 && util.isString(keys)) keys = [ keys ];
        else if(arguments.length === 0) keys = [];
    
        keys = keys.map(String);
    
        var obj = Object(this.obj);
    
        // first check if some keys are missing
        var missingKeys = [];
        keys.forEach(function(key) {
          if(!hasOwnProperty.call(this.obj, key))
            missingKeys.push(util.formatProp(key));
        }, this);
    
        // second check for extra keys
        var extraKeys = [];
        Object.keys(obj).forEach(function(key) {
          if(keys.indexOf(key) < 0) {
            extraKeys.push(util.formatProp(key));
          }
        });
    
        var verb = keys.length === 0 ? 'to be empty' :
          'to have ' + (keys.length === 1 ? 'key ' : 'keys ');
    
        this.params = { operator: verb + keys.map(util.formatProp).join(', ')};
    
        if(missingKeys.length > 0)
          this.params.operator += '\n\tmissing keys: ' + missingKeys.join(', ');
    
        if(extraKeys.length > 0)
          this.params.operator += '\n\textra keys: ' + extraKeys.join(', ');
    
        this.assert(missingKeys.length === 0 && extraKeys.length === 0);
      });
    
      Assertion.alias("keys", "key");
    
      Assertion.add('propertyByPath', function(properties) {
        if(arguments.length > 1) properties = aSlice.call(arguments);
        else if(arguments.length === 1 && util.isString(properties)) properties = [ properties ];
        else if(arguments.length === 0) properties = [];
    
        var allProps =  properties.map(util.formatProp);
    
        properties = properties.map(String);
    
        var obj = should(Object(this.obj));
    
        var foundProperties = [];
    
        var currentProperty;
        while(currentProperty = properties.shift()) {
          this.params = { operator: 'to have property by path ' + allProps.join(', ') + ' - failed on ' + util.formatProp(currentProperty) };
          obj = obj.have.property(currentProperty);
          foundProperties.push(currentProperty);
        }
    
        this.params = { operator: 'to have property by path ' + allProps.join(', ') };
    
        this.obj = obj.obj;
      });
    };
    
  provide("should/lib/ext/property", module.exports);
}(global));

// pakmanager:should/lib/ext/error
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    var util =  require('should/lib/util');
    
    module.exports = function(should, Assertion) {
      var i = should.format;
    
      Assertion.add('throw', function(message, properties) {
        var fn = this.obj
          , err = {}
          , errorInfo = ''
          , thrown = false;
    
        var errorMatched = true;
    
        try {
          fn();
        } catch(e) {
          thrown = true;
          err = e;
        }
    
        if(thrown) {
          if(message) {
            if('string' == typeof message) {
              errorMatched = message == err.message;
            } else if(message instanceof RegExp) {
              errorMatched = message.test(err.message);
            } else if('function' == typeof message) {
              errorMatched = err instanceof message;
            } else if(util.isObject(message)) {
              try {
                err.should.match(message);
              } catch(e) {
                if(e instanceof should.AssertionError) {
                  errorInfo = ": " + e.message;
                  errorMatched = false;
                } else {
                  throw e;
                }
              }
            }
    
            if(!errorMatched) {
              if('string' == typeof message || message instanceof RegExp) {
                errorInfo = " with a message matching " + i(message) + ", but got '" + err.message + "'";
              } else if('function' == typeof message) {
                errorInfo = " of type " + util.functionName(message) + ", but got " + util.functionName(err.constructor);
              }
            } else if('function' == typeof message && properties) {
              try {
                err.should.match(properties);
              } catch(e) {
                if(e instanceof should.AssertionError) {
                  errorInfo = ": " + e.message;
                  errorMatched = false;
                } else {
                  throw e;
                }
              }
            }
          } else {
            errorInfo = " (got " + i(err) + ")";
          }
        }
    
        this.params = { operator: 'to throw exception' + errorInfo };
    
        this.assert(thrown);
        this.assert(errorMatched);
      });
    
      Assertion.alias('throw', 'throwError');
    };
  provide("should/lib/ext/error", module.exports);
}(global));

// pakmanager:should/lib/ext/match
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    var util =  require('should/lib/util'),
      eql =  require('should/lib/eql');
    
    module.exports = function(should, Assertion) {
      var i = should.format;
    
      Assertion.add('match', function(other, description) {
        this.params = { operator: 'to match ' + i(other), message: description };
    
        if(!eql(this.obj, other)) {
          if(util.isRegExp(other)) { // something - regex
    
            if(util.isString(this.obj)) {
    
              this.assert(other.exec(this.obj));
            } else if(util.isArray(this.obj)) {
    
              this.obj.forEach(function(item) {
                this.assert(other.exec(item));// should we try to convert to String and exec?
              }, this);
            } else if(util.isObject(this.obj)) {
    
              var notMatchedProps = [], matchedProps = [];
              util.forOwn(this.obj, function(value, name) {
                if(other.exec(value)) matchedProps.push(util.formatProp(name));
                else notMatchedProps.push(util.formatProp(name) + ' (' + i(value) +')');
              }, this);
    
              if(notMatchedProps.length)
                this.params.operator += '\n\tnot matched properties: ' + notMatchedProps.join(', ');
              if(matchedProps.length)
                this.params.operator += '\n\tmatched properties: ' + matchedProps.join(', ');
    
              this.assert(notMatchedProps.length == 0);
            } // should we try to convert to String and exec?
          } else if(util.isFunction(other)) {
            var res;
            try {
              res = other(this.obj);
            } catch(e) {
              if(e instanceof should.AssertionError) {
                this.params.operator += '\n\t' + e.message;
              }
              throw e;
            }
    
            if(res instanceof Assertion) {
              this.params.operator += '\n\t' + res.getMessage();
            }
    
            //if we throw exception ok - it is used .should inside
            if(util.isBoolean(res)) {
              this.assert(res); // if it is just boolean function assert on it
            }
          } else if(util.isObject(other)) { // try to match properties (for Object and Array)
            notMatchedProps = []; matchedProps = [];
    
            util.forOwn(other, function(value, key) {
              try {
                should(this.obj[key]).match(value);
                matchedProps.push(util.formatProp(key));
              } catch(e) {
                if(e instanceof should.AssertionError) {
                  notMatchedProps.push(util.formatProp(key) + ' (' + i(this.obj[key]) + ')');
                } else {
                  throw e;
                }
              }
            }, this);
    
            if(notMatchedProps.length)
              this.params.operator += '\n\tnot matched properties: ' + notMatchedProps.join(', ');
            if(matchedProps.length)
              this.params.operator += '\n\tmatched properties: ' + matchedProps.join(', ');
    
            this.assert(notMatchedProps.length == 0);
          } else {
            this.assert(false);
          }
        }
      });
    
      Assertion.add('matchEach', function(other, description) {
        this.params = { operator: 'to match each ' + i(other), message: description };
    
        var f = other;
    
        if(util.isRegExp(other))
          f = function(it) {
            return !!other.exec(it);
          };
        else if(!util.isFunction(other))
          f = function(it) {
            return eql(it, other);
          };
    
        util.forOwn(this.obj, function(value, key) {
          var res = f(value, key);
    
          //if we throw exception ok - it is used .should inside
          if(util.isBoolean(res)) {
            this.assert(res); // if it is just boolean function assert on it
          }
        }, this);
      });
    };
  provide("should/lib/ext/match", module.exports);
}(global));

// pakmanager:should/lib/ext/contain
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    var util =  require('should/lib/util'),
      eql =  require('should/lib/eql');
    
    module.exports = function(should, Assertion) {
      var i = should.format;
    
      Assertion.add('containEql', function(other) {
        this.params = { operator: 'to contain ' + i(other) };
        var obj = this.obj;
        if(util.isArray(obj)) {
          this.assert(obj.some(function(item) {
            return eql(item, other);
          }));
        } else if(util.isString(obj)) {
          // expect obj to be string
          this.assert(obj.indexOf(String(other)) >= 0);
        } else if(util.isObject(obj)) {
          // object contains object case
          util.forOwn(other, function(value, key) {
            obj.should.have.property(key, value);
          });
        } else {
          //other uncovered cases
          this.assert(false);
        }
      });
    
      Assertion.add('containDeepOrdered', function(other) {
        this.params = { operator: 'to contain ' + i(other) };
    
        var obj = this.obj;
        if(util.isArray(obj)) {
          if(util.isArray(other)) {
            var otherIdx = 0;
            obj.forEach(function(item) {
              try {
                should(item).not.be.Null.and.containDeep(other[otherIdx]);
                otherIdx++;
              } catch(e) {
                if(e instanceof should.AssertionError) {
                  return;
                }
                throw e;
              }
            }, this);
    
            this.assert(otherIdx == other.length);
            //search array contain other as sub sequence
          } else {
            this.assert(false);
          }
        } else if(util.isString(obj)) {// expect other to be string
          this.assert(obj.indexOf(String(other)) >= 0);
        } else if(util.isObject(obj)) {// object contains object case
          if(util.isObject(other)) {
            util.forOwn(other, function(value, key) {
              should(obj[key]).not.be.Null.and.containDeep(value);
            });
          } else {//one of the properties contain value
            this.assert(false);
          }
        } else {
          this.eql(other);
        }
      });
    
      Assertion.add('containDeep', function(other) {
        this.params = { operator: 'to contain ' + i(other) };
    
        var obj = this.obj;
        if(util.isArray(obj)) {
          if(util.isArray(other)) {
            var usedKeys = {};
            other.forEach(function(otherItem) {
              this.assert(obj.some(function(item, index) {
                if(index in usedKeys) return false;
    
                try {
                  should(item).not.be.Null.and.containDeep(otherItem);
                  usedKeys[index] = true;
                  return true;
                } catch(e) {
                  if(e instanceof should.AssertionError) {
                    return false;
                  }
                  throw e;
                }
              }));
            }, this);
    
          } else {
            this.assert(false);
          }
        } else if(util.isString(obj)) {// expect other to be string
          this.assert(obj.indexOf(String(other)) >= 0);
        } else if(util.isObject(obj)) {// object contains object case
          if(util.isObject(other)) {
            util.forOwn(other, function(value, key) {
              should(obj[key]).not.be.Null.and.containDeep(value);
            });
          } else {//one of the properties contain value
            this.assert(false);
          }
        } else {
          this.eql(other);
        }
      });
    
    };
    
  provide("should/lib/ext/contain", module.exports);
}(global));

// pakmanager:should
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Should
     * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    
    
    var util =  require('should/lib/util'),
      AssertionError = util.AssertionError,
      inspect = util.inspect;
    
    /**
     * Our function should
     * @param obj
     * @returns {Assertion}
     */
    var should = function(obj) {
      return new Assertion(util.isWrapperType(obj) ? obj.valueOf() : obj);
    };
    
    /**
     * Initialize a new `Assertion` with the given _obj_.
     *
     * @param {*} obj
     * @api private
     */
    
    var Assertion = should.Assertion = function Assertion(obj) {
      this.obj = obj;
    };
    
    
    /**
     Way to extend Assertion function. It uses some logic
     to define only positive assertions and itself rule with negative assertion.
    
     All actions happen in subcontext and this method take care about negation.
     Potentially we can add some more modifiers that does not depends from state of assertion.
     */
    Assertion.add = function(name, f, isGetter) {
      var prop = { enumerable: true };
      prop[isGetter ? 'get' : 'value'] = function() {
        var context = new Assertion(this.obj);
        context.copy = context.copyIfMissing;
        context.anyOne = this.anyOne;
    
        try {
          f.apply(context, arguments);
        } catch(e) {
          //copy data from sub context to this
          this.copy(context);
    
          //check for fail
          if(e instanceof should.AssertionError) {
            //negative fail
            if(this.negate) {
              this.obj = context.obj;
              this.negate = false;
              return this;
            }
            this.assert(false);
          }
          // throw if it is another exception
          throw e;
        }
        //copy data from sub context to this
        this.copy(context);
        if(this.negate) {
          this.assert(false);
        }
    
        this.obj = context.obj;
        this.negate = false;
        return this;
      };
    
      Object.defineProperty(Assertion.prototype, name, prop);
    };
    
    Assertion.alias = function(from, to) {
      var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);
      if(!desc) throw new Error('Alias ' + from + ' -> ' + to + ' could not be created as ' + from + ' not defined');
      Object.defineProperty(Assertion.prototype, to, desc);
    };
    
    should.AssertionError = AssertionError;
    should.format = function (value) {
      if(util.isDate(value) && typeof value.inspect !== 'function') return value.toISOString(); //show millis in dates
      return inspect(value, { depth: null });
    };
    
    should.use = function(f) {
      f(this, Assertion);
      return this;
    };
    
    
    /**
     * Expose should to external world.
     */
    exports = module.exports = should;
    
    
    /**
     * Expose api via `Object#should`.
     *
     * @api public
     */
    
    Object.defineProperty(Object.prototype, 'should', {
      set: function() {
      },
      get: function() {
        return should(this);
      },
      configurable: true
    });
    
    
    Assertion.prototype = {
      constructor: Assertion,
    
      assert: function(expr) {
        if(expr) return this;
    
        var params = this.params;
    
        var msg = params.message, generatedMessage = false;
        if(!msg) {
          msg = this.getMessage();
          generatedMessage = true;
        }
    
        var err = new AssertionError({
          message: msg, actual: this.obj, expected: params.expected, stackStartFunction: this.assert
        });
    
        err.showDiff = params.showDiff;
        err.operator = params.operator;
        err.generatedMessage = generatedMessage;
    
        throw err;
      },
    
      getMessage: function() {
        return 'expected ' + ('obj' in this.params ? this.params.obj: should.format(this.obj)) + (this.negate ? ' not ': ' ') +
           this.params.operator + ('expected' in this.params  ? ' ' + should.format(this.params.expected) : '');
      },
    
      copy: function(other) {
        this.params = other.params;
      },
    
      copyIfMissing: function(other) {
        if(!this.params) this.params = other.params;
      },
    
    
      /**
       * Negation modifier.
       *
       * @api public
       */
    
      get not() {
        this.negate = !this.negate;
        return this;
      },
    
      /**
       * Any modifier - it affect on execution of sequenced assertion to do not check all, but any of
       *
       * @api public
       */
      get any() {
        this.anyOne = true;
        return this;
      }
    };
    
    should
      .use( require('should/lib/ext/assert'))
      .use( require('should/lib/ext/chain'))
      .use( require('should/lib/ext/bool'))
      .use( require('should/lib/ext/number'))
      .use( require('should/lib/ext/eql'))
      .use( require('should/lib/ext/type'))
      .use( require('should/lib/ext/string'))
      .use( require('should/lib/ext/property'))
      .use( require('should/lib/ext/error'))
      .use( require('should/lib/ext/match'))
      .use( require('should/lib/ext/contain'));
    
  provide("should", module.exports);
}(global));

// pakmanager:supertest/lib/test
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var request = require('superagent')
      , util = require('util')
      , http = require('http')
      , https = require('https')
      , assert = require('assert')
      , Request = request.Request;
    
    /**
     * Expose `Test`.
     */
    
    module.exports = Test;
    
    /**
     * Initialize a new `Test` with the given `app`,
     * request `method` and `path`.
     *
     * @param {Server} app
     * @param {String} method
     * @param {String} path
     * @api public
     */
    
    function Test(app, method, path) {
      Request.call(this, method, path);
      this.redirects(0);
      this.buffer();
      this.app = app;
      this._fields = {};
      this._bodies = [];
      this._asserts = [];
      this.url = 'string' == typeof app
        ? app + path
        : this.serverAddress(app, path);
    }
    
    /**
     * Inherits from `Request.prototype`.
     */
    
    Test.prototype.__proto__ = Request.prototype;
    
    /**
     * Returns a URL, extracted from a server.
     *
     * @param {Server} app
     * @param {String} path
     * @returns {String} URL address
     * @api private
     */
    
    Test.prototype.serverAddress = function(app, path){
      var addr = app.address();
      if (!addr) this._server = app.listen(0);
      var port = app.address().port;
      var protocol = app instanceof https.Server ? 'https' : 'http';
      return protocol + '://127.0.0.1:' + port + path;
    };
    
    /**
     * Expectations:
     *
     *   .expect(200)
     *   .expect(200, fn)
     *   .expect(200, body)
     *   .expect('Some body')
     *   .expect('Some body', fn)
     *   .expect('Content-Type', 'application/json')
     *   .expect('Content-Type', 'application/json', fn)
     *   .expect(fn)
     *
     * @return {Test}
     * @api public
     */
    
    Test.prototype.expect = function(a, b, c){
      var self = this;
    
      // callback
      if ('function' == typeof a) {
        this._asserts.push(a);
        return this;
      }
      if ('function' == typeof b) this.end(b);
      if ('function' == typeof c) this.end(c);
    
      // status
      if ('number' == typeof a) {
        this._status = a;
        // body
        if ('function' != typeof b && arguments.length > 1) this._bodies.push(b);
        return this;
      }
    
      // header field
      if ('string' == typeof b || 'number' == typeof b || b instanceof RegExp) {
        if (!this._fields[a]) this._fields[a] = [];
        this._fields[a].push(b);
        return this;
      }
    
      // body
      this._bodies.push(a);
    
      return this;
    };
    
    /**
     * Defer invoking superagent's `.end()` until
     * the server is listening.
     *
     * @param {Function} fn
     * @api public
     */
    
    Test.prototype.end = function(fn){
      var self = this;
      var server = this._server;
      var end = Request.prototype.end;
    
      end.call(this, function(err, res){
        if (err) return fn(err);
        if (server) return server.close(assert);
    
        assert();
    
        function assert(){
          self.assert(res, fn);
        }
      });
    
      return this;
    };
    
    /**
     * Perform assertions and invoke `fn(err)`.
     *
     * @param {Response} res
     * @param {Function} fn
     * @api private
     */
    
    Test.prototype.assert = function(res, fn){
      var status = this._status
        , fields = this._fields
        , bodies = this._bodies
        , expecteds
        , actual
        , re;
    
      // body
      for (var i = 0; i < bodies.length; i++) {
        var body = bodies[i];
        var isregexp = body instanceof RegExp;
        // parsed
        if ('object' == typeof body && !isregexp) {
          try {
            assert.deepEqual(body, res.body);
          } catch (err) {
            var a = util.inspect(body);
            var b = util.inspect(res.body);
            return fn(error('expected ' + a + ' response body, got ' + b, body, res.body));
          }
        } else {
          // string
          if (body !== res.text) {
            var a = util.inspect(body);
            var b = util.inspect(res.text);
    
            // regexp
            if (isregexp) {
              if (!body.test(res.text)) {
                return fn(error('expected body ' + b + ' to match ' + body, body, res.body));
              }
            } else {
              return fn(error('expected ' + a + ' response body, got ' + b, body, res.body));
            }
          }
        }
      }
    
      // fields
      for (var field in fields) {
        expecteds = fields[field];
        actual = res.header[field.toLowerCase()];
        if (null == actual) return fn(new Error('expected "' + field + '" header field'));
        for (var i = 0; i < expecteds.length; i++) {
          var fieldExpected = expecteds[i];
          if (fieldExpected == actual) continue;
          if (fieldExpected instanceof RegExp) re = fieldExpected;
          if (re && re.test(actual)) continue;
          if (re) return fn(new Error('expected "' + field + '" matching ' + fieldExpected + ', got "' + actual + '"'));
          return fn(new Error('expected "' + field + '" of "' + fieldExpected + '", got "' + actual + '"'));
        }
      }
    
      // status
      if (status && res.status !== status) {
        var a = http.STATUS_CODES[status];
        var b = http.STATUS_CODES[res.status];
        return fn(new Error('expected ' + status + ' "' + a + '", got ' + res.status + ' "' + b + '"'), res);
      }
    
      // asserts
      for (var i = 0; i < this._asserts.length; i++) {
        var check = this._asserts[i];
        var err;
        try {
          err = check(res);
        } catch(e) {
          err = e;
        }
        if (!err) continue;
        return fn(err instanceof Error ? err : new Error(err))
      }
    
      fn.call(this, null, res);
    };
    
    /**
     * Return an `Error` with `msg` and results properties.
     *
     * @param {String} msg
     * @param {Mixed} expected
     * @param {Mixed} actual
     * @return {Error}
     * @api private
     */
    
    function error(msg, expected, actual) {
      var err = new Error(msg);
      err.expected = expected;
      err.actual = actual;
      err.showDiff = true;
      return err;
    }
    
    
  provide("supertest/lib/test", module.exports);
}(global));

// pakmanager:supertest/lib/agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Agent = require('superagent').agent
    	, methods = require('methods')
    	, http = require('http')
    	, Test =  require('supertest/lib/test');
    
    /**
     * Expose `Agent`.
     */
    
    module.exports = TestAgent;
    
    /**
     * Initialize a new `TestAgent`.
     *
     * @param {Function|Server} app
     * @api public
     */
    
    function TestAgent(app){
    	if (!(this instanceof TestAgent)) return new TestAgent(app);
    	if ('function' == typeof app) app = http.createServer(app);
    	Agent.call(this);
    	this.app = app;
    }
    
    /**
     * Inherits from `Agent.prototype`.
     */
    
    TestAgent.prototype.__proto__ = Agent.prototype;
    
    // override HTTP verb methods
    methods.forEach(function(method){
      TestAgent.prototype[method] = function(url, fn){
        var req = new Test(this.app, method.toUpperCase(), url);
    
        req.on('response', this.saveCookies.bind(this));
        req.on('redirect', this.saveCookies.bind(this));
        req.on('redirect', this.attachCookies.bind(this, req));
        this.attachCookies(req);
    
        return req;
      };
    });
    
    TestAgent.prototype.del = TestAgent.prototype.delete;
    
  provide("supertest/lib/agent", module.exports);
}(global));

// pakmanager:supertest
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var methods = require('methods')
      , Test =  require('supertest/lib/test')
      , http = require('http');
    
    /**
     * Test against the given `app`,
     * returning a new `Test`.
     *
     * @param {Function|Server} app
     * @return {Test}
     * @api public
     */
    
    module.exports = function(app){
      if ('function' == typeof app) app = http.createServer(app);
      var obj = {};
    
      methods.forEach(function(method){
        obj[method] = function(url){
          return new Test(app, method, url);
        };
      });
    
      // Support previous use of del
      obj.del = obj['delete'];
    
      return obj;
    };
    
    /**
     * Expose `Test`
     */
    
    module.exports.Test = Test;
    
    /**
     * Expose the agent function
     */
    
    module.exports.agent =  require('supertest/lib/agent');
    
  provide("supertest", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/contacts/ContactFormSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.572Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The FieldsItem class
     * @constructor
     * @alias FieldsItem
     */
    function FieldsItem() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The value value
         * @member
         */
        this.value = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link FieldsItem }
     */
    FieldsItem.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'value'
     * @returns {@link FieldsItem }
     */
    FieldsItem.prototype.withValue = function(value) {
        this['value'] = value;
        return this;
    };
    /**
     * The ContactFormSchema class
     * @constructor
     * @alias ContactFormSchema
     */
    function ContactFormSchema() {
    
    }
    
    /**
     * @returns {@link FieldsItem }
     */
    ContactFormSchema.prototype.newField = function() {
        return Object.create(FieldsItem.prototype);
    };
    /**
     * @param { FieldsItem } arrayItem the {@link FieldsItem } object to add
     * @returns {@link ContactFormSchema }
     */
    ContactFormSchema.prototype.addField = function(arrayItem) {
        if (!this.hasOwnProperty('fields')) {
            this['fields'] = [];
        }
        this['fields'].push(arrayItem);
        return this;
    };
    
    module.exports = ContactFormSchema;
    
  provide("openapi-node/lib/schemas/contacts/ContactFormSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/contacts/ContactCreateSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.604Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Name class
     * @constructor
     * @alias Name
     */
    function Name() {
        /**
         * The prefix value
         * @member
         */
        this.prefix = null;
        /**
         * The first value
         * @member
         */
        this.first = null;
        /**
         * The middle value
         * @member
         */
        this.middle = null;
        /**
         * The last value
         * @member
         */
        this.last = null;
        /**
         * The suffix value
         * @member
         */
        this.suffix = null;
    
    }
    
    /**
     * @param value the value of 'prefix'
     * @returns {@link Name }
     */
    Name.prototype.withPrefix = function(value) {
        this['prefix'] = value;
        return this;
    };
    /**
     * @param value the value of 'first'
     * @returns {@link Name }
     */
    Name.prototype.withFirst = function(value) {
        this['first'] = value;
        return this;
    };
    /**
     * @param value the value of 'middle'
     * @returns {@link Name }
     */
    Name.prototype.withMiddle = function(value) {
        this['middle'] = value;
        return this;
    };
    /**
     * @param value the value of 'last'
     * @returns {@link Name }
     */
    Name.prototype.withLast = function(value) {
        this['last'] = value;
        return this;
    };
    /**
     * @param value the value of 'suffix'
     * @returns {@link Name }
     */
    Name.prototype.withSuffix = function(value) {
        this['suffix'] = value;
        return this;
    };
    /**
     * The Company class
     * @constructor
     * @alias Company
     */
    function Company() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The role value
         * @member
         */
        this.role = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Company }
     */
    Company.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'role'
     * @returns {@link Company }
     */
    Company.prototype.withRole = function(value) {
        this['role'] = value;
        return this;
    };
    /**
     * The EmailsItem class
     * @constructor
     * @alias EmailsItem
     */
    function EmailsItem() {
        /**
         * The tag value
         * @member
         */
        this.tag = null;
        /**
         * The email value
         * @member
         */
        this.email = null;
    
    }
    
    /**
     * @param value the value of 'tag'
     * @returns {@link EmailsItem }
     */
    EmailsItem.prototype.withTag = function(value) {
        this['tag'] = value;
        return this;
    };
    /**
     * @param value the value of 'email'
     * @returns {@link EmailsItem }
     */
    EmailsItem.prototype.withEmail = function(value) {
        this['email'] = value;
        return this;
    };
    /**
     * The PhonesItem class
     * @constructor
     * @alias PhonesItem
     */
    function PhonesItem() {
        /**
         * The tag value
         * @member
         */
        this.tag = null;
        /**
         * The phone value
         * @member
         */
        this.phone = null;
    
    }
    
    /**
     * @param value the value of 'tag'
     * @returns {@link PhonesItem }
     */
    PhonesItem.prototype.withTag = function(value) {
        this['tag'] = value;
        return this;
    };
    /**
     * @param value the value of 'phone'
     * @returns {@link PhonesItem }
     */
    PhonesItem.prototype.withPhone = function(value) {
        this['phone'] = value;
        return this;
    };
    /**
     * The AddressesItem class
     * @constructor
     * @alias AddressesItem
     */
    function AddressesItem() {
        /**
         * The tag value
         * @member
         */
        this.tag = null;
        /**
         * The address value
         * @member
         */
        this.address = null;
        /**
         * The neighborhood value
         * @member
         */
        this.neighborhood = null;
        /**
         * The city value
         * @member
         */
        this.city = null;
        /**
         * The region value
         * @member
         */
        this.region = null;
        /**
         * The postalCode value
         * @member
         */
        this.postalCode = null;
        /**
         * The country value
         * @member
         */
        this.country = null;
    
    }
    
    /**
     * @param value the value of 'tag'
     * @returns {@link AddressesItem }
     */
    AddressesItem.prototype.withTag = function(value) {
        this['tag'] = value;
        return this;
    };
    /**
     * @param value the value of 'address'
     * @returns {@link AddressesItem }
     */
    AddressesItem.prototype.withAddress = function(value) {
        this['address'] = value;
        return this;
    };
    /**
     * @param value the value of 'neighborhood'
     * @returns {@link AddressesItem }
     */
    AddressesItem.prototype.withNeighborhood = function(value) {
        this['neighborhood'] = value;
        return this;
    };
    /**
     * @param value the value of 'city'
     * @returns {@link AddressesItem }
     */
    AddressesItem.prototype.withCity = function(value) {
        this['city'] = value;
        return this;
    };
    /**
     * @param value the value of 'region'
     * @returns {@link AddressesItem }
     */
    AddressesItem.prototype.withRegion = function(value) {
        this['region'] = value;
        return this;
    };
    /**
     * @param value the value of 'postalCode'
     * @returns {@link AddressesItem }
     */
    AddressesItem.prototype.withPostalCode = function(value) {
        this['postalCode'] = value;
        return this;
    };
    /**
     * @param value the value of 'country'
     * @returns {@link AddressesItem }
     */
    AddressesItem.prototype.withCountry = function(value) {
        this['country'] = value;
        return this;
    };
    /**
     * The DatesItem class
     * @constructor
     * @alias DatesItem
     */
    function DatesItem() {
        /**
         * The tag value
         * @member
         */
        this.tag = null;
        /**
         * The date value
         * @member
         */
        this.date = null;
    
    }
    
    /**
     * @param value the value of 'tag'
     * @returns {@link DatesItem }
     */
    DatesItem.prototype.withTag = function(value) {
        this['tag'] = value;
        return this;
    };
    /**
     * @param value the value of 'date'
     * @returns {@link DatesItem }
     */
    DatesItem.prototype.withDate = function(value) {
        this['date'] = value;
        return this;
    };
    /**
     * The UrlsItem class
     * @constructor
     * @alias UrlsItem
     */
    function UrlsItem() {
        /**
         * The tag value
         * @member
         */
        this.tag = null;
        /**
         * The url value
         * @member
         */
        this.url = null;
    
    }
    
    /**
     * @param value the value of 'tag'
     * @returns {@link UrlsItem }
     */
    UrlsItem.prototype.withTag = function(value) {
        this['tag'] = value;
        return this;
    };
    /**
     * @param value the value of 'url'
     * @returns {@link UrlsItem }
     */
    UrlsItem.prototype.withUrl = function(value) {
        this['url'] = value;
        return this;
    };
    /**
     * The ContactCreateSchema class
     * @constructor
     * @alias ContactCreateSchema
     */
    function ContactCreateSchema() {
        /**
         * The name of value
         * @member
         * @type { Name }
         */
        this.name = Object.create(Name.prototype);
        /**
         * The picture value
         * @member
         */
        this.picture = null;
        /**
         * The company of value
         * @member
         * @type { Company }
         */
        this.company = Object.create(Company.prototype);
    
    }
    
    /**
     * @param value the value of 'picture'
     * @returns {@link ContactCreateSchema }
     */
    ContactCreateSchema.prototype.withPicture = function(value) {
        this['picture'] = value;
        return this;
    };
    /**
     * @returns {@link EmailsItem }
     */
    ContactCreateSchema.prototype.newEmail = function() {
        return Object.create(EmailsItem.prototype);
    };
    /**
     * @param { EmailsItem } arrayItem the {@link EmailsItem } object to add
     * @returns {@link ContactCreateSchema }
     */
    ContactCreateSchema.prototype.addEmail = function(arrayItem) {
        if (!this.hasOwnProperty('emails')) {
            this['emails'] = [];
        }
        this['emails'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link PhonesItem }
     */
    ContactCreateSchema.prototype.newPhone = function() {
        return Object.create(PhonesItem.prototype);
    };
    /**
     * @param { PhonesItem } arrayItem the {@link PhonesItem } object to add
     * @returns {@link ContactCreateSchema }
     */
    ContactCreateSchema.prototype.addPhone = function(arrayItem) {
        if (!this.hasOwnProperty('phones')) {
            this['phones'] = [];
        }
        this['phones'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link AddressesItem }
     */
    ContactCreateSchema.prototype.newAddress = function() {
        return Object.create(AddressesItem.prototype);
    };
    /**
     * @param { AddressesItem } arrayItem the {@link AddressesItem } object to add
     * @returns {@link ContactCreateSchema }
     */
    ContactCreateSchema.prototype.addAddress = function(arrayItem) {
        if (!this.hasOwnProperty('addresses')) {
            this['addresses'] = [];
        }
        this['addresses'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link DatesItem }
     */
    ContactCreateSchema.prototype.newDate = function() {
        return Object.create(DatesItem.prototype);
    };
    /**
     * @param { DatesItem } arrayItem the {@link DatesItem } object to add
     * @returns {@link ContactCreateSchema }
     */
    ContactCreateSchema.prototype.addDate = function(arrayItem) {
        if (!this.hasOwnProperty('dates')) {
            this['dates'] = [];
        }
        this['dates'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link UrlsItem }
     */
    ContactCreateSchema.prototype.newUrl = function() {
        return Object.create(UrlsItem.prototype);
    };
    /**
     * @param { UrlsItem } arrayItem the {@link UrlsItem } object to add
     * @returns {@link ContactCreateSchema }
     */
    ContactCreateSchema.prototype.addUrl = function(arrayItem) {
        if (!this.hasOwnProperty('urls')) {
            this['urls'] = [];
        }
        this['urls'].push(arrayItem);
        return this;
    };
    
    module.exports = ContactCreateSchema;
    
  provide("openapi-node/lib/schemas/contacts/ContactCreateSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/conversion/ConversionCompleteSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.610Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The MetadataItem class
     * @constructor
     * @alias MetadataItem
     */
    function MetadataItem() {
        /**
         * The property value
         * @member
         */
        this.property = null;
        /**
         * The value value
         * @member
         */
        this.value = null;
    
    }
    
    /**
     * @param value the value of 'property'
     * @returns {@link MetadataItem }
     */
    MetadataItem.prototype.withProperty = function(value) {
        this['property'] = value;
        return this;
    };
    /**
     * @param value the value of 'value'
     * @returns {@link MetadataItem }
     */
    MetadataItem.prototype.withValue = function(value) {
        this['value'] = value;
        return this;
    };
    /**
     * The ConversionCompleteSchema class
     * @constructor
     * @alias ConversionCompleteSchema
     */
    function ConversionCompleteSchema() {
        /**
         * The conversionType value
         * @member
         */
        this.conversionType = null;
        /**
         * The messageId value
         * @member
         */
        this.messageId = null;
    
    }
    
    /**
     * @param value the value of 'conversionType'
     * @returns {@link ConversionCompleteSchema }
     */
    ConversionCompleteSchema.prototype.withConversionType = function(value) {
        var enumProperties = [];
        if (!_.contains(enumProperties, value)) {
            return this;
        }
        this['conversionType'] = value;
        return this;
    };
    /**
     * @param value the value of 'messageId'
     * @returns {@link ConversionCompleteSchema }
     */
    ConversionCompleteSchema.prototype.withMessageId = function(value) {
        this['messageId'] = value;
        return this;
    };
    /**
     * @returns {@link MetadataItem }
     */
    ConversionCompleteSchema.prototype.newMetadata = function() {
        return Object.create(MetadataItem.prototype);
    };
    /**
     * @param { MetadataItem } arrayItem the {@link MetadataItem } object to add
     * @returns {@link ConversionCompleteSchema }
     */
    ConversionCompleteSchema.prototype.addMetadata = function(arrayItem) {
        if (!this.hasOwnProperty('metadata')) {
            this['metadata'] = [];
        }
        this['metadata'].push(arrayItem);
        return this;
    };
    
    module.exports = ConversionCompleteSchema;
    
  provide("openapi-node/lib/schemas/conversion/ConversionCompleteSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/e_commerce/PurchaseSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.632Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Media class
     * @constructor
     * @alias Media
     */
    function Media() {
        /**
         * The thumbnail value
         * @member
         */
        this.thumbnail = null;
    
    }
    
    /**
     * @param value the value of 'thumbnail'
     * @returns {@link Media }
     */
    Media.prototype.withThumbnail = function(value) {
        this['thumbnail'] = value;
        return this;
    };
    /**
     * The VariantsItem class
     * @constructor
     * @alias VariantsItem
     */
    function VariantsItem() {
        /**
         * The title value
         * @member
         */
        this.title = null;
        /**
         * The value value
         * @member
         */
        this.value = null;
    
    }
    
    /**
     * @param value the value of 'title'
     * @returns {@link VariantsItem }
     */
    VariantsItem.prototype.withTitle = function(value) {
        this['title'] = value;
        return this;
    };
    /**
     * @param value the value of 'value'
     * @returns {@link VariantsItem }
     */
    VariantsItem.prototype.withValue = function(value) {
        this['value'] = value;
        return this;
    };
    /**
     * The ItemsItem class
     * @constructor
     * @alias ItemsItem
     */
    function ItemsItem() {
        /**
         * The id value
         * @member
         */
        this.id = null;
        /**
         * The sku value
         * @member
         */
        this.sku = null;
        /**
         * The title value
         * @member
         */
        this.title = null;
        /**
         * The quantity value
         * @member
         */
        this.quantity = null;
        /**
         * The price value
         * @member
         */
        this.price = null;
        /**
         * The formattedPrice value
         * @member
         */
        this.formattedPrice = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
        /**
         * The productLink value
         * @member
         */
        this.productLink = null;
        /**
         * The weight value
         * @member
         */
        this.weight = null;
        /**
         * The formattedWeight value
         * @member
         */
        this.formattedWeight = null;
        /**
         * The media of value
         * @member
         * @type { Media }
         */
        this.media = Object.create(Media.prototype);
    
    }
    
    /**
     * @param value the value of 'id'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * @param value the value of 'sku'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withSku = function(value) {
        this['sku'] = value;
        return this;
    };
    /**
     * @param value the value of 'title'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withTitle = function(value) {
        this['title'] = value;
        return this;
    };
    /**
     * @param value the value of 'quantity'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withQuantity = function(value) {
        this['quantity'] = value;
        return this;
    };
    /**
     * @param value the value of 'price'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withPrice = function(value) {
        this['price'] = value;
        return this;
    };
    /**
     * @param value the value of 'formattedPrice'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withFormattedPrice = function(value) {
        this['formattedPrice'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * @param value the value of 'productLink'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withProductLink = function(value) {
        this['productLink'] = value;
        return this;
    };
    /**
     * @param value the value of 'weight'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withWeight = function(value) {
        this['weight'] = value;
        return this;
    };
    /**
     * @param value the value of 'formattedWeight'
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.withFormattedWeight = function(value) {
        this['formattedWeight'] = value;
        return this;
    };
    /**
     * @returns {@link VariantsItem }
     */
    ItemsItem.prototype.newVariant = function() {
        return Object.create(VariantsItem.prototype);
    };
    /**
     * @param { VariantsItem } arrayItem the {@link VariantsItem } object to add
     * @returns {@link ItemsItem }
     */
    ItemsItem.prototype.addVariant = function(arrayItem) {
        if (!this.hasOwnProperty('variants')) {
            this['variants'] = [];
        }
        this['variants'].push(arrayItem);
        return this;
    };
    /**
     * The Coupon class
     * @constructor
     * @alias Coupon
     */
    function Coupon() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The formattedTotal value
         * @member
         */
        this.formattedTotal = null;
        /**
         * The title value
         * @member
         */
        this.title = null;
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Coupon }
     */
    Coupon.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'formattedTotal'
     * @returns {@link Coupon }
     */
    Coupon.prototype.withFormattedTotal = function(value) {
        this['formattedTotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'title'
     * @returns {@link Coupon }
     */
    Coupon.prototype.withTitle = function(value) {
        this['title'] = value;
        return this;
    };
    /**
     * The Tax class
     * @constructor
     * @alias Tax
     */
    function Tax() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The formattedTotal value
         * @member
         */
        this.formattedTotal = null;
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Tax }
     */
    Tax.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'formattedTotal'
     * @returns {@link Tax }
     */
    Tax.prototype.withFormattedTotal = function(value) {
        this['formattedTotal'] = value;
        return this;
    };
    /**
     * The Shipping class
     * @constructor
     * @alias Shipping
     */
    function Shipping() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The formattedTotal value
         * @member
         */
        this.formattedTotal = null;
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Shipping }
     */
    Shipping.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'formattedTotal'
     * @returns {@link Shipping }
     */
    Shipping.prototype.withFormattedTotal = function(value) {
        this['formattedTotal'] = value;
        return this;
    };
    /**
     * The Payment class
     * @constructor
     * @alias Payment
     */
    function Payment() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The formattedTotal value
         * @member
         */
        this.formattedTotal = null;
        /**
         * The formattedSubtotal value
         * @member
         */
        this.formattedSubtotal = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
        /**
         * The coupon of value
         * @member
         * @type { Coupon }
         */
        this.coupon = Object.create(Coupon.prototype);
        /**
         * The tax of value
         * @member
         * @type { Tax }
         */
        this.tax = Object.create(Tax.prototype);
        /**
         * The shipping of value
         * @member
         * @type { Shipping }
         */
        this.shipping = Object.create(Shipping.prototype);
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Payment }
     */
    Payment.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'subtotal'
     * @returns {@link Payment }
     */
    Payment.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'formattedTotal'
     * @returns {@link Payment }
     */
    Payment.prototype.withFormattedTotal = function(value) {
        this['formattedTotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'formattedSubtotal'
     * @returns {@link Payment }
     */
    Payment.prototype.withFormattedSubtotal = function(value) {
        this['formattedSubtotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link Payment }
     */
    Payment.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The ShippingAddress class
     * @constructor
     * @alias ShippingAddress
     */
    function ShippingAddress() {
        /**
         * The firstName value
         * @member
         */
        this.firstName = null;
        /**
         * The lastName value
         * @member
         */
        this.lastName = null;
        /**
         * The email value
         * @member
         */
        this.email = null;
        /**
         * The phone value
         * @member
         */
        this.phone = null;
        /**
         * The country value
         * @member
         */
        this.country = null;
        /**
         * The countryCode value
         * @member
         */
        this.countryCode = null;
        /**
         * The region value
         * @member
         */
        this.region = null;
        /**
         * The regionCode value
         * @member
         */
        this.regionCode = null;
        /**
         * The city value
         * @member
         */
        this.city = null;
        /**
         * The address1 value
         * @member
         */
        this.address1 = null;
        /**
         * The address2 value
         * @member
         */
        this.address2 = null;
        /**
         * The zip value
         * @member
         */
        this.zip = null;
        /**
         * The company value
         * @member
         */
        this.company = null;
    
    }
    
    /**
     * @param value the value of 'firstName'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withFirstName = function(value) {
        this['firstName'] = value;
        return this;
    };
    /**
     * @param value the value of 'lastName'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withLastName = function(value) {
        this['lastName'] = value;
        return this;
    };
    /**
     * @param value the value of 'email'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withEmail = function(value) {
        this['email'] = value;
        return this;
    };
    /**
     * @param value the value of 'phone'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withPhone = function(value) {
        this['phone'] = value;
        return this;
    };
    /**
     * @param value the value of 'country'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withCountry = function(value) {
        this['country'] = value;
        return this;
    };
    /**
     * @param value the value of 'countryCode'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withCountryCode = function(value) {
        this['countryCode'] = value;
        return this;
    };
    /**
     * @param value the value of 'region'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withRegion = function(value) {
        this['region'] = value;
        return this;
    };
    /**
     * @param value the value of 'regionCode'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withRegionCode = function(value) {
        this['regionCode'] = value;
        return this;
    };
    /**
     * @param value the value of 'city'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withCity = function(value) {
        this['city'] = value;
        return this;
    };
    /**
     * @param value the value of 'address1'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withAddress1 = function(value) {
        this['address1'] = value;
        return this;
    };
    /**
     * @param value the value of 'address2'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withAddress2 = function(value) {
        this['address2'] = value;
        return this;
    };
    /**
     * @param value the value of 'zip'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withZip = function(value) {
        this['zip'] = value;
        return this;
    };
    /**
     * @param value the value of 'company'
     * @returns {@link ShippingAddress }
     */
    ShippingAddress.prototype.withCompany = function(value) {
        this['company'] = value;
        return this;
    };
    /**
     * The BillingAddress class
     * @constructor
     * @alias BillingAddress
     */
    function BillingAddress() {
        /**
         * The firstName value
         * @member
         */
        this.firstName = null;
        /**
         * The lastName value
         * @member
         */
        this.lastName = null;
        /**
         * The email value
         * @member
         */
        this.email = null;
        /**
         * The phone value
         * @member
         */
        this.phone = null;
        /**
         * The country value
         * @member
         */
        this.country = null;
        /**
         * The countryCode value
         * @member
         */
        this.countryCode = null;
        /**
         * The region value
         * @member
         */
        this.region = null;
        /**
         * The regionCode value
         * @member
         */
        this.regionCode = null;
        /**
         * The city value
         * @member
         */
        this.city = null;
        /**
         * The address1 value
         * @member
         */
        this.address1 = null;
        /**
         * The address2 value
         * @member
         */
        this.address2 = null;
        /**
         * The zip value
         * @member
         */
        this.zip = null;
        /**
         * The company value
         * @member
         */
        this.company = null;
    
    }
    
    /**
     * @param value the value of 'firstName'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withFirstName = function(value) {
        this['firstName'] = value;
        return this;
    };
    /**
     * @param value the value of 'lastName'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withLastName = function(value) {
        this['lastName'] = value;
        return this;
    };
    /**
     * @param value the value of 'email'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withEmail = function(value) {
        this['email'] = value;
        return this;
    };
    /**
     * @param value the value of 'phone'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withPhone = function(value) {
        this['phone'] = value;
        return this;
    };
    /**
     * @param value the value of 'country'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withCountry = function(value) {
        this['country'] = value;
        return this;
    };
    /**
     * @param value the value of 'countryCode'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withCountryCode = function(value) {
        this['countryCode'] = value;
        return this;
    };
    /**
     * @param value the value of 'region'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withRegion = function(value) {
        this['region'] = value;
        return this;
    };
    /**
     * @param value the value of 'regionCode'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withRegionCode = function(value) {
        this['regionCode'] = value;
        return this;
    };
    /**
     * @param value the value of 'city'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withCity = function(value) {
        this['city'] = value;
        return this;
    };
    /**
     * @param value the value of 'address1'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withAddress1 = function(value) {
        this['address1'] = value;
        return this;
    };
    /**
     * @param value the value of 'address2'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withAddress2 = function(value) {
        this['address2'] = value;
        return this;
    };
    /**
     * @param value the value of 'zip'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withZip = function(value) {
        this['zip'] = value;
        return this;
    };
    /**
     * @param value the value of 'company'
     * @returns {@link BillingAddress }
     */
    BillingAddress.prototype.withCompany = function(value) {
        this['company'] = value;
        return this;
    };
    /**
     * The PurchaseSchema class
     * @constructor
     * @alias PurchaseSchema
     */
    function PurchaseSchema() {
        /**
         * The cartId value
         * @member
         */
        this.cartId = null;
        /**
         * The storeId value
         * @member
         */
        this.storeId = null;
        /**
         * The orderId value
         * @member
         */
        this.orderId = null;
        /**
         * The payment of value
         * @member
         * @type { Payment }
         */
        this.payment = Object.create(Payment.prototype);
        /**
         * The shippingAddress of value
         * @member
         * @type { ShippingAddress }
         */
        this.shippingAddress = Object.create(ShippingAddress.prototype);
        /**
         * The billingAddress of value
         * @member
         * @type { BillingAddress }
         */
        this.billingAddress = Object.create(BillingAddress.prototype);
        /**
         * The paymentGateway value
         * @member
         */
        this.paymentGateway = null;
        /**
         * The note value
         * @member
         */
        this.note = null;
        /**
         * The buyerAcceptsMarketing value
         * @member
         */
        this.buyerAcceptsMarketing = null;
    
    }
    
    /**
     * @param value the value of 'cartId'
     * @returns {@link PurchaseSchema }
     */
    PurchaseSchema.prototype.withCartId = function(value) {
        this['cartId'] = value;
        return this;
    };
    /**
     * @param value the value of 'storeId'
     * @returns {@link PurchaseSchema }
     */
    PurchaseSchema.prototype.withStoreId = function(value) {
        this['storeId'] = value;
        return this;
    };
    /**
     * @param value the value of 'orderId'
     * @returns {@link PurchaseSchema }
     */
    PurchaseSchema.prototype.withOrderId = function(value) {
        this['orderId'] = value;
        return this;
    };
    /**
     * @returns {@link ItemsItem }
     */
    PurchaseSchema.prototype.newItem = function() {
        return Object.create(ItemsItem.prototype);
    };
    /**
     * @param { ItemsItem } arrayItem the {@link ItemsItem } object to add
     * @returns {@link PurchaseSchema }
     */
    PurchaseSchema.prototype.addItem = function(arrayItem) {
        if (!this.hasOwnProperty('items')) {
            this['items'] = [];
        }
        this['items'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'paymentGateway'
     * @returns {@link PurchaseSchema }
     */
    PurchaseSchema.prototype.withPaymentGateway = function(value) {
        this['paymentGateway'] = value;
        return this;
    };
    /**
     * @param value the value of 'note'
     * @returns {@link PurchaseSchema }
     */
    PurchaseSchema.prototype.withNote = function(value) {
        this['note'] = value;
        return this;
    };
    /**
     * @param value the value of 'buyerAcceptsMarketing'
     * @returns {@link PurchaseSchema }
     */
    PurchaseSchema.prototype.withBuyerAcceptsMarketing = function(value) {
        this['buyerAcceptsMarketing'] = value;
        return this;
    };
    
    module.exports = PurchaseSchema;
    
  provide("openapi-node/lib/schemas/e_commerce/PurchaseSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/hotels/HotelPurchaseSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T11:45:41.275Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Guests class
     * @constructor
     * @alias Guests
     */
    function Guests() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The adults value
         * @member
         */
        this.adults = null;
        /**
         * The children value
         * @member
         */
        this.children = null;
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Guests }
     */
    Guests.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'adults'
     * @returns {@link Guests }
     */
    Guests.prototype.withAdults = function(value) {
        this['adults'] = value;
        return this;
    };
    /**
     * @param value the value of 'children'
     * @returns {@link Guests }
     */
    Guests.prototype.withChildren = function(value) {
        this['children'] = value;
        return this;
    };
    /**
     * The Stay class
     * @constructor
     * @alias Stay
     */
    function Stay() {
        /**
         * The checkin value
         * @member
         */
        this.checkin = null;
        /**
         * The checkout value
         * @member
         */
        this.checkout = null;
    
    }
    
    /**
     * @param value the value of 'checkin'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckin = function(value) {
        this['checkin'] = value;
        return this;
    };
    /**
     * @param value the value of 'checkout'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckout = function(value) {
        this['checkout'] = value;
        return this;
    };
    /**
     * The TaxesItem class
     * @constructor
     * @alias TaxesItem
     */
    function TaxesItem() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The RatesItem class
     * @constructor
     * @alias RatesItem
     */
    function RatesItem() {
        /**
         * The date value
         * @member
         */
        this.date = null;
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'date'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withDate = function(value) {
        this['date'] = value;
        return this;
    };
    /**
     * @param value the value of 'subtotal'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @returns {@link TaxesItem }
     */
    RatesItem.prototype.newTaxe = function() {
        return Object.create(TaxesItem.prototype);
    };
    /**
     * @param { TaxesItem } arrayItem the {@link TaxesItem } object to add
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.addTaxe = function(arrayItem) {
        if (!this.hasOwnProperty('taxes')) {
            this['taxes'] = [];
        }
        this['taxes'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The Payment class
     * @constructor
     * @alias Payment
     */
    function Payment() {
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
        /**
         * The source value
         * @member
         */
        this.source = null;
    
    }
    
    /**
     * @param value the value of 'subtotal'
     * @returns {@link Payment }
     */
    Payment.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link Payment }
     */
    Payment.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link Payment }
     */
    Payment.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * @param value the value of 'source'
     * @returns {@link Payment }
     */
    Payment.prototype.withSource = function(value) {
        this['source'] = value;
        return this;
    };
    /**
     * The Name class
     * @constructor
     * @alias Name
     */
    function Name() {
        /**
         * The prefix value
         * @member
         */
        this.prefix = null;
        /**
         * The first value
         * @member
         */
        this.first = null;
        /**
         * The middle value
         * @member
         */
        this.middle = null;
        /**
         * The last value
         * @member
         */
        this.last = null;
        /**
         * The suffix value
         * @member
         */
        this.suffix = null;
    
    }
    
    /**
     * @param value the value of 'prefix'
     * @returns {@link Name }
     */
    Name.prototype.withPrefix = function(value) {
        this['prefix'] = value;
        return this;
    };
    /**
     * @param value the value of 'first'
     * @returns {@link Name }
     */
    Name.prototype.withFirst = function(value) {
        this['first'] = value;
        return this;
    };
    /**
     * @param value the value of 'middle'
     * @returns {@link Name }
     */
    Name.prototype.withMiddle = function(value) {
        this['middle'] = value;
        return this;
    };
    /**
     * @param value the value of 'last'
     * @returns {@link Name }
     */
    Name.prototype.withLast = function(value) {
        this['last'] = value;
        return this;
    };
    /**
     * @param value the value of 'suffix'
     * @returns {@link Name }
     */
    Name.prototype.withSuffix = function(value) {
        this['suffix'] = value;
        return this;
    };
    /**
     * The Customer class
     * @constructor
     * @alias Customer
     */
    function Customer() {
        /**
         * The contactId value
         * @member
         */
        this.contactId = null;
        /**
         * The isGuest value
         * @member
         */
        this.isGuest = null;
        /**
         * The name of value
         * @member
         * @type { Name }
         */
        this.name = Object.create(Name.prototype);
        /**
         * The phone value
         * @member
         */
        this.phone = null;
        /**
         * The email value
         * @member
         */
        this.email = null;
    
    }
    
    /**
     * @param value the value of 'contactId'
     * @returns {@link Customer }
     */
    Customer.prototype.withContactId = function(value) {
        this['contactId'] = value;
        return this;
    };
    /**
     * @param value the value of 'isGuest'
     * @returns {@link Customer }
     */
    Customer.prototype.withIsGuest = function(value) {
        this['isGuest'] = value;
        return this;
    };
    /**
     * @param value the value of 'phone'
     * @returns {@link Customer }
     */
    Customer.prototype.withPhone = function(value) {
        this['phone'] = value;
        return this;
    };
    /**
     * @param value the value of 'email'
     * @returns {@link Customer }
     */
    Customer.prototype.withEmail = function(value) {
        this['email'] = value;
        return this;
    };
    /**
     * The BedsItem class
     * @constructor
     * @alias BedsItem
     */
    function BedsItem() {
        /**
         * The kind value
         * @member
         */
        this.kind = null;
        /**
         * The sleeps value
         * @member
         */
        this.sleeps = null;
    
    }
    
    /**
     * @param value the value of 'kind'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withKind = function(value) {
        this['kind'] = value;
        return this;
    };
    /**
     * @param value the value of 'sleeps'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withSleeps = function(value) {
        this['sleeps'] = value;
        return this;
    };
    /**
     * The RoomsItem class
     * @constructor
     * @alias RoomsItem
     */
    function RoomsItem() {
        /**
         * The id value
         * @member
         */
        this.id = null;
        /**
         * The maxOccupancy value
         * @member
         */
        this.maxOccupancy = null;
    
    }
    
    /**
     * @param value the value of 'id'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * @returns {@link BedsItem }
     */
    RoomsItem.prototype.newBed = function() {
        return Object.create(BedsItem.prototype);
    };
    /**
     * @param { BedsItem } arrayItem the {@link BedsItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addBed = function(arrayItem) {
        if (!this.hasOwnProperty('beds')) {
            this['beds'] = [];
        }
        this['beds'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'maxOccupancy'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withMaxOccupancy = function(value) {
        this['maxOccupancy'] = value;
        return this;
    };
    /**
     * @returns {@link AmenitiesItem }
     */
    RoomsItem.prototype.newAmenitie = function() {
        return Object.create(AmenitiesItem.prototype);
    };
    /**
     * @param { AmenitiesItem } arrayItem the {@link AmenitiesItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addAmenitie = function(arrayItem) {
        if (!this.hasOwnProperty('amenities')) {
            this['amenities'] = [];
        }
        this['amenities'].push(arrayItem);
        return this;
    };
    /**
     * The HotelPurchaseSchema class
     * @constructor
     * @alias HotelPurchaseSchema
     */
    function HotelPurchaseSchema() {
        /**
         * The reservationId value
         * @member
         */
        this.reservationId = null;
        /**
         * The guests of value
         * @member
         * @type { Guests }
         */
        this.guests = Object.create(Guests.prototype);
        /**
         * The stay of value
         * @member
         * @type { Stay }
         */
        this.stay = Object.create(Stay.prototype);
        /**
         * The payment of value
         * @member
         * @type { Payment }
         */
        this.payment = Object.create(Payment.prototype);
        /**
         * The customer of value
         * @member
         * @type { Customer }
         */
        this.customer = Object.create(Customer.prototype);
    
    }
    
    /**
     * @param value the value of 'reservationId'
     * @returns {@link HotelPurchaseSchema }
     */
    HotelPurchaseSchema.prototype.withReservationId = function(value) {
        this['reservationId'] = value;
        return this;
    };
    /**
     * @returns {@link RatesItem }
     */
    HotelPurchaseSchema.prototype.newRate = function() {
        return Object.create(RatesItem.prototype);
    };
    /**
     * @param { RatesItem } arrayItem the {@link RatesItem } object to add
     * @returns {@link HotelPurchaseSchema }
     */
    HotelPurchaseSchema.prototype.addRate = function(arrayItem) {
        if (!this.hasOwnProperty('rates')) {
            this['rates'] = [];
        }
        this['rates'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link RoomsItem }
     */
    HotelPurchaseSchema.prototype.newRoom = function() {
        return Object.create(RoomsItem.prototype);
    };
    /**
     * @param { RoomsItem } arrayItem the {@link RoomsItem } object to add
     * @returns {@link HotelPurchaseSchema }
     */
    HotelPurchaseSchema.prototype.addRoom = function(arrayItem) {
        if (!this.hasOwnProperty('rooms')) {
            this['rooms'] = [];
        }
        this['rooms'].push(arrayItem);
        return this;
    };
    
    module.exports = HotelPurchaseSchema;
    
  provide("openapi-node/lib/schemas/hotels/HotelPurchaseSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/hotels/HotelPurchaseFailedSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T11:45:41.293Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Guests class
     * @constructor
     * @alias Guests
     */
    function Guests() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The adults value
         * @member
         */
        this.adults = null;
        /**
         * The children value
         * @member
         */
        this.children = null;
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Guests }
     */
    Guests.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'adults'
     * @returns {@link Guests }
     */
    Guests.prototype.withAdults = function(value) {
        this['adults'] = value;
        return this;
    };
    /**
     * @param value the value of 'children'
     * @returns {@link Guests }
     */
    Guests.prototype.withChildren = function(value) {
        this['children'] = value;
        return this;
    };
    /**
     * The Stay class
     * @constructor
     * @alias Stay
     */
    function Stay() {
        /**
         * The checkin value
         * @member
         */
        this.checkin = null;
        /**
         * The checkout value
         * @member
         */
        this.checkout = null;
    
    }
    
    /**
     * @param value the value of 'checkin'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckin = function(value) {
        this['checkin'] = value;
        return this;
    };
    /**
     * @param value the value of 'checkout'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckout = function(value) {
        this['checkout'] = value;
        return this;
    };
    /**
     * The TaxesItem class
     * @constructor
     * @alias TaxesItem
     */
    function TaxesItem() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The RatesItem class
     * @constructor
     * @alias RatesItem
     */
    function RatesItem() {
        /**
         * The date value
         * @member
         */
        this.date = null;
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'date'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withDate = function(value) {
        this['date'] = value;
        return this;
    };
    /**
     * @param value the value of 'subtotal'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @returns {@link TaxesItem }
     */
    RatesItem.prototype.newTaxe = function() {
        return Object.create(TaxesItem.prototype);
    };
    /**
     * @param { TaxesItem } arrayItem the {@link TaxesItem } object to add
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.addTaxe = function(arrayItem) {
        if (!this.hasOwnProperty('taxes')) {
            this['taxes'] = [];
        }
        this['taxes'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The Error class
     * @constructor
     * @alias Error
     */
    function Error() {
        /**
         * The errorCode value
         * @member
         */
        this.errorCode = null;
        /**
         * The reason value
         * @member
         */
        this.reason = null;
    
    }
    
    /**
     * @param value the value of 'errorCode'
     * @returns {@link Error }
     */
    Error.prototype.withErrorCode = function(value) {
        this['errorCode'] = value;
        return this;
    };
    /**
     * @param value the value of 'reason'
     * @returns {@link Error }
     */
    Error.prototype.withReason = function(value) {
        this['reason'] = value;
        return this;
    };
    /**
     * The Payment class
     * @constructor
     * @alias Payment
     */
    function Payment() {
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
        /**
         * The source value
         * @member
         */
        this.source = null;
        /**
         * The error of value
         * @member
         * @type { Error }
         */
        this.error = Object.create(Error.prototype);
    
    }
    
    /**
     * @param value the value of 'subtotal'
     * @returns {@link Payment }
     */
    Payment.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link Payment }
     */
    Payment.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link Payment }
     */
    Payment.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * @param value the value of 'source'
     * @returns {@link Payment }
     */
    Payment.prototype.withSource = function(value) {
        this['source'] = value;
        return this;
    };
    /**
     * The Name class
     * @constructor
     * @alias Name
     */
    function Name() {
        /**
         * The prefix value
         * @member
         */
        this.prefix = null;
        /**
         * The first value
         * @member
         */
        this.first = null;
        /**
         * The middle value
         * @member
         */
        this.middle = null;
        /**
         * The last value
         * @member
         */
        this.last = null;
        /**
         * The suffix value
         * @member
         */
        this.suffix = null;
    
    }
    
    /**
     * @param value the value of 'prefix'
     * @returns {@link Name }
     */
    Name.prototype.withPrefix = function(value) {
        this['prefix'] = value;
        return this;
    };
    /**
     * @param value the value of 'first'
     * @returns {@link Name }
     */
    Name.prototype.withFirst = function(value) {
        this['first'] = value;
        return this;
    };
    /**
     * @param value the value of 'middle'
     * @returns {@link Name }
     */
    Name.prototype.withMiddle = function(value) {
        this['middle'] = value;
        return this;
    };
    /**
     * @param value the value of 'last'
     * @returns {@link Name }
     */
    Name.prototype.withLast = function(value) {
        this['last'] = value;
        return this;
    };
    /**
     * @param value the value of 'suffix'
     * @returns {@link Name }
     */
    Name.prototype.withSuffix = function(value) {
        this['suffix'] = value;
        return this;
    };
    /**
     * The Customer class
     * @constructor
     * @alias Customer
     */
    function Customer() {
        /**
         * The contactId value
         * @member
         */
        this.contactId = null;
        /**
         * The isGuest value
         * @member
         */
        this.isGuest = null;
        /**
         * The name of value
         * @member
         * @type { Name }
         */
        this.name = Object.create(Name.prototype);
        /**
         * The phone value
         * @member
         */
        this.phone = null;
        /**
         * The email value
         * @member
         */
        this.email = null;
    
    }
    
    /**
     * @param value the value of 'contactId'
     * @returns {@link Customer }
     */
    Customer.prototype.withContactId = function(value) {
        this['contactId'] = value;
        return this;
    };
    /**
     * @param value the value of 'isGuest'
     * @returns {@link Customer }
     */
    Customer.prototype.withIsGuest = function(value) {
        this['isGuest'] = value;
        return this;
    };
    /**
     * @param value the value of 'phone'
     * @returns {@link Customer }
     */
    Customer.prototype.withPhone = function(value) {
        this['phone'] = value;
        return this;
    };
    /**
     * @param value the value of 'email'
     * @returns {@link Customer }
     */
    Customer.prototype.withEmail = function(value) {
        this['email'] = value;
        return this;
    };
    /**
     * The BedsItem class
     * @constructor
     * @alias BedsItem
     */
    function BedsItem() {
        /**
         * The kind value
         * @member
         */
        this.kind = null;
        /**
         * The sleeps value
         * @member
         */
        this.sleeps = null;
    
    }
    
    /**
     * @param value the value of 'kind'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withKind = function(value) {
        this['kind'] = value;
        return this;
    };
    /**
     * @param value the value of 'sleeps'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withSleeps = function(value) {
        this['sleeps'] = value;
        return this;
    };
    /**
     * The RoomsItem class
     * @constructor
     * @alias RoomsItem
     */
    function RoomsItem() {
        /**
         * The id value
         * @member
         */
        this.id = null;
        /**
         * The maxOccupancy value
         * @member
         */
        this.maxOccupancy = null;
    
    }
    
    /**
     * @param value the value of 'id'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * @returns {@link BedsItem }
     */
    RoomsItem.prototype.newBed = function() {
        return Object.create(BedsItem.prototype);
    };
    /**
     * @param { BedsItem } arrayItem the {@link BedsItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addBed = function(arrayItem) {
        if (!this.hasOwnProperty('beds')) {
            this['beds'] = [];
        }
        this['beds'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'maxOccupancy'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withMaxOccupancy = function(value) {
        this['maxOccupancy'] = value;
        return this;
    };
    /**
     * @returns {@link AmenitiesItem }
     */
    RoomsItem.prototype.newAmenitie = function() {
        return Object.create(AmenitiesItem.prototype);
    };
    /**
     * @param { AmenitiesItem } arrayItem the {@link AmenitiesItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addAmenitie = function(arrayItem) {
        if (!this.hasOwnProperty('amenities')) {
            this['amenities'] = [];
        }
        this['amenities'].push(arrayItem);
        return this;
    };
    /**
     * The HotelPurchaseFailedSchema class
     * @constructor
     * @alias HotelPurchaseFailedSchema
     */
    function HotelPurchaseFailedSchema() {
        /**
         * The reservationId value
         * @member
         */
        this.reservationId = null;
        /**
         * The guests of value
         * @member
         * @type { Guests }
         */
        this.guests = Object.create(Guests.prototype);
        /**
         * The stay of value
         * @member
         * @type { Stay }
         */
        this.stay = Object.create(Stay.prototype);
        /**
         * The payment of value
         * @member
         * @type { Payment }
         */
        this.payment = Object.create(Payment.prototype);
        /**
         * The customer of value
         * @member
         * @type { Customer }
         */
        this.customer = Object.create(Customer.prototype);
    
    }
    
    /**
     * @param value the value of 'reservationId'
     * @returns {@link HotelPurchaseFailedSchema }
     */
    HotelPurchaseFailedSchema.prototype.withReservationId = function(value) {
        this['reservationId'] = value;
        return this;
    };
    /**
     * @returns {@link RatesItem }
     */
    HotelPurchaseFailedSchema.prototype.newRate = function() {
        return Object.create(RatesItem.prototype);
    };
    /**
     * @param { RatesItem } arrayItem the {@link RatesItem } object to add
     * @returns {@link HotelPurchaseFailedSchema }
     */
    HotelPurchaseFailedSchema.prototype.addRate = function(arrayItem) {
        if (!this.hasOwnProperty('rates')) {
            this['rates'] = [];
        }
        this['rates'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link RoomsItem }
     */
    HotelPurchaseFailedSchema.prototype.newRoom = function() {
        return Object.create(RoomsItem.prototype);
    };
    /**
     * @param { RoomsItem } arrayItem the {@link RoomsItem } object to add
     * @returns {@link HotelPurchaseFailedSchema }
     */
    HotelPurchaseFailedSchema.prototype.addRoom = function(arrayItem) {
        if (!this.hasOwnProperty('rooms')) {
            this['rooms'] = [];
        }
        this['rooms'].push(arrayItem);
        return this;
    };
    
    module.exports = HotelPurchaseFailedSchema;
    
  provide("openapi-node/lib/schemas/hotels/HotelPurchaseFailedSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/hotels/HotelCancelSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T11:45:41.310Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Guests class
     * @constructor
     * @alias Guests
     */
    function Guests() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The adults value
         * @member
         */
        this.adults = null;
        /**
         * The children value
         * @member
         */
        this.children = null;
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Guests }
     */
    Guests.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'adults'
     * @returns {@link Guests }
     */
    Guests.prototype.withAdults = function(value) {
        this['adults'] = value;
        return this;
    };
    /**
     * @param value the value of 'children'
     * @returns {@link Guests }
     */
    Guests.prototype.withChildren = function(value) {
        this['children'] = value;
        return this;
    };
    /**
     * The Stay class
     * @constructor
     * @alias Stay
     */
    function Stay() {
        /**
         * The checkin value
         * @member
         */
        this.checkin = null;
        /**
         * The checkout value
         * @member
         */
        this.checkout = null;
    
    }
    
    /**
     * @param value the value of 'checkin'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckin = function(value) {
        this['checkin'] = value;
        return this;
    };
    /**
     * @param value the value of 'checkout'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckout = function(value) {
        this['checkout'] = value;
        return this;
    };
    /**
     * The TaxesItem class
     * @constructor
     * @alias TaxesItem
     */
    function TaxesItem() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The RatesItem class
     * @constructor
     * @alias RatesItem
     */
    function RatesItem() {
        /**
         * The date value
         * @member
         */
        this.date = null;
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'date'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withDate = function(value) {
        this['date'] = value;
        return this;
    };
    /**
     * @param value the value of 'subtotal'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @returns {@link TaxesItem }
     */
    RatesItem.prototype.newTaxe = function() {
        return Object.create(TaxesItem.prototype);
    };
    /**
     * @param { TaxesItem } arrayItem the {@link TaxesItem } object to add
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.addTaxe = function(arrayItem) {
        if (!this.hasOwnProperty('taxes')) {
            this['taxes'] = [];
        }
        this['taxes'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The Error class
     * @constructor
     * @alias Error
     */
    function Error() {
        /**
         * The errorCode value
         * @member
         */
        this.errorCode = null;
        /**
         * The reason value
         * @member
         */
        this.reason = null;
    
    }
    
    /**
     * @param value the value of 'errorCode'
     * @returns {@link Error }
     */
    Error.prototype.withErrorCode = function(value) {
        this['errorCode'] = value;
        return this;
    };
    /**
     * @param value the value of 'reason'
     * @returns {@link Error }
     */
    Error.prototype.withReason = function(value) {
        this['reason'] = value;
        return this;
    };
    /**
     * The Payment class
     * @constructor
     * @alias Payment
     */
    function Payment() {
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
        /**
         * The source value
         * @member
         */
        this.source = null;
        /**
         * The error of value
         * @member
         * @type { Error }
         */
        this.error = Object.create(Error.prototype);
    
    }
    
    /**
     * @param value the value of 'subtotal'
     * @returns {@link Payment }
     */
    Payment.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link Payment }
     */
    Payment.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link Payment }
     */
    Payment.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * @param value the value of 'source'
     * @returns {@link Payment }
     */
    Payment.prototype.withSource = function(value) {
        this['source'] = value;
        return this;
    };
    /**
     * The Name class
     * @constructor
     * @alias Name
     */
    function Name() {
        /**
         * The prefix value
         * @member
         */
        this.prefix = null;
        /**
         * The first value
         * @member
         */
        this.first = null;
        /**
         * The middle value
         * @member
         */
        this.middle = null;
        /**
         * The last value
         * @member
         */
        this.last = null;
        /**
         * The suffix value
         * @member
         */
        this.suffix = null;
    
    }
    
    /**
     * @param value the value of 'prefix'
     * @returns {@link Name }
     */
    Name.prototype.withPrefix = function(value) {
        this['prefix'] = value;
        return this;
    };
    /**
     * @param value the value of 'first'
     * @returns {@link Name }
     */
    Name.prototype.withFirst = function(value) {
        this['first'] = value;
        return this;
    };
    /**
     * @param value the value of 'middle'
     * @returns {@link Name }
     */
    Name.prototype.withMiddle = function(value) {
        this['middle'] = value;
        return this;
    };
    /**
     * @param value the value of 'last'
     * @returns {@link Name }
     */
    Name.prototype.withLast = function(value) {
        this['last'] = value;
        return this;
    };
    /**
     * @param value the value of 'suffix'
     * @returns {@link Name }
     */
    Name.prototype.withSuffix = function(value) {
        this['suffix'] = value;
        return this;
    };
    /**
     * The Customer class
     * @constructor
     * @alias Customer
     */
    function Customer() {
        /**
         * The contactId value
         * @member
         */
        this.contactId = null;
        /**
         * The isGuest value
         * @member
         */
        this.isGuest = null;
        /**
         * The name of value
         * @member
         * @type { Name }
         */
        this.name = Object.create(Name.prototype);
        /**
         * The phone value
         * @member
         */
        this.phone = null;
        /**
         * The email value
         * @member
         */
        this.email = null;
    
    }
    
    /**
     * @param value the value of 'contactId'
     * @returns {@link Customer }
     */
    Customer.prototype.withContactId = function(value) {
        this['contactId'] = value;
        return this;
    };
    /**
     * @param value the value of 'isGuest'
     * @returns {@link Customer }
     */
    Customer.prototype.withIsGuest = function(value) {
        this['isGuest'] = value;
        return this;
    };
    /**
     * @param value the value of 'phone'
     * @returns {@link Customer }
     */
    Customer.prototype.withPhone = function(value) {
        this['phone'] = value;
        return this;
    };
    /**
     * @param value the value of 'email'
     * @returns {@link Customer }
     */
    Customer.prototype.withEmail = function(value) {
        this['email'] = value;
        return this;
    };
    /**
     * The BedsItem class
     * @constructor
     * @alias BedsItem
     */
    function BedsItem() {
        /**
         * The kind value
         * @member
         */
        this.kind = null;
        /**
         * The sleeps value
         * @member
         */
        this.sleeps = null;
    
    }
    
    /**
     * @param value the value of 'kind'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withKind = function(value) {
        this['kind'] = value;
        return this;
    };
    /**
     * @param value the value of 'sleeps'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withSleeps = function(value) {
        this['sleeps'] = value;
        return this;
    };
    /**
     * The RoomsItem class
     * @constructor
     * @alias RoomsItem
     */
    function RoomsItem() {
        /**
         * The id value
         * @member
         */
        this.id = null;
        /**
         * The maxOccupancy value
         * @member
         */
        this.maxOccupancy = null;
    
    }
    
    /**
     * @param value the value of 'id'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * @returns {@link BedsItem }
     */
    RoomsItem.prototype.newBed = function() {
        return Object.create(BedsItem.prototype);
    };
    /**
     * @param { BedsItem } arrayItem the {@link BedsItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addBed = function(arrayItem) {
        if (!this.hasOwnProperty('beds')) {
            this['beds'] = [];
        }
        this['beds'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'maxOccupancy'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withMaxOccupancy = function(value) {
        this['maxOccupancy'] = value;
        return this;
    };
    /**
     * @returns {@link AmenitiesItem }
     */
    RoomsItem.prototype.newAmenitie = function() {
        return Object.create(AmenitiesItem.prototype);
    };
    /**
     * @param { AmenitiesItem } arrayItem the {@link AmenitiesItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addAmenitie = function(arrayItem) {
        if (!this.hasOwnProperty('amenities')) {
            this['amenities'] = [];
        }
        this['amenities'].push(arrayItem);
        return this;
    };
    /**
     * The HotelCancelSchema class
     * @constructor
     * @alias HotelCancelSchema
     */
    function HotelCancelSchema() {
        /**
         * The reservationId value
         * @member
         */
        this.reservationId = null;
        /**
         * The guests of value
         * @member
         * @type { Guests }
         */
        this.guests = Object.create(Guests.prototype);
        /**
         * The stay of value
         * @member
         * @type { Stay }
         */
        this.stay = Object.create(Stay.prototype);
        /**
         * The payment of value
         * @member
         * @type { Payment }
         */
        this.payment = Object.create(Payment.prototype);
        /**
         * The customer of value
         * @member
         * @type { Customer }
         */
        this.customer = Object.create(Customer.prototype);
    
    }
    
    /**
     * @param value the value of 'reservationId'
     * @returns {@link HotelCancelSchema }
     */
    HotelCancelSchema.prototype.withReservationId = function(value) {
        this['reservationId'] = value;
        return this;
    };
    /**
     * @returns {@link RatesItem }
     */
    HotelCancelSchema.prototype.newRate = function() {
        return Object.create(RatesItem.prototype);
    };
    /**
     * @param { RatesItem } arrayItem the {@link RatesItem } object to add
     * @returns {@link HotelCancelSchema }
     */
    HotelCancelSchema.prototype.addRate = function(arrayItem) {
        if (!this.hasOwnProperty('rates')) {
            this['rates'] = [];
        }
        this['rates'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link RoomsItem }
     */
    HotelCancelSchema.prototype.newRoom = function() {
        return Object.create(RoomsItem.prototype);
    };
    /**
     * @param { RoomsItem } arrayItem the {@link RoomsItem } object to add
     * @returns {@link HotelCancelSchema }
     */
    HotelCancelSchema.prototype.addRoom = function(arrayItem) {
        if (!this.hasOwnProperty('rooms')) {
            this['rooms'] = [];
        }
        this['rooms'].push(arrayItem);
        return this;
    };
    
    module.exports = HotelCancelSchema;
    
  provide("openapi-node/lib/schemas/hotels/HotelCancelSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/hotels/HotelConfirmationSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T11:45:41.320Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Guests class
     * @constructor
     * @alias Guests
     */
    function Guests() {
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The adults value
         * @member
         */
        this.adults = null;
        /**
         * The children value
         * @member
         */
        this.children = null;
    
    }
    
    /**
     * @param value the value of 'total'
     * @returns {@link Guests }
     */
    Guests.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'adults'
     * @returns {@link Guests }
     */
    Guests.prototype.withAdults = function(value) {
        this['adults'] = value;
        return this;
    };
    /**
     * @param value the value of 'children'
     * @returns {@link Guests }
     */
    Guests.prototype.withChildren = function(value) {
        this['children'] = value;
        return this;
    };
    /**
     * The Stay class
     * @constructor
     * @alias Stay
     */
    function Stay() {
        /**
         * The checkin value
         * @member
         */
        this.checkin = null;
        /**
         * The checkout value
         * @member
         */
        this.checkout = null;
    
    }
    
    /**
     * @param value the value of 'checkin'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckin = function(value) {
        this['checkin'] = value;
        return this;
    };
    /**
     * @param value the value of 'checkout'
     * @returns {@link Stay }
     */
    Stay.prototype.withCheckout = function(value) {
        this['checkout'] = value;
        return this;
    };
    /**
     * The TaxesItem class
     * @constructor
     * @alias TaxesItem
     */
    function TaxesItem() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link TaxesItem }
     */
    TaxesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The RatesItem class
     * @constructor
     * @alias RatesItem
     */
    function RatesItem() {
        /**
         * The date value
         * @member
         */
        this.date = null;
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'date'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withDate = function(value) {
        this['date'] = value;
        return this;
    };
    /**
     * @param value the value of 'subtotal'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @returns {@link TaxesItem }
     */
    RatesItem.prototype.newTaxe = function() {
        return Object.create(TaxesItem.prototype);
    };
    /**
     * @param { TaxesItem } arrayItem the {@link TaxesItem } object to add
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.addTaxe = function(arrayItem) {
        if (!this.hasOwnProperty('taxes')) {
            this['taxes'] = [];
        }
        this['taxes'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link RatesItem }
     */
    RatesItem.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The Invoice class
     * @constructor
     * @alias Invoice
     */
    function Invoice() {
        /**
         * The subtotal value
         * @member
         */
        this.subtotal = null;
        /**
         * The total value
         * @member
         */
        this.total = null;
        /**
         * The currency value
         * @member
         */
        this.currency = null;
    
    }
    
    /**
     * @param value the value of 'subtotal'
     * @returns {@link Invoice }
     */
    Invoice.prototype.withSubtotal = function(value) {
        this['subtotal'] = value;
        return this;
    };
    /**
     * @param value the value of 'total'
     * @returns {@link Invoice }
     */
    Invoice.prototype.withTotal = function(value) {
        this['total'] = value;
        return this;
    };
    /**
     * @param value the value of 'currency'
     * @returns {@link Invoice }
     */
    Invoice.prototype.withCurrency = function(value) {
        this['currency'] = value;
        return this;
    };
    /**
     * The Name class
     * @constructor
     * @alias Name
     */
    function Name() {
        /**
         * The prefix value
         * @member
         */
        this.prefix = null;
        /**
         * The first value
         * @member
         */
        this.first = null;
        /**
         * The middle value
         * @member
         */
        this.middle = null;
        /**
         * The last value
         * @member
         */
        this.last = null;
        /**
         * The suffix value
         * @member
         */
        this.suffix = null;
    
    }
    
    /**
     * @param value the value of 'prefix'
     * @returns {@link Name }
     */
    Name.prototype.withPrefix = function(value) {
        this['prefix'] = value;
        return this;
    };
    /**
     * @param value the value of 'first'
     * @returns {@link Name }
     */
    Name.prototype.withFirst = function(value) {
        this['first'] = value;
        return this;
    };
    /**
     * @param value the value of 'middle'
     * @returns {@link Name }
     */
    Name.prototype.withMiddle = function(value) {
        this['middle'] = value;
        return this;
    };
    /**
     * @param value the value of 'last'
     * @returns {@link Name }
     */
    Name.prototype.withLast = function(value) {
        this['last'] = value;
        return this;
    };
    /**
     * @param value the value of 'suffix'
     * @returns {@link Name }
     */
    Name.prototype.withSuffix = function(value) {
        this['suffix'] = value;
        return this;
    };
    /**
     * The Customer class
     * @constructor
     * @alias Customer
     */
    function Customer() {
        /**
         * The contactId value
         * @member
         */
        this.contactId = null;
        /**
         * The isGuest value
         * @member
         */
        this.isGuest = null;
        /**
         * The name of value
         * @member
         * @type { Name }
         */
        this.name = Object.create(Name.prototype);
        /**
         * The phone value
         * @member
         */
        this.phone = null;
        /**
         * The email value
         * @member
         */
        this.email = null;
    
    }
    
    /**
     * @param value the value of 'contactId'
     * @returns {@link Customer }
     */
    Customer.prototype.withContactId = function(value) {
        this['contactId'] = value;
        return this;
    };
    /**
     * @param value the value of 'isGuest'
     * @returns {@link Customer }
     */
    Customer.prototype.withIsGuest = function(value) {
        this['isGuest'] = value;
        return this;
    };
    /**
     * @param value the value of 'phone'
     * @returns {@link Customer }
     */
    Customer.prototype.withPhone = function(value) {
        this['phone'] = value;
        return this;
    };
    /**
     * @param value the value of 'email'
     * @returns {@link Customer }
     */
    Customer.prototype.withEmail = function(value) {
        this['email'] = value;
        return this;
    };
    /**
     * The BedsItem class
     * @constructor
     * @alias BedsItem
     */
    function BedsItem() {
        /**
         * The kind value
         * @member
         */
        this.kind = null;
        /**
         * The sleeps value
         * @member
         */
        this.sleeps = null;
    
    }
    
    /**
     * @param value the value of 'kind'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withKind = function(value) {
        this['kind'] = value;
        return this;
    };
    /**
     * @param value the value of 'sleeps'
     * @returns {@link BedsItem }
     */
    BedsItem.prototype.withSleeps = function(value) {
        this['sleeps'] = value;
        return this;
    };
    /**
     * The RoomsItem class
     * @constructor
     * @alias RoomsItem
     */
    function RoomsItem() {
        /**
         * The id value
         * @member
         */
        this.id = null;
        /**
         * The maxOccupancy value
         * @member
         */
        this.maxOccupancy = null;
    
    }
    
    /**
     * @param value the value of 'id'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * @returns {@link BedsItem }
     */
    RoomsItem.prototype.newBed = function() {
        return Object.create(BedsItem.prototype);
    };
    /**
     * @param { BedsItem } arrayItem the {@link BedsItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addBed = function(arrayItem) {
        if (!this.hasOwnProperty('beds')) {
            this['beds'] = [];
        }
        this['beds'].push(arrayItem);
        return this;
    };
    /**
     * @param value the value of 'maxOccupancy'
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.withMaxOccupancy = function(value) {
        this['maxOccupancy'] = value;
        return this;
    };
    /**
     * @returns {@link AmenitiesItem }
     */
    RoomsItem.prototype.newAmenitie = function() {
        return Object.create(AmenitiesItem.prototype);
    };
    /**
     * @param { AmenitiesItem } arrayItem the {@link AmenitiesItem } object to add
     * @returns {@link RoomsItem }
     */
    RoomsItem.prototype.addAmenitie = function(arrayItem) {
        if (!this.hasOwnProperty('amenities')) {
            this['amenities'] = [];
        }
        this['amenities'].push(arrayItem);
        return this;
    };
    /**
     * The HotelConfirmationSchema class
     * @constructor
     * @alias HotelConfirmationSchema
     */
    function HotelConfirmationSchema() {
        /**
         * The source value
         * @member
         */
        this.source = null;
        /**
         * The reservationId value
         * @member
         */
        this.reservationId = null;
        /**
         * The guests of value
         * @member
         * @type { Guests }
         */
        this.guests = Object.create(Guests.prototype);
        /**
         * The stay of value
         * @member
         * @type { Stay }
         */
        this.stay = Object.create(Stay.prototype);
        /**
         * The invoice of value
         * @member
         * @type { Invoice }
         */
        this.invoice = Object.create(Invoice.prototype);
        /**
         * The customer of value
         * @member
         * @type { Customer }
         */
        this.customer = Object.create(Customer.prototype);
    
    }
    
    /**
     * @param value the value of 'source'
     * @returns {@link HotelConfirmationSchema }
     */
    HotelConfirmationSchema.prototype.withSource = function(value) {
        var enumProperties = [];
        if (!_.contains(enumProperties, value)) {
            return this;
        }
        this['source'] = value;
        return this;
    };
    /**
     * @param value the value of 'reservationId'
     * @returns {@link HotelConfirmationSchema }
     */
    HotelConfirmationSchema.prototype.withReservationId = function(value) {
        this['reservationId'] = value;
        return this;
    };
    /**
     * @returns {@link RatesItem }
     */
    HotelConfirmationSchema.prototype.newRate = function() {
        return Object.create(RatesItem.prototype);
    };
    /**
     * @param { RatesItem } arrayItem the {@link RatesItem } object to add
     * @returns {@link HotelConfirmationSchema }
     */
    HotelConfirmationSchema.prototype.addRate = function(arrayItem) {
        if (!this.hasOwnProperty('rates')) {
            this['rates'] = [];
        }
        this['rates'].push(arrayItem);
        return this;
    };
    /**
     * @returns {@link RoomsItem }
     */
    HotelConfirmationSchema.prototype.newRoom = function() {
        return Object.create(RoomsItem.prototype);
    };
    /**
     * @param { RoomsItem } arrayItem the {@link RoomsItem } object to add
     * @returns {@link HotelConfirmationSchema }
     */
    HotelConfirmationSchema.prototype.addRoom = function(arrayItem) {
        if (!this.hasOwnProperty('rooms')) {
            this['rooms'] = [];
        }
        this['rooms'].push(arrayItem);
        return this;
    };
    
    module.exports = HotelConfirmationSchema;
    
  provide("openapi-node/lib/schemas/hotels/HotelConfirmationSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/messaging/SendSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.642Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Name class
     * @constructor
     * @alias Name
     */
    function Name() {
        /**
         * The prefix value
         * @member
         */
        this.prefix = null;
        /**
         * The first value
         * @member
         */
        this.first = null;
        /**
         * The middle value
         * @member
         */
        this.middle = null;
        /**
         * The last value
         * @member
         */
        this.last = null;
        /**
         * The suffix value
         * @member
         */
        this.suffix = null;
    
    }
    
    /**
     * @param value the value of 'prefix'
     * @returns {@link Name }
     */
    Name.prototype.withPrefix = function(value) {
        this['prefix'] = value;
        return this;
    };
    /**
     * @param value the value of 'first'
     * @returns {@link Name }
     */
    Name.prototype.withFirst = function(value) {
        this['first'] = value;
        return this;
    };
    /**
     * @param value the value of 'middle'
     * @returns {@link Name }
     */
    Name.prototype.withMiddle = function(value) {
        this['middle'] = value;
        return this;
    };
    /**
     * @param value the value of 'last'
     * @returns {@link Name }
     */
    Name.prototype.withLast = function(value) {
        this['last'] = value;
        return this;
    };
    /**
     * @param value the value of 'suffix'
     * @returns {@link Name }
     */
    Name.prototype.withSuffix = function(value) {
        this['suffix'] = value;
        return this;
    };
    /**
     * The Destination class
     * @constructor
     * @alias Destination
     */
    function Destination() {
        /**
         * The destination value
         * @member
         */
        this.destination = null;
        /**
         * The name of value
         * @member
         * @type { Name }
         */
        this.name = Object.create(Name.prototype);
    
    }
    
    /**
     * @param value the value of 'destination'
     * @returns {@link Destination }
     */
    Destination.prototype.withDestination = function(value) {
        this['destination'] = value;
        return this;
    };
    /**
     * The Recipient class
     * @constructor
     * @alias Recipient
     */
    function Recipient() {
        /**
         * The method value
         * @member
         */
        this.method = null;
        /**
         * The destination of value
         * @member
         * @type { Destination }
         */
        this.destination = Object.create(Destination.prototype);
        /**
         * The contactId value
         * @member
         */
        this.contactId = null;
    
    }
    
    /**
     * @param value the value of 'method'
     * @returns {@link Recipient }
     */
    Recipient.prototype.withMethod = function(value) {
        var enumProperties = [];
        if (!_.contains(enumProperties, value)) {
            return this;
        }
        this['method'] = value;
        return this;
    };
    /**
     * @param value the value of 'contactId'
     * @returns {@link Recipient }
     */
    Recipient.prototype.withContactId = function(value) {
        this['contactId'] = value;
        return this;
    };
    /**
     * The MetadataItem class
     * @constructor
     * @alias MetadataItem
     */
    function MetadataItem() {
        /**
         * The property value
         * @member
         */
        this.property = null;
        /**
         * The value value
         * @member
         */
        this.value = null;
    
    }
    
    /**
     * @param value the value of 'property'
     * @returns {@link MetadataItem }
     */
    MetadataItem.prototype.withProperty = function(value) {
        this['property'] = value;
        return this;
    };
    /**
     * @param value the value of 'value'
     * @returns {@link MetadataItem }
     */
    MetadataItem.prototype.withValue = function(value) {
        this['value'] = value;
        return this;
    };
    /**
     * The ConversionTarget class
     * @constructor
     * @alias ConversionTarget
     */
    function ConversionTarget() {
        /**
         * The conversionType value
         * @member
         */
        this.conversionType = null;
    
    }
    
    /**
     * @param value the value of 'conversionType'
     * @returns {@link ConversionTarget }
     */
    ConversionTarget.prototype.withConversionType = function(value) {
        var enumProperties = [];
        if (!_.contains(enumProperties, value)) {
            return this;
        }
        this['conversionType'] = value;
        return this;
    };
    /**
     * @returns {@link MetadataItem }
     */
    ConversionTarget.prototype.newMetadata = function() {
        return Object.create(MetadataItem.prototype);
    };
    /**
     * @param { MetadataItem } arrayItem the {@link MetadataItem } object to add
     * @returns {@link ConversionTarget }
     */
    ConversionTarget.prototype.addMetadata = function(arrayItem) {
        if (!this.hasOwnProperty('metadata')) {
            this['metadata'] = [];
        }
        this['metadata'].push(arrayItem);
        return this;
    };
    /**
     * The SendSchema class
     * @constructor
     * @alias SendSchema
     */
    function SendSchema() {
        /**
         * The recipient of value
         * @member
         * @type { Recipient }
         */
        this.recipient = Object.create(Recipient.prototype);
        /**
         * The messageId value
         * @member
         */
        this.messageId = null;
        /**
         * The conversionTarget of value
         * @member
         * @type { ConversionTarget }
         */
        this.conversionTarget = Object.create(ConversionTarget.prototype);
    
    }
    
    /**
     * @param value the value of 'messageId'
     * @returns {@link SendSchema }
     */
    SendSchema.prototype.withMessageId = function(value) {
        this['messageId'] = value;
        return this;
    };
    
    module.exports = SendSchema;
    
  provide("openapi-node/lib/schemas/messaging/SendSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/music/AlbumFanSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.645Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Album class
     * @constructor
     * @alias Album
     */
    function Album() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Album }
     */
    Album.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Album }
     */
    Album.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The AlbumFanSchema class
     * @constructor
     * @alias AlbumFanSchema
     */
    function AlbumFanSchema() {
        /**
         * The album of value
         * @member
         * @type { Album }
         */
        this.album = Object.create(Album.prototype);
    
    }
    
    
    
    module.exports = AlbumFanSchema;
    
  provide("openapi-node/lib/schemas/music/AlbumFanSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/music/AlbumShareSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.650Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Album class
     * @constructor
     * @alias Album
     */
    function Album() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Album }
     */
    Album.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Album }
     */
    Album.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The AlbumShareSchema class
     * @constructor
     * @alias AlbumShareSchema
     */
    function AlbumShareSchema() {
        /**
         * The album of value
         * @member
         * @type { Album }
         */
        this.album = Object.create(Album.prototype);
        /**
         * The sharedTo value
         * @member
         */
        this.sharedTo = null;
    
    }
    
    /**
     * @param value the value of 'sharedTo'
     * @returns {@link AlbumShareSchema }
     */
    AlbumShareSchema.prototype.withSharedTo = function(value) {
        var enumProperties = [];
        if (!_.contains(enumProperties, value)) {
            return this;
        }
        this['sharedTo'] = value;
        return this;
    };
    
    module.exports = AlbumShareSchema;
    
  provide("openapi-node/lib/schemas/music/AlbumShareSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/music/AlbumLyricsSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.652Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Album class
     * @constructor
     * @alias Album
     */
    function Album() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Album }
     */
    Album.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Album }
     */
    Album.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The AlbumLyricsSchema class
     * @constructor
     * @alias AlbumLyricsSchema
     */
    function AlbumLyricsSchema() {
        /**
         * The album of value
         * @member
         * @type { Album }
         */
        this.album = Object.create(Album.prototype);
    
    }
    
    
    
    module.exports = AlbumLyricsSchema;
    
  provide("openapi-node/lib/schemas/music/AlbumLyricsSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/music/TrackPlaySchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.657Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Track class
     * @constructor
     * @alias Track
     */
    function Track() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Track }
     */
    Track.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Track }
     */
    Track.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The Album class
     * @constructor
     * @alias Album
     */
    function Album() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Album }
     */
    Album.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Album }
     */
    Album.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The TrackPlaySchema class
     * @constructor
     * @alias TrackPlaySchema
     */
    function TrackPlaySchema() {
        /**
         * The track of value
         * @member
         * @type { Track }
         */
        this.track = Object.create(Track.prototype);
        /**
         * The album of value
         * @member
         * @type { Album }
         */
        this.album = Object.create(Album.prototype);
    
    }
    
    
    
    module.exports = TrackPlaySchema;
    
  provide("openapi-node/lib/schemas/music/TrackPlaySchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/music/TrackPlayedSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.663Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Track class
     * @constructor
     * @alias Track
     */
    function Track() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Track }
     */
    Track.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Track }
     */
    Track.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The Album class
     * @constructor
     * @alias Album
     */
    function Album() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Album }
     */
    Album.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Album }
     */
    Album.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The TrackPlayedSchema class
     * @constructor
     * @alias TrackPlayedSchema
     */
    function TrackPlayedSchema() {
        /**
         * The track of value
         * @member
         * @type { Track }
         */
        this.track = Object.create(Track.prototype);
        /**
         * The album of value
         * @member
         * @type { Album }
         */
        this.album = Object.create(Album.prototype);
    
    }
    
    
    
    module.exports = TrackPlayedSchema;
    
  provide("openapi-node/lib/schemas/music/TrackPlayedSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/music/TrackSkippedSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.667Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Track class
     * @constructor
     * @alias Track
     */
    function Track() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Track }
     */
    Track.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Track }
     */
    Track.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The Album class
     * @constructor
     * @alias Album
     */
    function Album() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Album }
     */
    Album.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Album }
     */
    Album.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The TrackSkippedSchema class
     * @constructor
     * @alias TrackSkippedSchema
     */
    function TrackSkippedSchema() {
        /**
         * The track of value
         * @member
         * @type { Track }
         */
        this.track = Object.create(Track.prototype);
        /**
         * The album of value
         * @member
         * @type { Album }
         */
        this.album = Object.create(Album.prototype);
    
    }
    
    
    
    module.exports = TrackSkippedSchema;
    
  provide("openapi-node/lib/schemas/music/TrackSkippedSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/schemas/music/TrackShareSchema.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 2014-09-04T10:16:59.672Z
    **/
    var _ = require('lodash-node');
    
    /**
     * The Track class
     * @constructor
     * @alias Track
     */
    function Track() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Track }
     */
    Track.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Track }
     */
    Track.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The Album class
     * @constructor
     * @alias Album
     */
    function Album() {
        /**
         * The name value
         * @member
         */
        this.name = null;
        /**
         * The id value
         * @member
         */
        this.id = null;
    
    }
    
    /**
     * @param value the value of 'name'
     * @returns {@link Album }
     */
    Album.prototype.withName = function(value) {
        this['name'] = value;
        return this;
    };
    /**
     * @param value the value of 'id'
     * @returns {@link Album }
     */
    Album.prototype.withId = function(value) {
        this['id'] = value;
        return this;
    };
    /**
     * The TrackShareSchema class
     * @constructor
     * @alias TrackShareSchema
     */
    function TrackShareSchema() {
        /**
         * The track of value
         * @member
         * @type { Track }
         */
        this.track = Object.create(Track.prototype);
        /**
         * The album of value
         * @member
         * @type { Album }
         */
        this.album = Object.create(Album.prototype);
        /**
         * The sharedTo value
         * @member
         */
        this.sharedTo = null;
    
    }
    
    /**
     * @param value the value of 'sharedTo'
     * @returns {@link TrackShareSchema }
     */
    TrackShareSchema.prototype.withSharedTo = function(value) {
        var enumProperties = [];
        if (!_.contains(enumProperties, value)) {
            return this;
        }
        this['sharedTo'] = value;
        return this;
    };
    
    module.exports = TrackShareSchema;
    
  provide("openapi-node/lib/schemas/music/TrackShareSchema.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/WixConnect.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @file core library for connecting to Wix REST APIs
     * @author David Zuckerman <davidz@wix.com>
     * @module wix/connect
     * */
    
    var crypto = require('crypto');
    var urlLib = require('url');
    var _ = require('lodash-node');
    
    var EXTERNAL_URL = 'openapi.wix.com';
    
    function signData(key, data) {
        var hmac = crypto.createHmac('sha256', key);
        return toBase64Safe(hmac.update(data).digest('base64'));
    }
    
    function toBase64Safe(out, encoding) {
        if(out instanceof Buffer) {
            return toBase64Safe(out.toString((encoding !== undefined ? encoding : 'base64')));
        }
        return out.replace(/\+/g,'-').replace(/\//g,'_').replace('=','')
    }
    
    function WixPaths() {
        this.paths = [];
    }
    
    WixPaths.prototype = {
        withSegment : function(segment) {
            if(segment && segment !== null && segment.length > 0) {
                this.paths.push(segment);
            }
            return this;
        },
        toString : function() {
            return this.paths.join('/');
        }
    };
    
    function WixParameters(copy) {
        if(copy !== undefined && copy instanceof WixParameters) {
            this.params =   copy.params.slice(0)
        } else {
            this.params = [];
        }
    }
    
    WixParameters.prototype = {
        withParameter : function(name, value) {
            var normalizedValue;
            if(Array.isArray(value)) {
                normalizedValue =  value.join(',');
            } else if('string' === typeof value) {
                normalizedValue = value.trim();
            } else {
                normalizedValue = value;
            }
            this.params.push({param: name, value: normalizedValue});
            return this;
        },
        getParameters : function() {
            return this.params;
        },
        withParameters : function(params) {
            this.params = this.params.concat(params);
            return this;
        },
        toQueryString : function() {
            return _.reduce(this.params, function(queryOut, element) {
                return queryOut + ((queryOut.length > 0) ? '&' : '') + element.param + '=' + element.value;
            }, '');
        },
        toHeaderMap : function() {
            if(this.params.length === 0) {
                return null;
            }
            var r = {};
            for(var i = 0; i < this.params.length; i++) {
                r[this.params[i].param] = this.params[i].value;
            }
            return r;
        }
    };
    
    function WixAPIRequest(verb, path, secretKey, appId, instanceId) {
        this.paths = new WixPaths();
        this.additionalParams = new WixParameters();
        this.versionNumber = '1.0.0';
        this.key = secretKey;
        this.verb = verb;
        this.path = path;
        this.appId = appId;
        this.instanceId = instanceId;
        this.postData = null;
        this.timestamp = new Date().toISOString();
        this.wixParamMode = 'header'
    }
    
    WixAPIRequest.prototype = {
        withPostData : function(data) {
            this.postData = data;
            return this;
        },
        asWixHeaders : function() {
            this.wixParamMode = 'header';
            return this;
        },
        asWixQueryParams : function() {
            this.wixParamMode = 'query';
        },
        isHeaderMode : function() {
            return this.wixParamMode === 'header';
        },
        isQueryMode : function() {
            return this.wixParamMode === 'query';
        },
        withPathSegment : function(segment) {
            this.paths.withSegment(segment);
            return this;
        },
        withQueryParam : function(key, value) {
            this.additionalParams.withParameter(key, value);
            return this;
        },
        withVersionNumber : function(number) {
            this.versionNumber = number;
            return this;
        },
        getHeaders : function() {
            var headers = new WixParameters();
            if(this.isHeaderMode()) {
                headers.withParameter('x-wix-application-id', this.appId).
                    withParameter('x-wix-instance-id', this.instanceId).
                    withParameter('x-wix-timestamp', this.timestamp);
            }
            var allHeaders = new WixParameters(headers);
            if(this.postData !== undefined && this.postData !== null) {
                allHeaders.withParameter('Content-Length', JSON.stringify(this.postData).length).
                    withParameter('Content-Type', 'application/json');
            }
    
            return { wix: headers, all: allHeaders };
        },
        getQueryParams : function() {
            var parameters = new WixParameters();
            parameters.withParameter('version', this.versionNumber).
                withParameters(this.additionalParams.getParameters());
            if(this.isQueryMode()) {
                parameters.withParameter('application-id', this.appId).
                    withParameter('instance-id', this.instanceId).
                    withParameter('timestamp', this.timestamp);
            }
            return parameters;
        },
        calculateSignature : function() {
            var headers = this.getHeaders().wix.getParameters();
            var parameters = this.getQueryParams().params.concat(headers);
            parameters.sort(function(a, b) {
                if(a.param < b.param) return -1;
                if(a.param > b.param) return 1;
                return 0;
            });
            var out = this.verb + "\n" + urlLib.parse(this.path + this.paths.toString()).pathname + "\n" + _.pluck(parameters, 'value').join('\n');
            if(this.postData) {
                out += "\n" + this.postData;
            }
            return signData(this.key, out);
        },
        toHttpsOptions : function() {
            var sig = this.calculateSignature();
            var headers = this.getHeaders();
            var query = this.getQueryParams();
            if(this.isHeaderMode()) {
                headers.all.withParameter('x-wix-signature', sig);
            } else {
                query.withParameter('signature', sig);
            }
    
            return {
                host: EXTERNAL_URL,
                path: this.path + this.paths.toString() + '?' + query.toQueryString(),
                method: this.verb,
                headers: headers.all.toHeaderMap()
            };
        }
    };
    /**
     * Information about the requesting site
     * @typedef {Object} module:Wix/Connect.WixInstanceData
     * @alias WixInstanceData
     * @property {string} instanceId - The instanceId
     * @property {Date} signDate - the date this request was signed
     * @property {?string} uid - The ID of the site-member that is currently logged in (optional)
     * @property {string} permissions - The permission set of the site member. At this point, the permissions have the value OWNER if the uid is of the site owner. Otherwise, the permissions member will be empty.
     * @property {string} vendorProductId - Premium Package ID, as was entered in the Dev Center during the app registration process
     * @alias WixInstanceData
     */
    
    /**
     * A callback that validates that a date sent from Wix is within a certain range.  Defaults to 30 seconds
     *
     * @callback module:Wix/Connect~WixDateValidator
     * @param {Date} date - the Date from the signed Wix request
     */
    
    /** @module Wix/Connect **/
    module.exports = {
        createRequest : function(verb, path, secretKey, appId, instanceId) {
            return new WixAPIRequest(verb, path, secretKey, appId, instanceId);
        },
        /**
         * Parses a Wix instance and verifies the data.  Either returns an object or throws an exception
         * @static
         * @param {string} instance - the instance parameter sent by Wix
         * @param {string} secret - your application's secret key
         * @param {?module:Wix/Connect~WixDateValidator} validator - an optional data validator
         * @returns {module:Wix/Connect.WixInstanceData} - a JSON object containing information from Wix about the requester
         * @throws an exception if signatures don't match
         */
        parseInstance : function(instance, secret, validator) {
            // spilt the instance into signature and data
    
            if (instance === null || typeof secret !== 'string' || instance.split('.').length !== 2) {
                throw {
                    name: "WixSignatureException",
                    message: "Missing instance or secret key"
                }
            }
            var pair = instance.split('.');
            var signature = new Buffer(pair[0], 'base64');
            // sign the data using hmac-sha1-256
            var data = pair[1];
            var newSignature = signData(secret, data);
    
            if (toBase64Safe(signature) !== newSignature.toString()) {
                throw {
                    name: "WixSignatureException",
                    message: "Signatures do not match, requester is most likely not Wix"
                };
            }
            var jsonData = JSON.parse(toBase64Safe(new Buffer(data, 'base64'), 'utf8'));
    
            if (typeof validator !== 'function') {
                validator = function (date) {
                    return (Date.now() - date.getTime()) <= (1000 * 60 * 60 * 24 * 2); // 2 days
                };
            }
            if (validator(new Date(jsonData.signDate))) {
                return jsonData;
            }
            throw {
                name: "WixSignatureException",
                message: "Signatures date has expired"
            };
        },
        /**
         * The URL for the Wix RESTful API
         * @static
         * @member
         */
        WIX_API_ENTRY_POINT : EXTERNAL_URL
    };
    
  provide("openapi-node/lib/WixConnect.js", module.exports);
}(global));

// pakmanager:openapi-node/lib/SchemaFactory.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
    THIS IS A GENERATED FILE, DO NOT EDIT THIS
    
    Generated on 
    **/
    var ContactFormSchema =  require('openapi-node/lib/schemas/contacts/ContactFormSchema.js');
    var ContactCreateSchema =  require('openapi-node/lib/schemas/contacts/ContactCreateSchema.js');
    var ConversionCompleteSchema =  require('openapi-node/lib/schemas/conversion/ConversionCompleteSchema.js');
    var PurchaseSchema =  require('openapi-node/lib/schemas/e_commerce/PurchaseSchema.js');
    var HotelPurchaseSchema =  require('openapi-node/lib/schemas/hotels/HotelPurchaseSchema.js');
    var HotelPurchaseFailedSchema =  require('openapi-node/lib/schemas/hotels/HotelPurchaseFailedSchema.js');
    var HotelCancelSchema =  require('openapi-node/lib/schemas/hotels/HotelCancelSchema.js');
    var HotelConfirmationSchema =  require('openapi-node/lib/schemas/hotels/HotelConfirmationSchema.js');
    var SendSchema =  require('openapi-node/lib/schemas/messaging/SendSchema.js');
    var AlbumFanSchema =  require('openapi-node/lib/schemas/music/AlbumFanSchema.js');
    var AlbumShareSchema =  require('openapi-node/lib/schemas/music/AlbumShareSchema.js');
    var AlbumLyricsSchema =  require('openapi-node/lib/schemas/music/AlbumLyricsSchema.js');
    var TrackPlaySchema =  require('openapi-node/lib/schemas/music/TrackPlaySchema.js');
    var TrackPlayedSchema =  require('openapi-node/lib/schemas/music/TrackPlayedSchema.js');
    var TrackSkippedSchema =  require('openapi-node/lib/schemas/music/TrackSkippedSchema.js');
    var TrackShareSchema =  require('openapi-node/lib/schemas/music/TrackShareSchema.js');
    
    function createSchemaObject(type) {
    
        if (type === 'contact/contact-form') {
            return new ContactFormSchema();
        }
        if (type === 'contacts/create') {
            return new ContactCreateSchema();
        }
        if (type === 'conversion/complete') {
            return new ConversionCompleteSchema();
        }
        if (type === 'e_commerce/purchase') {
            return new PurchaseSchema();
        }
        if (type === 'hotels/purchase') {
            return new HotelPurchaseSchema();
        }
        if (type === 'hotels/purchase-failed') {
            return new HotelPurchaseFailedSchema();
        }
        if (type === 'hotels/cancel') {
            return new HotelCancelSchema();
        }
        if (type === 'hotels/confirmation') {
            return new HotelConfirmationSchema();
        }
        if (type === 'messaging/send') {
            return new SendSchema();
        }
        if (type === 'music/album-fan') {
            return new AlbumFanSchema();
        }
        if (type === 'music/album-share') {
            return new AlbumShareSchema();
        }
        if (type === 'music/track-lyrics') {
            return new AlbumLyricsSchema();
        }
        if (type === 'music/track-play') {
            return new TrackPlaySchema();
        }
        if (type === 'music/track-played') {
            return new TrackPlayedSchema();
        }
        if (type === 'music/track-share') {
            return new TrackSkippedSchema();
        }
        if (type === 'music/track-skip') {
            return new TrackShareSchema();
        }
    
    }
    
    module.exports = createSchemaObject;
    
  provide("openapi-node/lib/SchemaFactory.js", module.exports);
}(global));

// pakmanager:openapi-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @module Wix/API
     * */
    
    "use strict";
    
    var wixconnect =  require('openapi-node/lib/WixConnect.js');
    var schemaFactory =  require('openapi-node/lib/SchemaFactory.js');
    var rest = require("restler");
    var https = require("http");
    var q = require("q");
    var _ = require('lodash-node');
    var extend = require('extend');
    
    function compactObject(o) {
        var clone = _.clone(o);
        _.each(clone, function(v, k) {
            if(!v || v === undefined || v == null || v.length == 0 || _.isEmpty(v)) {
                delete clone[k];
            }
        });
        return clone;
    };
    
    
    /**
     * A WixPagingData object is used to navigate cursored data sets returned by Wix APIs
     * @constructor
     * @class
     * @alias WixPagingData
     */
    function WixPagingData(initialResult, wixApiCallback, dataHandler) {
        this.currentData = initialResult;
        if(dataHandler !== undefined && dataHandler !== null) {
            this.resultData = _.map(initialResult.results, function(elem) {
                return dataHandler(elem);
            });
        } else {
            this.resultData = initialResult.results;
        }
    
        this.wixApiCallback = wixApiCallback;
    
        function canYieldData(data, mode) {
            if(data !== null) {
                var field = data.nextCursor;
                if(mode === 'previous') {
                    field = data.previousCursor;
                }
                return field !== null && field !== 0;
            }
            return false;
        }
    
        /**
         * Determines if this cursor can yield additional data
         * @returns {boolean}
         */
        this.hasNext = function() {
            return canYieldData(this.currentData, 'next');
        };
        /**
         * Determines if this cursor can yield previous data
         * @returns {boolean}
         */
        this.hasPrevious = function() {
            return canYieldData(this.currentData, 'previous');
        };
        /**
         * Returns the next page of data for this paging collection
         * @returns {Promise.<WixPagingData, error>}
         */
        this.next = function() {
            return this.wixApiCallback(this.currentData.nextCursor);
        };
        /**
         * Returns the previous page of data for this paging collection
         * @returns {Promise.<WixPagingData, error>}
         */
        this.previous = function() {
            return this.wixApiCallback(this.currentData.previousCursor);
        };
        /**
         * Returns an array of items represented in this page of data
         * @returns {array}
         */
        this.results = function() {
            return this.resultData;
        };
    }
    
    /**
     * Represents a Wix Activity Type, representing both the schema definition and the Wix Activity name
     * @constructor
     * @class
     * @alias ActivityType
     */
    function ActivityType(name, schema) {
        /**
         * The name of the Activity Schema
         * @member
         * @readonly
         */
        this.name = name;
        /**
         * The path to the Activity JSON Schema
         * @member
         * @readonly
         */
        this.schema = schema;
    };
    /**
     * @mixin
     * @constructor
     * @alias BaseWixAPIObject
     * @class
     */
    function BaseWixAPIObject() {
        /**
         * A collection of {@link ActivityType} objects
         * @enum {ActivityType}
         * @readonly
         */
        this.TYPES = {
            /**
             * indicates a contact form was filled out
             * @constant
             */
            CONTACT_FORM : new ActivityType("contact/contact-form"),
            /**
             * A schema for creating a contact
             * @constant
             */
            CONTACT_CREATE : new ActivityType("contacts/create"),
            /**
             * indicates a conversion with a contact was completed
             * @constant
             */
            CONVERSION_COMPLETE : new ActivityType("conversion/complete"),
            /**
             * indicates a purchase was made through ecommerce
             * @constant
             */
            ECOMMERCE_PURCHASE : new ActivityType("e_commerce/purchase"),
            /**
             * indicates a message was sent to a contact
             * @constant
             */
            SEND_MESSAGE : new ActivityType("messaging/send"),
            /**
             * indicates a contact liked an album of music
             * @constant
             */
            ALBUM_FAN : new ActivityType("music/album-fan"),
            /**
             * indicates a contact shared an album of music
             * @constant
             */
            ALBUM_SHARE : new ActivityType( "music/album-share"),
            /**
             * indicates a contact shared an album of music
             * @constant
             */
            ALBUM_PLAYED : new ActivityType( "music/album-played"),
            /**
             * indicates a contact viewed the lyrics of a song
             * @constant
             */
            TRACK_LYRICS : new ActivityType("music/track-lyrics"),
            /**
             * indicates a contact begun to play a track
             * @constant
             */
            TRACK_PLAY : new ActivityType("music/track-play"),
            /**
             * indicates a contact played a track to completion
             * @constant
             */
            TRACK_PLAYED : new ActivityType("music/track-played"),
            /**
             * indicates a contact shared a track
             * @constant
             */
            TRACK_SHARE : new ActivityType("music/track-share"),
            /**
             * indicates a contact skipped a track
             * @constant
             */
            TRACK_SKIP : new ActivityType("music/track-skip")
            ,
            /**
             * indicates a hotel reservation has been cancelled
             * @constant
             */
            HOTELS_CANCEL: new ActivityType("hotels/cancel"),
            /**
             * indicates a hotel reservation has been confirmed
             * @constant
             */
            HOTELS_CONFIRMATION: new ActivityType("hotels/confirmation"),
            /**
             * indicates a hotel purchase has been made
             * @constant
             */
            HOTELS_PURCHASE: new ActivityType("hotels/purchase"),
            /**
             * indicates a hotel purchase has failed
             * @constant
             */
            HOTELS_PURCHASE_FAILED: new ActivityType("hotels/purchase-failed"),
            /**
             * indicates an appointment has been scheduled
             * @constant
             */
            SCHEDULER_APPOINTMENT: new ActivityType("scheduler/appointment")
        };
    }
    
    /**
     * Represents an Activity in the Wix ecosystem
     * @constructor
     * @alias WixActivityData
     * @class
     */
    function WixActivityData() {
        /**
         * Information about the Activity
         * @typedef {Object} WixActivityData.ActivityDetails
         * @property {?String} additionalInfoUrl Url linking to more specific contextual information about the activity for use in the Dashboard
         * @property {?string} summary A short description about the activity for use in the Dashboard
         */
    
        /**
         * The id of the Activity
         * @member WixActivityData#id
         * @type {string}
         */
    
        /**
         * A timestamp to indicate when this Activity took place
         * @member
         * @type {Date}
         */
        this.createdAt = new Date().toISOString();
    
        /**
         * The URL where the activity was performed
         * @member
         * @type {String}
         */
        this.activityLocationUrl = null;
    
        /**
         * Information about the Activity
         * @member
         * @type {WixActivityData.ActivityDetails}
         */
        this.activityDetails = {summary : null, additionalInfoUrl : null};
    
        /**
         * The type of Activity
         * @member
         * @type {string}
         */
        this.activityType = null;
    
        /**
         * Schema information about the Activity
         * @member
         * @type {Object}
         */
        this.activityInfo = null;
        /**
         * @private
         */
        this.init = function(obj) {
            this.activityType = { name: obj.activityType };
            this.activityDetails = obj.activityDetails;
            this.activityInfo = obj.activityInfo;
            this.id = obj.id;
            this.activityLocationUrl = obj.activityLocationUrl;
            this.createdAt = obj.createdAt;
            return this;
        };
    }
    
    /**
     * Represents a new Activity in the Wix ecosystem, allowing for easy construction and creation
     * @mixes BaseWixAPIObject
     * @mixes WixActivityData
     * @constructor
     * @alias WixActivity
     * @class
     */
    function WixActivity() {
    
        /**
         * Updates to the existing contact that performed this activity. The structure of this object should match the schema for Contact, with the relevant fields updated.
         * @member
         * @type {Object}
         */
        this.contactUpdate = schemaFactory(this.TYPES.CONTACT_CREATE.name);
        /**
         * Configures this Activity with a given type
         * @param {ActivityType} type the type of the Activity to create
         * @returns {WixActivity}
         */
        this.withActivityType = function(type) {
            this.activityType = type.name;
            this.activityInfo = schemaFactory(type.name);
            return this;
        };
    
        /**
         * Configures the activityLocationUrl of this Activity
         * @param {string} url The URL of the Activities location
         * @returns {WixActivity}
         */
        this.withLocationUrl = function(url) {
            this.activityLocationUrl = url;
            return this;
        };
    
        /**
         * Configures the details of this Activity
         * @param {string} summary A summary of this Activity
         * @param {string} additionalInfoUrl a link to additional information about this Activity
         * @returns {WixActivity}
         */
        this.withActivityDetails = function(summary, additionalInfoUrl) {
            if(summary !== null && summary !== undefined) {
                this.activityDetails.summary = summary;
            }
            if(additionalInfoUrl !== null && additionalInfoUrl !== undefined) {
                this.activityDetails.additionalInfoUrl = additionalInfoUrl;
            }
            return this;
        };
    
        var readOnlyTypes = [
            this.TYPES.CONTACT_CREATE.name
        ];
        this.isWritable = function() {
            return (readOnlyTypes.indexOf(this.activityType) == -1);
        };
    
        this.isValid = function() {
            //TODO provide slightly better validation
            return this.activityLocationUrl !== null
                && this.activityType !== null
                && this.activityDetails.summary !== null
                && this.createdAt !== null
                && this.activityDetails.additionalInfoUrl !== null;
        };
    
        /**
         * Posts the Activity to Wix.  Returns a Promise for an id
         * @param {string} sessionToken The current session token for the active Wix site visitor
         * @param {Wix} wix A Wix API object
         * @returns {Promise.<string, error>} A new id, or an error
         */
        this.post = function(sessionToken, wix) {
            return wix.Activities.postActivity(this, sessionToken);
        };
    
        function removeNulls(obj){
            var isArray = obj instanceof Array;
            for (var k in obj){
                if (obj[k]===null) isArray ? obj.splice(k,1) : delete obj[k];
                else if (typeof obj[k]=="object") removeNulls(obj[k]);
            }
        }
    
        this.toJSON = function() {
            var _this = this;
            removeNulls(_this.contactUpdate);
            removeNulls(_this.activityInfo);
            return {
                createdAt : _this.createdAt,
                activityType : _this.activityType,
                contactUpdate : _this.contactUpdate,
                activityLocationUrl : _this.activityLocationUrl,
                activityDetails : _this.activityDetails,
                activityInfo: _this.activityInfo
            };
        };
    };
    WixActivity.prototype = new BaseWixAPIObject();
    /**
     * @mixin
     * @mixes BaseWixAPIObject
     * @constructor
     * @class
     * @alias WixAPICaller
     */
    function WixAPICaller() {
        /**
         * @private
         */
        this.withAppId = function(appId) {
            this.appId = appId;
            return this;
        };
        /**
         * @private
         */
        this.withSecretKey = function(secretKey) {
            this.secretKey = secretKey;
            return this;
        };
        /**
         * @private
         */
        this.withInstanceId = function(instanceId) {
            this.instanceId = instanceId;
            return this;
        };
        this.createRequest = function(verb, path) {
            return new wixconnect.createRequest(verb, path, this.secretKey, this.appId, this.instanceId);
        };
        this.resourceRequest = function(request, callback) {
            var deferred = q.defer();
            request.asWixQueryParams();
            var options = request.toHttpsOptions();
            rest.get('https://' + options.host + options.path,
                {
                    headers : options.headers
                }
            ).on('complete', function(data, response) {
                    if(response.statusCode !== 200) {
                        deferred.reject(data);
                    } else {
                        deferred.resolve((callback !== null) ? callback(data) : data);
                    }
                }).on('error', function(data) {
                    deferred.reject(data);
                });
            return deferred.promise;
        };
        /**
         * An enum of Scope options
         * @readonly
         * @enum {string}
         */
        this.Scope = {
            /**
             * The full site
             * @constant
             * @default
             */
            SITE : "site",
            /**
             * The calling application
             * @constant
             * @default
             */
            APP : "app"
        }
    }
    WixAPICaller.prototype = new BaseWixAPIObject();
    
    
    /**
     * Handles interactions with the Activities RESTful API
     * @class
     * @mixes WixAPICaller
     * @constructor
     * @alias Activities
     */
    function Activities(wixApi) {
    
        if (!(wixApi instanceof Wix)){
            throw 'WixApi must be provided'
        }
        var wixApi = wixApi;
        this.wixApi = function() {
            return wixApi;
        };
    
        /**
         * Creates a new WixActivity for the given {@link ActivityType}
         * @method
         * @param {ActivityType} type the type of Activity
         * @returns {WixActivity} returns an empty Wix Activity
         */
        this.newActivity = function(type) {
            var wao = new WixActivity();
            extend(wao, new WixActivityData());
            return wao.withActivityType(type);
        };
    
        /**
         * Posts the Activity to Wix.  Returns a Promise for an id
         * @param {WixActivity} activity the Activity to post to Wix
         * @param {string} userSessionToken The current session token for active Wix user
         * @returns {Promise.<string, error>} A new id, or an error
         */
        this.postActivity = function(activity, userSessionToken) {
            if(!(activity instanceof WixActivity)) {
                throw 'WixActivity must be provided'
            }
            if(!activity.isValid()) {
                throw 'WixActivity is missing required fields'
            }
            if(!activity.isWritable()){
                throw 'Cannot post read only Activities'
            }
    
            var deferred = q.defer();
            var request = this.createRequest("POST", "/v1/activities");
    
            request.withPostData(JSON.stringify(activity.toJSON()));
            request.withQueryParam("userSessionToken", userSessionToken);
            request.asWixQueryParams();
            var options = request.toHttpsOptions();
            rest.postJson('https://' + options.host + options.path, activity, {
                headers : options.headers
            }).on('complete', function(data, response) {
                if(response.statusCode === 200) {
                    deferred.resolve(data.activityId);
                } else {
                    deferred.reject(data);
                }
    
            }).on('error', function(data) {
                deferred.reject(data);
            });
            return deferred.promise;
        };
        /**
         * Returns an Activity by a given ID
         * @param {string} activityId The id of the Activity to return
         * @returns {Promise.<WixActivity, error>} An Activity, or an error
         */
        this.getActivityById = function(activityId) {
            if (activityId === undefined || activityId == null || activityId.length == 0){
                throw "Activity Id must be provided"
            }
            return this.resourceRequest(this.createRequest("GET", "/v1/activities/").withPathSegment(activityId),
            function(data) {
                return new WixActivityData().init(data);
            });
        };
    
        /**
         * Get Activities Query Options
         * @typedef {Object} GetActivitiesOptions
         * @property {?Number} pageSize - The number of results to return per page of data. Valid options are: 25, 50 and 100. Defaults to 25
         * @property {?string} activityTypes - The activity types to filter against. Multiple activity types are separated by a comma
         * @property {?dateTime} until - The ending date for activities we want to return, as an ISO 8601 timestamp This field is only relevant when a cursor is not present
         * @property {?dateTime} from - The     beginning date for activities we want to return, as an ISO 8601 timestamp. This field is only relevant when a cursor is not present
         * @property {?string} scope - The scope of the results to return, either for the entire site or limited to the current application. Can either be site or app. By default, all activities for the site will be returned
         */
    
        /**
         * Navigates the Activities found on the current site
         * @param {string} cursor The current cursor
         * @param options {GetActivitiesOptions} The Activity to post
         * @returns {Promise.<WixPagingData, error>} A promise for a {@link WixPagingData} object to navigate results, or an error
         */
        this.getActivities = function(cursor, options) {
            var request = this.createRequest("GET", "/v1/activities");
            if(cursor !== undefined && cursor !== null) {
                request.withQueryParam("cursor", cursor);
            }
            if(options !== undefined && options !== null) {
                if(options.from !== undefined && options.from !== null) {
                    request.withQueryParam("from", options.from);
                }
                if (options.until !== undefined && options.until !== null) {
                    request.withQueryParam("until", options.until);
                }
                if (options.scope !== undefined && options.scope !== null) {
                    request.withQueryParam("scope", options.scope);
                }
                if (options.activityTypes !== undefined && options.activityTypes !== null) {
                    request.withQueryParam("activityTypes", options.activityTypes);
                }
            }
            var wixApi = this;
            return this.resourceRequest(request, function(data) {
                return new WixPagingData(data, function(cursor) {
                    return wixApi.getActivities(cursor, null);
                }, function(elem) {
                    return new WixActivityData().init(elem);
                });
            });
        };
    
        /**
         * Returns a list of all activity types contained within the Wix system
         * @returns {Promise.<Array.<string>, error>} A promise for an array of strings
         */
        this.getTypes = function() {
            return this.resourceRequest(this.createRequest("GET", "/v1/activities/types"), null);
        }
    };
    
    Activities.prototype = new WixAPICaller();
    
    /**
     * @constructor
     * @class
     * @alias Contacts
     */
    function Contacts(wixApi) {
    
        this.EMAIL_STATUS_TYPES = {
            /**
             * indicates a contact form was filled out
             * @constant
             */
            TRANSACTIONAL : "transactional",
            RECURRING : "recurring",
            OPT_OUT : "optOut"
        };
    
        /**
         * Returns a Contact by a given ID
         * @param {string} contactId The id of the Contact to return
         * @returns {Promise.<Object, error>} A Contact, or an error
         */
        this.getContactById = function(contactId) {
            var deferred = q.defer();
            var wixApi = this;
            this.resourceRequest(this.createRequest("GET", "/v1/contacts/").withPathSegment(contactId), null).then(
                function(data){
                    var contact = new Contact(wixApi, data);
                    deferred.resolve(contact);
                },
                function(error){
                    deferred.reject(error);
                }
            );
            return deferred.promise;
        };
    
        /**
         * Get Contacts Query Options
         * @typedef {Object} GetContactsOptions
         * @property {?Number} pageSize - The number of results to return per page of data. Valid options are: 25, 50 and 100. Defaults to 25
         */
    
        /**
         * Returns the Contacts found on the current site
         * @param {string} cursor The current cursor
         * @param {GetContactsOptions} options getContacts query options
         * @returns {Promise.<WixPagingData, error>} A promise for a {@link WixPagingData} object to navigate results, or an error
         */
        this.getContacts = function(cursor, options) {
            var request = this.createRequest("GET", "/v1/contacts");
            if(cursor !== undefined && cursor !== null) {
                request.withQueryParam("cursor", cursor);
            }
            if(options !== undefined && options !== null) {
                if(options.pageSize !== undefined && options.pageSize !== null) {
                    request.withQueryParam("pageSize", options.pageSize);
                }
            }
            var wixApi = this;
            return this.resourceRequest(request, function(data) {
                return new WixPagingData(data, function(cursor) {
                    return wixApi.getContacts(cursor);
                });
            });
        };
    
        /**
         * Get Contacts Subscribers Query Options
         * @typedef {Object} GetContactsSubscribersOptions
         * @property {?Number} pageSize - The number of results to return per page of data. Valid options are: 25, 50 and 100. Defaults to 25
         * @property {?String} subscriberStatus - The contact's subscription status in relation to the site. Can either be notSet or optIn. By default, contacts who have explicitly opted in will be returned.
         */
    
        /**
         * Returns all the Contacts for the given site that have opted in to receiving communications from applications
         * @param {string} cursor The current cursor
         * @param {GetContactsSubscribersOptions} options getContactsSubscribers query options
         * @returns {Promise.<WixPagingData, error>} A promise for a {@link WixPagingData} object to navigate results, or an error
         */
        this.getContactsSubscribers = function(cursor, options) {
            var request = this.createRequest("GET", "/v1/contacts/subscribers");
            if(cursor !== undefined && cursor !== null) {
                request.withQueryParam("cursor", cursor);
            }
            if(options !== undefined && options !== null) {
                if (options.pageSize !== undefined && options.pageSize !== null) {
                    request.withQueryParam("pageSize", options.pageSize);
                }
                if (options.subscriberStatus !== undefined && options.subscriberStatus !== null) {
                    request.withQueryParam("status", options.subscriberStatus);
                }
            }
            var wixApi = this;
            return this.resourceRequest(request, function(data) {
                return new WixPagingData(data, function(cursor) {
                    return wixApi.getContacts(cursor);
                });
            });
        };
    
        /**
         * Creates a new Contact and returns back the ID
         * @param {object} contact JSON representing the Contact
         * @returns {Promise.<Object, error>} A new Contact, or an error
         */
        this.create = function(contact) {
            var wix = this;
            var request = this.createRequest("POST", "/v1/contacts");
            var deferred = q.defer();
            request.withPostData(JSON.stringify(contact.toJson()));
            request.asWixHeaders();
            var options = request.toHttpsOptions();
            rest.postJson('https://' + options.host + options.path, contact.toJson(), {
                headers : options.headers
            }).on('complete', function(data, response) {
                if(response.statusCode === 200) {
    
                    deferred.resolve(data.contactId);
    
                } else {
                    deferred.reject(data);
                }
    
            }).on('error', function(data, response) {
                deferred.reject(data);
            });
            return deferred.promise;
        };
    
    
        /**
         * Checks for the existence of a Contact by either phone, email or both properties.
         * If the Contact exists with the values you have specified, it will be returned.
         * If email and phone are specified, a Contact will only be returned if both properties match.
         * If no match is found, a new Contact will be created
         * @param {String} phone The contact phone to match with
         * @param {String} email The contact email to match with
         * @returns {Promise.<Object, error>} A Contact id, or an error
         */
        this.upsert = function(phone, email) {
    
            var upsertData = {
                phone: phone,
                email: email
            };
            upsertData = compactObject(upsertData);
    
            if (!upsertData.phone && !upsertData.email) {
                throw 'Missing properties: This method checks for the existence of a Contact by either phone, email or both properties.'
            }
    
            var request = this.createRequest("PUT", "/v1/contacts");
            var deferred = q.defer();
            request.withPostData(JSON.stringify(upsertData));
            request.asWixHeaders();
            var options = request.toHttpsOptions();
            rest.putJson('https://' + options.host + options.path, upsertData, {
                headers : options.headers
            }).on('complete', function(data, response) {
                if(response.statusCode === 200) {
    
                    deferred.resolve(data.contactId);
                } else {
                    deferred.reject(data);
                }
    
            }).on('error', function(data, response) {
                deferred.reject(data);
            });
            return deferred.promise;
        };
    
        /**
         * Creates a Contact object
         * @returns {object} Returns an empty Contact object
         */
        this.newContact = function() {
            return new Contact(this);
        };
    }
    Contacts.prototype = new WixAPICaller();
    
    /**
     * Contact Name information
     * @typedef {Object} Contact.Name
     * @property {string} prefix - The prefix of the contact's name
     * @property {string} first - The contact's first name
     * @property {string} middle - The contact's middle name
     * @property {string} last - The contact's last name
     * @property {string} suffix - The suffix of the contact's name
     */
    function Name(obj){
        this._prefix = obj && obj.prefix;
        this._first = obj && obj.first;
        this._last = obj && obj.last;
        this._middle = obj && obj.middle;
        this._suffix = obj && obj.suffix;
    }
    Name.prototype.prefix = function (str) {
        if (str !== undefined) this._prefix = str;
        return this._prefix;
    };
    Name.prototype.first = function (str) {
        if (str !== undefined) this._first = str;
        return this._first;
    };
    Name.prototype.last = function (str) {
        if (str !== undefined) this._last = str;
        return this._last;
    };
    Name.prototype.middle = function (str) {
        if (str !== undefined) this._middle = str;
        return this._middle;
    };
    Name.prototype.suffix = function (str) {
        if (str !== undefined) this._suffix = str;
        return this._suffix;
    };
    Name.prototype.toJson = function() {
        var retVal = {
            prefix: this.prefix(),
            first: this.first(),
            middle: this.middle(),
            last: this.last(),
            suffix: this.suffix()
        };
        return compactObject(retVal);
    };
    
    
    /**
     * Contact Company information
     * @typedef {Object} Contact.Company
     * @property {string} role - The contact's role within their company,
     * @property {string} name - The name of the contact's current company
     */
    function Company(obj){
        this._role = obj && obj.role;
        this._name = obj && obj.name;
    }
    Company.prototype.role = function (str) {
        if (str !== undefined)
            this._role = str;
        return this._role;
    };
    Company.prototype.name = function (str) {
        if (str !== undefined)
            this._name = str;
        return this._name;
    };
    Company.prototype.toJson = function() {
        if (this.name() || this.role()){
            var retVal = {
                role: this.role(),
                name: this.name()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact Email information
     * @typedef {Object} Contact.Email
     * @property {string} tag - a context tag
     * @property {string} email - The email address to add
     * @property {string} contactSubscriptionStatus - The subscription status of the current contact ['optIn' or 'optInOut' or 'notSet']
     * @property {string} siteOwnerSubscriptionStatus - The subscription status of the site owner in relation to this contact ['optIn' or 'optInOut' or 'notSet']
     */
    function Email(obj){
        this._id = obj && obj.id;
        this._tag = obj && obj.tag;
        this._email = obj && obj.email;
        this._emailStatus = obj && obj.emailStatus;
    
        if (this._tag == undefined || this._tag == null){
            throw 'Tag is a required field'
        }
        if (this._email == undefined || this._email == null){
            throw 'Email is a required field'
        }
        if (this._emailStatus == undefined || this._emailStatus == null){
            throw 'Email status is a required field'
        }
    }
    
    Email.prototype.id = function () {
        return this._id;
    };
    Email.prototype.tag = function (str) {
        if (str !== undefined && str !== null)
            this._tag = str;
        return this._tag;
    };
    Email.prototype.email = function (str) {
        if (str !== undefined && str !== null)
            this._email = str;
        return this._email;
    };
    Email.prototype.emailStatus = function (str) {
        if (str !== undefined)
            this._emailStatus = str;
        return this._emailStatus;
    };
    Email.prototype.toJson = function() {
        if (this.tag() || this.email() || this.emailStatus()) {
            var retVal = {
                id: this.id(),
                tag: this.tag(),
                email: this.email(),
                emailStatus: this.emailStatus()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact Phone information
     * @typedef {Object} Contact.Phone
     * @property {string} tag - a context tag
     * @property {string} phone - The phone number to add
     * @property {string} normalizedPhone - The contact's normalized phone number
     */
    function Phone(obj){
        this._id = obj && obj.id;
        this._tag = obj && obj.tag;
        this._phone = obj && obj.phone;
        this._normalizedPhone = obj && obj.normalizedPhone;
    }
    Phone.prototype.id = function () {
        return this._id;
    };
    Phone.prototype.tag = function (str) {
        if (str !== undefined)
            this._tag = str;
        return this._tag;
    };
    Phone.prototype.phone = function (str) {
        if (str !== undefined && str !== null)
            this._phone = str;
        return this._phone;
    };
    Phone.prototype.normalizedPhone = function (str) {
        if (str !== undefined && str !== null)
            this._normalizedPhone = str;
        return this._normalizedPhone;
    };
    Phone.prototype.toJson = function() {
        if (this.tag() || this.phone() || this.normalizedPhone()) {
            var retVal = {
                id: this.id(),
                tag: this.tag(),
                phone: this.phone(),
                normalizedPhone: this.normalizedPhone()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact Address information
     * @typedef {Object} Contact.Address
     * @property {String} tag - The context tag associated with this address,
     * @property {?String} address - The contact's street address,
     * @property {?String} neighborhood - The contact's street neighborhood,
     * @property {?String} city - The contact's city,
     * @property {?String} region - The contact's region. An example of this would be a state in the US, or a province in Canada,
     * @property {?String} country - The contact's country,
     * @property {?Number} postalCode - The contact's postal code
     */
    function Address(obj){
        this._id = obj && obj.id;
        this._tag = obj && obj.tag;
        this._address = obj && obj.address;
        this._city = obj && obj.city;
        this._neighborhood = obj && obj.neighborhood;
        this._region = obj && obj.region;
        this._country = obj && obj.country;
        this._postalCode = obj && obj.postalCode;
    }
    Address.prototype.id = function () {
        return this._id;
    };
    Address.prototype.tag = function (str) {
        if (str !== undefined && str !== null)
            this._tag = str;
        return this._tag;
    };
    Address.prototype.address = function (str) {
        if (str !== undefined && str !== null)
            this._address = str;
        return this._address;
    };
    Address.prototype.neighborhood = function (str) {
        if (str !== undefined && str !== null)
            this._neighborhood = str;
        return this._neighborhood;
    };
    Address.prototype.city = function (str) {
        if (str !== undefined && str !== null)
            this._city = str;
        return this._city;
    };
    Address.prototype.region = function (str) {
        if (str !== undefined && str !== null)
            this._region = str;
        return this._region;
    };
    Address.prototype.country = function (str) {
        if (str !== undefined && str !== null)
            this._country = str;
        return this._country;
    };
    Address.prototype.postalCode = function (str) {
        if (str !== undefined)
            this._postalCode = str;
        return this._postalCode;
    };
    Address.prototype.toJson = function() {
        if (this.tag() || this.address() || this.neighborhood() || this.city() || this.region() || this.country() || this.postalCode()){
            var retVal = {
                id: this.id(),
                tag: this.tag(),
                address: this.address(),
                neighborhood: this.neighborhood(),
                city: this.city(),
                region: this.region(),
                country: this.country(),
                postalCode: this.postalCode()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact Url information
     * @typedef {Object} Contact.Url
     * @property {string} tag - The context tag associated with this url
     * @property {string} url - A url associated with this contact
     */
    function Url(obj){
        this._id = obj && obj.id;
        this._tag = obj && obj.tag;
        this._url = obj && obj.url;
    }
    Url.prototype.id = function () {
        return this._id;
    };
    Url.prototype.tag = function (str) {
        if (str !== undefined && str !== null)
            this._tag = str;
        return this._tag;
    };
    Url.prototype.url = function (str) {
        if (str !== undefined && str !== null)
            this._url = str;
        return this._url;
    };
    Url.prototype.toJson = function() {
        if (this.tag() || this.url()){
            var retVal = {
                id: this.id(),
                tag: this.tag(),
                url: this.url()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact Link information
     * A HATEOAS link to operations applicable to this Contact resource
     * @typedef {Object} Contact.StateLink
     * @property {string} href - The href of the operation relevant to this resource
     * @property {string} rel - The relationship of this operation to the returned resource
     */
    function StateLink(obj){
        this._id = obj && obj.id;
        this._href = obj && obj.href;
        this._rel = obj && obj.rel;
    }
    StateLink.prototype.id = function () {
        return this._id;
    };
    StateLink.prototype.href = function (str) {
        if (str !== undefined && str !== null)
            this._href = str;
        return this._href;
    };
    StateLink.prototype.rel = function (str) {
        if (str !== undefined && str !== null)
            this._rel = str;
        return this._rel;
    };
    StateLink.prototype.toJson = function() {
        if (this.href() || this.rel()){
            var retVal = {
                id: this.id(),
                href: this.href(),
                rel: this.rel()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact Important Date information
     * @typedef {Object} Contact.ImportantDate
     * @property {string} tag - The context tag associated with this date
     * @property {dateTime} date - An important date for this contact, as an ISO 8601 timestamp
     */
    function ImportantDate(obj){
        this._id = obj && obj.id;
        this._tag = obj && obj.tag;
        this._date = obj && obj.date;
    }
    ImportantDate.prototype.id = function () {
        return this._id;
    };
    ImportantDate.prototype.tag = function (str) {
        if (str !== undefined && str !== null)
            this._tag = str;
        return this._tag;
    };
    ImportantDate.prototype.date = function (str) {
        if (str !== undefined && str !== null)
            this._date = str;
        return this._date;
    };
    ImportantDate.prototype.toJson = function() {
        if (this.tag() || this.date()){
            var retVal = {
                id: this.id(),
                tag: this.tag(),
                date: this.date()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * CustomField
     * @typedef {Object} Contact.CustomField
     * @property {string} field - The name of the custom field
     * @property {string} value - The value of the custom field
     */
    function CustomField(obj){
        this._id = obj && obj.id;
        this._field = obj && obj.field;
        this._value = obj && obj.value;
    }
    CustomField.prototype.id = function () {
        return this._id;
    };
    CustomField.prototype.field = function (str) {
        if (str !== undefined && str !== null)
            this._field = str;
        return this._field;
    };
    CustomField.prototype.value = function (str) {
        if (str !== undefined && str !== null)
            this._value = str;
        return this._value;
    };
    CustomField.prototype.toJson = function() {
        if (this.field() || this.value()) {
            var retVal = {
                id: this.id(),
                field: this.field(),
                value: this.value()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact Note information
     * @typedef {Object} Contact.Note
     * @property {string} tag - a context tag
     * @property {string} note - The note to add
     */
    function Note(obj){
        this._id = obj && obj.id;
        this._modifiedAt = obj && obj.modifiedAt;
        this._content = obj && obj.content;
    }
    Note.prototype.id = function () {
        return this._id;
    };
    Note.prototype.modifiedAt = function () {
        return this._modifiedAt;
    };
    Note.prototype.content = function (str) {
        if (str !== undefined && str !== null)
            this._content = str;
        return this._content;
    };
    Note.prototype.toJson = function() {
        if (this.modifiedAt() || this.content()){
            var retVal = {
                id: this.id(),
                modifiedAt: this.modifiedAt(),
                content: this.content()
            };
            return compactObject(retVal);
        } else return {};
    };
    
    /**
     * Contact ID information
     * @typedef {Object} Contact.ID
     * @property {boolean} exists - true if this id exists
     * @property {string} id - The id of this Contact
     */
    function Id(id){
        this._id = id;
    }
    Id.prototype.exists = function () {
        return (this._id !== undefined && this._id != null);
    };
    Id.prototype.id = function () {
        return this._id;
    };
    Id.prototype.toJson = function() {
        if (this.exists()) {
            return {
                id: this.id()
            };
        } else {};
    };
    
    
    /**
     * @class
     * @constructor
     * @alias Contact
     */
    var Contact = function(wixApi, obj) {
    
        if (!(wixApi instanceof WixAPICaller)){
            throw 'WixApi must be provided'
        }
        var wixApi = wixApi;
        this.wixApi = function() {
            return wixApi;
        };
    
        var name = new Name();
        this.name = function (obj) {
            if (obj !== undefined && obj != null)
                name = new Name(obj);
            return name;
        };
    
        var company = new Company();
        this.company = function (obj) {
            if (obj !== undefined && obj != null)
                company = new Company(obj);
            return company;
        };
    
        var picture;
        this.picture = function (url) {
            if (url !== undefined && url != null)
                picture = url;
            return picture;
        };
    
        var emails = [];
        this.emails = function () {
            return emails;
        };
        this.addEmail = function (email) {
            emails.push(new Email(email));
        };
    
        var phones = [];
        this.phones = function () {
            return phones;
        };
        this.addPhone = function (phone) {
            phones.push(new Phone(phone));
        };
    
        var addresses = [];
        this.addresses = function () {
            return addresses;
        };
        this.addAddress = function (address) {
            addresses.push(new Address(address));
        };
    
        var urls = [];
        this.urls = function () {
            return urls;
        };
        this.addUrl = function (url) {
            urls.push(new Url(url));
        };
    
        var links = [];
        this.links = function () {
            return links;
        };
    
        var dates = [];
        this.dates = function () {
            return dates;
        };
        this.addDate = function (date) {
            dates.push(new ImportantDate(date));
        };
    
        var customFields = [];
        this.customFields = function () {
            return customFields;
        };
        this.addCustomField = function (field) {
            customFields.push(new CustomField(field));
        };
    
        var notes = [];
        this.notes = function () {
            return notes;
        };
        this.addNote = function (note) {
            notes.push(new Note(note));
        };
    
        var id = new Id();
        this.id = function (obj) {
            if (obj !== undefined && obj != null)
                id = new Id(obj);
            return id;
        };
    
        var modifiedAt = new Date().toISOString();
        this.modifiedAt = function () {
            return modifiedAt;
        };
    
        var createdAt = new Date().toISOString();
        this.createdAt = function () {
            return createdAt;
        };
    
        this.getJson = function(array){
            var out = [];
            array.forEach(function(entry) {
                if (entry.toJson)
                    out.push(entry.toJson());
                else
                    out.push(entry);
            });
            return out;
        };
    
        var contact = this;
        if (obj && obj.id){
            this.id(obj.id);
        }
        if (obj && obj.name){
            this.name(obj.name);
        }
        if (obj && obj.company){
            this.company(obj.company);
        }
        if (obj && obj.picture){
            this.picture(obj.picture);
        }
        if (obj && obj.modifiedAt){
            modifiedAt = obj.modifiedAt;
        }
        if (obj && obj.emails && obj.emails.length > 0){
            obj.emails.forEach(function(entry) {
                contact.addEmail(entry);
            });
        }
        if (obj && obj.phones && obj.phones.length > 0){
            obj.phones.forEach(function(entry) {
                contact.addPhone(entry);
            });
        }
        if (obj && obj.addresses && obj.addresses.length > 0){
            obj.addresses.forEach(function(entry) {
                contact.addAddress(entry);
            });
        }
        if (obj && obj.urls && obj.urls.length > 0){
            obj.urls.forEach(function(entry) {
                contact.addUrl(entry);
            });
        }
        if (obj && obj.dates && obj.dates.length > 0){
            obj.dates.forEach(function(entry) {
                contact.addDate(entry);
            });
        }
        if (obj && obj.notes && obj.notes.length > 0){
            obj.notes.forEach(function(entry) {
                contact.addNote(entry);
            });
        }
        if (obj && obj.custom && obj.custom.length > 0){
            obj.custom.forEach(function(entry) {
                contact.addCustomField(entry);
            });
        }
        if (obj && obj.links && obj.links.length > 0){
            obj.links.forEach(function(entry) {
                links.push(new StateLink(entry));
            });
        }
    };
    
    /**
     * Creates a JSON Object representing the contact
     * @returns {Object} A Json object representing the Contact
     */
    Contact.prototype.toJson = function() {
        var retVal =  {
            id: this.id().toJson(),
            name: this.name().toJson(),
            company: this.company().toJson(),
            picture: this.picture(),
            emails: this.getJson(this.emails()),
            phones: this.getJson(this.phones()),
            addresses: this.getJson(this.addresses()),
            urls: this.getJson(this.urls()),
            links: this.getJson(this.links()),
            dates: this.getJson(this.dates()),
            custom: this.getJson(this.customFields()),
            notes: this.getJson(this.notes())
        };
        return compactObject(retVal);
    };
    
    Contact.prototype.saveEditedField = function(path, obj, isListField){
        var wixApi = this.wixApi();
    
        if (!this.id().exists()) {
            throw 'Contact must be saved before individual fields can be altered'
        }
        var urlPath = "/v1/contacts/" + this.id().id() + "/" + path;
        if (isListField && !obj.id()){
            throw 'Please provide a valid ' + path + ' ID or use post ' + path + ' method'
        } else if (isListField && obj.id()) {
            urlPath = "/v1/contacts/" + this.id().id() + "/" + path + "/" + obj.id();
        }
    
        var request = wixApi.createRequest("PUT", urlPath);
        var deferred = q.defer();
        request.withPostData(JSON.stringify(obj.toJson()));
        request.withQueryParam("modifiedAt", this.modifiedAt());
        request.asWixHeaders();
        var options = request.toHttpsOptions();
        rest.putJson('https://' + options.host + options.path, obj.toJson(), {
            headers : options.headers
        }).on('complete', function(data, response) {
            if(response.statusCode === 200) {
    
                var contact = new Contact(wixApi,data);
                deferred.resolve(contact);
            } else {
                deferred.reject(data);
            }
    
        }).on('error', function(data, response) {
            deferred.reject(data);
        });
        return deferred.promise;
    };
    
    Contact.prototype.saveNewField = function(path, obj) {
        var wixApi = this.wixApi();
        if (!this.id().exists()) {
            throw 'Contact must be saved before individual fields can be altered'
        }
        var request = wixApi.createRequest("POST", "/v1/contacts/" + this.id().id() + "/" + path);
        var deferred = q.defer();
        request.withPostData(JSON.stringify(obj.toJson()));
        request.withQueryParam("modifiedAt", this.modifiedAt());
        request.asWixHeaders();
        var options = request.toHttpsOptions();
        rest.postJson('https://' + options.host + options.path, obj.toJson(), {
            headers : options.headers
        }).on('complete', function(data, response) {
            if(response.statusCode === 200) {
    
                var contact = new Contact(wixApi,data);
                deferred.resolve(contact);
            } else {
                deferred.reject(data);
            }
    
        }).on('error', function(data, response) {
            deferred.reject(data);
        });
        return deferred.promise;
    };
    
    
    Contact.prototype.updateName = function(){
        return this.saveEditedField("name", this.name())
    };
    Contact.prototype.updateCompany = function(){
        return this.saveEditedField("company", this.company())
    };
    Contact.prototype.updatePicture = function(){
        var pic = this.picture();
        var picObj = {
            toJson: function(){
                return pic;
            }
        };
        return this.saveEditedField("picture", picObj)
    };
    Contact.prototype.updateEmail = function(email){
        return this.saveEditedField("email", email, true)
    };
    Contact.prototype.postEmail = function(email){
        return this.saveNewField("email", email, true)
    };
    Contact.prototype.updateAddress = function(address){
        return this.saveEditedField("address", address, true)
    };
    Contact.prototype.postAddress = function(address){
        return this.saveNewField("address", address, true)
    };
    Contact.prototype.updatePhone = function(phone){
        return this.saveEditedField("phone", phone, true)
    };
    Contact.prototype.postPhone = function(phone){
        return this.saveNewField("phone", phone, true)
    };
    Contact.prototype.updateUrl = function(url){
        return this.saveEditedField("url", url, true)
    };
    Contact.prototype.postUrl = function(url){
        return this.saveNewField("url", url, true)
    };
    Contact.prototype.updateDate = function(date){
        return this.saveEditedField("date", date, true)
    };
    Contact.prototype.postDate = function(date){
        return this.saveNewField("date", date, true)
    };
    Contact.prototype.updateNote = function(note){
        return this.saveEditedField("note", note, true)
    };
    Contact.prototype.postNote = function(note){
        return this.saveNewField("note", note, true)
    };
    Contact.prototype.updateCustomField = function(custom){
        return this.saveEditedField("custom", custom, true)
    };
    Contact.prototype.postCustomField = function(custom){
        return this.saveNewField("custom", custom, true)
    };
    
    /**
     * Checks for the existence of a Contact by either phone, email or both properties.
     * If the Contact exists with the values you have specified, it will be returned.
     * If email and phone are specified, a Contact will only be returned if both properties match.
     * If no match is found, a new Contact will be created
     * @param {object} contact JSON representing the Contact
     * @returns {Promise.<Object, error>} A new Contact, or an error
     */
    Contact.prototype.update = function() {
    
        var contact = this;
        var wixApi = this.wixApi();
    
        if (!(contact.id().exists())) {
            throw 'Contact must be created first! Use Contacts.create'
        }
    
        var request = wixApi.createRequest("PUT", "/v1/contacts/" + contact.id().id());
        var deferred = q.defer();
        request.withQueryParam("modifiedAt", this.modifiedAt());
        request.withPostData(JSON.stringify(contact.toJson()));
        request.asWixHeaders();
        var options = request.toHttpsOptions();
        rest.postJson('https://' + options.host + options.path, contact.toJson(), {
            headers : options.headers
        }).on('complete', function(data, response) {
            if(response.statusCode === 200) {
    
                var contact = new Contact(wixApi,data);
                contact.id(data.contactId);
                deferred.resolve(contact);
            } else {
                deferred.reject(data);
            }
    
        }).on('error', function(data, response) {
            deferred.reject(data);
        });
        return deferred.promise;
    
    };
    
    /**
     * Adds an Activity to this {@link Contact}. Note, the {@link Contact} must be saved for the {@link Activity} to be persisted
     * @param activity {Activity} The Activity to post
     */
    Contact.prototype.addActivity = function(activity) {
    
        if(!(activity instanceof WixActivity)) {
            throw 'WixActivity must be provided'
        }
        if(!activity.isValid()) {
            throw 'WixActivity is missing required fields'
        }
        if (!(this.id().exists())) {
            throw 'Contact must be saved first'
        }
    
        var deferred = q.defer();
        var request = this.wixApi().createRequest("POST", "/v1/contacts/" + this.id().id() + "/activities");
    
        request.withPostData(JSON.stringify(activity.toJSON()));
        request.asWixHeaders();
        var options = request.toHttpsOptions();
        rest.postJson('https://' + options.host + options.path, activity, {
            headers : options.headers
        }).on('complete', function(data, response) {
            if(response.statusCode === 200) {
                deferred.resolve(data);
            } else {
                deferred.reject(data);
            }
    
        }).on('error', function(data) {
            deferred.reject(data);
        });
        return deferred.promise;
    };
    
    /**
     * Get Activities Query Options
     * @typedef {Object} GetActivitiesOptions
     * @property {?Number} pageSize - The number of results to return per page of data. Valid options are: 25, 50 and 100. Defaults to 25
     * @property {?string} activityTypes - The activity types to filter against. Multiple activity types are separated by a comma
     * @property {?dateTime} until - The ending date for activities we want to return, as an ISO 8601 timestamp This field is only relevant when a cursor is not present
     * @property {?dateTime} from - The     beginning date for activities we want to return, as an ISO 8601 timestamp. This field is only relevant when a cursor is not present
     * @property {?string} scope - The scope of the results to return, either for the entire site or limited to the current application. Can either be site or app. By default, all activities for the site will be returned
     */
    
    /**
     * Returns a list of {@link Activity} for this contact, based on the filter. By default, all Activities are returned
     * @param {string} cursor The current cursor
     * @param options {GetActivitiesOptions} The Activity to post
     */
    Contact.prototype.getActivities = function(cursor, options) {
        if (!(this.id().exists())) {
            throw 'Contact must be saved first. An unsaved Contact has no Activities'
        }
    
        var deferred = q.defer();
        var request = this.wixApi().createRequest("GET", "/v1/contacts/" + this.id().id() + "/activities");
        request.asWixHeaders();
        if(cursor !== undefined && cursor !== null) {
            request.withQueryParam("cursor", cursor);
        }
        if(options !== undefined && options !== null) {
            if(options.from !== undefined && options.from !== null) {
                request.withQueryParam("from", options.from);
            }
            if (options.until !== undefined && options.until !== null) {
                request.withQueryParam("until", options.until);
            }
            if (options.scope !== undefined && options.scope !== null) {
                request.withQueryParam("scope", options.scope);
            }
            if (options.activityTypes !== undefined && options.activityTypes !== null) {
                request.withQueryParam("activityTypes", options.activityTypes);
            }
        }
        var options = request.toHttpsOptions();
        rest.get('https://' + options.host + options.path,
        {
            headers : options.headers
        }).on('complete', function(data, response) {
            if(response.statusCode === 200) {
                deferred.resolve(data);
            } else {
                deferred.reject(data);
            }
    
        }).on('error', function(data) {
            deferred.reject(data);
        });
        return deferred.promise;
    };
    
    /**
     * @class
     * @constructor
     * @mixes WixAPICaller
     * @alias Insights
     */
    function Insights(wixApi) {
    
        if (!(wixApi instanceof Wix)){
            throw 'WixApi must be provided'
        }
        var wixApi = wixApi;
        this.wixApi = function() {
            return wixApi;
        };
    
        /**
         * Summary information for activities performed on a site
         * @typedef {Object} Insights.ActivitySummary
         * @property {Array.<Insights.ActivityTypeSummary>} activityTypes - an array of {@link Insights.ActivityTypeCount} items
         * @property {number} total - The total number of activities
         */
    
        /**
         * Summary information for an activity type performed on a site
         * @typedef {Object} Insights.ActivityTypeSummary
         * @property {string} activityType - the activity type
         * @property {number} total - The total number of activities of the given type
         */
    
    
        /**
         * Returns the number of activity type events attributed to a specific application
         * @param {string} scope The scope of the results to return, either for the entire site or limited to the current application. Can either be site or app. By default, summary information for the current application will be returned
         * @returns {Promise.<Insights.ActivitySummary, error>} Summary information, or an error
         */
        this.getActivitiesSummary = function(scope) {
            var request = this.createRequest("GET", "/v1/insights/activities/summary");
            if(scope !== undefined && scope == this.Scope.APP || scope == this.Scope.SITE) {
                request.withQueryParam("scope", scope);
            }
            return this.resourceRequest(request, null);
        };
        /**
         *
         * @param contactId
         * @returns {*}
         */
        this.getActivitySummaryForContact = function(contactId) {
            var api = this;
            return this.resourceRequest(api.createRequest("GET", "/v1/insights/contacts")
                .withPathSegment(contactId)
                .withPathSegment("activities")
                .withPathSegment("summary"), null);
        };
    }
    Insights.prototype = new WixAPICaller();
    
    /**
     * @class
     * @alias Wix
     * @constructor
     */
    function Wix(secretKey, appId, instanceId) {
        /**
         * An interface to interact with Wix Activities
         * @public
         * @readonly
         * @member
         * @type Activities
         * */
        this.Activities = new Activities(this).withSecretKey(secretKey).withAppId(appId).withInstanceId(instanceId);
        /**
         * An interface to interact with Wix Contacts
         * @public
         * @member
         * @readonly
         * @type Contacts
         * */
        this.Contacts = new Contacts(this).withSecretKey(secretKey).withAppId(appId).withInstanceId(instanceId);
        /**
         * An interface to interact with Wix Insights
         * @public
         * @member
         * @readonly
         * @type Insights
         * */
        this.Insights = new Insights(this).withSecretKey(secretKey).withAppId(appId).withInstanceId(instanceId);
    }
    
    function throwMissingValue(paramName) {
        throw {
            name : "WixAPIException",
            message : "Missing parameter: " + paramName
        };
    }
    
    /**
     * Credentials to access the Wix API. Must specific either an instance or an instanceId property
     * @typedef {Object} APIBuilder.APICredentials
     * @alias APICredentials
     * @property {!String} secretKey Your applications Secret Key
     * @property {!string} appId Your applications App Id
     * @property {?String} instanceId Your applications instanceId
     * @property {?String} instance The instance passed to your server from Wix
     */
    
    /**
     * Builder used to create new instances of the {@link Wix} object
     * @class
     * @alias APIBuilder
     * @constructor
     */
    function APIBuilder() {
        /**
         * Creates a {@link Wix} API object with the give credentials.
         * @method
         * @param {APIBuilder.APICredentials} data JSON data containing credentials for the API
         * @throws an exception if signatures don't match when using the API with the instance param
         * @throws an exception if API credentials are missing
         * @returns {Wix} a Wix API interface object
         */
        this.withCredentials = function(data) {
            if(!data.hasOwnProperty('secretKey')) {
                throwMissingValue('secretKey');
            }
            if(!data.hasOwnProperty('appId')) {
                throwMissingValue('appId')
            }
            if(!data.hasOwnProperty('instanceId') && !data.hasOwnProperty('instance')) {
                throwMissingValue('instanceId or instance')
            }
    
            var i = null;
            if(data.hasOwnProperty('instanceId')) {
                i = data.instanceId;
            } else {
                i = wixconnect.parseInstance(data.instance, data.secretKey).instanceId;
            }
            return new Wix(data.secretKey, data.appId, i);
        };
    }
    
    /**
     * Credentials for accessing the Wix API
     * @typedef {Object} module:wix/API.WixInstanceData
     * @alias WixInstanceData
     * @property {string} instanceId - The instanceId
     * @property {Date} signDate - the date this request was signed
     * @property {?string} uid - The ID of the site-member that is currently logged in (optional)
     * @property {string} permissions - The permission set of the site member. At this point, the permissions have the value OWNER if the uid is of the site owner. Otherwise, the permissions member will be empty.
     * @property {string} vendorProductId - Premium Package ID, as was entered in the Dev Center during the app registration process
     * @alias WixInstanceData
     */
    
    module.exports = {
        /**
         * Returns an interface to the Wix API
         * @param {!String} secretKey Your applications Secret Key
         * @param {!String} appId Your applications App Id
         * @param {!String} instanceId Your applications instanceId
         *
         * @returns {Wix} Wix API interface object
         */
        getAPI : function(secretKey, appId, instanceId) {
            return new Wix(secretKey, appId, instanceId);
        },
        /**
         * Access to the {@link APIBuilder} for more control over creating a {@link Wix} object
         * @member
         * @readonly
         * @returns {APIBuilder} an APIBuilder
         */
        API : new APIBuilder(),
        /**
         * Returns an interface to a {module:Wix/Connect} module
         * @returns {module:Wix/Connect} the Wix Connect module
         */
        getConnect : function() {
            return wixconnect;
        },
        /**
         * Prototype
         */
        Contact: Contact
    };
    
  provide("openapi-node", module.exports);
}(global));